<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vee&#39;s blog</title>
  
  <subtitle>make world better !</subtitle>
  <link href="https://vee-zhang.github.io/Vee-blog/atom.xml" rel="self"/>
  
  <link href="https://vee-zhang.github.io/Vee-blog/"/>
  <updated>2021-01-19T03:26:45.381Z</updated>
  <id>https://vee-zhang.github.io/Vee-blog/</id>
  
  <author>
    <name>Vee Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GraphQl-Java(一)Schema</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/</id>
    <published>2021-01-19T02:13:53.000Z</published>
    <updated>2021-01-19T03:26:45.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p><a href="https://github.com/graphql-java/graphql-java/releases">版本列表</a></p><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.graphql-java:graphql-java:15.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Schema——大纲"><a href="#Schema——大纲" class="headerlink" title="Schema——大纲"></a>Schema——大纲</h2><p>创建一个Schema有两种方式：</p><ol><li>推荐SDL(special graphql dsl): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Foo &#123;</span><br><span class="line">    bar: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>java code: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType fooType = newObject()</span><br><span class="line">    .name(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="DataFetcher-and-TypeResolver"><a href="#DataFetcher-and-TypeResolver" class="headerlink" title="DataFetcher and TypeResolver"></a>DataFetcher and TypeResolver</h2></li></ol><p><code>DataFetcher</code>用来向field提供数据，每一个<code>field</code>都包含一个DataFetcher,默认采用<code>PropertyDataFetcher</code>。</p><p><code>PropertyDataFetcher</code> 从<code>Map</code>或者<code>Java Bean</code>中获取数据，所以当field name与map的key，或者类的元素名称的相匹配，就不需要定义<code>DataFetcher</code>了。</p><p><code>TypeResolver</code>帮助<code>graphql-java</code>判断值的类型。</p><p>想象一下，你有一个接口MagicUserType，用来解析一系列java类Wizard,Witch和Necromancer。类型检查器负责检查一个运行时对象，并且判断用哪个<code>GraphqlObjectType</code>去响应这个对象，对应的应该用哪个<code>data fetchers</code>和field去运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TypeResolver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLObjectType <span class="title">getType</span><span class="params">(TypeResolutionEnvironment env)</span> </span>&#123;</span><br><span class="line">        Object javaObject = env.getObject();</span><br><span class="line">        <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Wizard) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WizardType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Witch) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WitchType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;NecromancerType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用SDL创建一个Schema"><a href="#用SDL创建一个Schema" class="headerlink" title="用SDL创建一个Schema"></a>用SDL创建一个Schema</h2><p>当通过schema创建一个SDL，你应该定义好<code>DataFetcher</code>和<code>TypeResolver</code>。</p><p>比如创建一个starWarsSchema.graphqls:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query: QueryType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QueryType &#123;</span><br><span class="line">    hero(episode: Episode): Character</span><br><span class="line">    human(id : String) : Human</span><br><span class="line">    droid(id: ID!): Droid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum Episode &#123;</span><br><span class="line">    NEWHOPE</span><br><span class="line">    EMPIRE</span><br><span class="line">    JEDI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    homePlanet: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个静态文件<code>starWarsSchema.graphqls</code>包含了field和type的定义，但是你还需要一个<code>runtimeWiring（运行时注入）</code>来把这个静态文件转换为一个可运行的schema。</p><p><code>runtimeWiring</code>必须包含<code>DataFetcher</code>、<code>TypeResolver</code>和自定义的<code>Scalar</code>。</p><p>你可以用下面的建造者模式去创建报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">RuntimeWiring <span class="title">buildRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .scalar(CustomScalar)</span><br><span class="line">            <span class="comment">// this uses builder function lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;QueryType&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;hero&quot;</span>, <span class="keyword">new</span> StaticDataFetcher(StarWarsData.getArtoo()))</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;human&quot;</span>, StarWarsData.getHumanDataFetcher())</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;droid&quot;</span>, StarWarsData.getDroidDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            .type(<span class="string">&quot;Human&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// you can use builder syntax if you don&#x27;t like the lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;Droid&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// or full builder syntax if that takes your fancy</span></span><br><span class="line">            .type(</span><br><span class="line">                    newTypeWiring(<span class="string">&quot;Character&quot;</span>)</span><br><span class="line">                            .typeResolver(StarWarsData.getCharacterTypeResolver())</span><br><span class="line">                            .build()</span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，你可以把静态的大纲和注入结合到一起来创建一个可运行的schema：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line"></span><br><span class="line">File schemaFile = loadSchema(<span class="string">&quot;starWarsSchema.graphqls&quot;</span>);</span><br><span class="line"></span><br><span class="line">TypeDefinitionRegistry typeRegistry = schemaParser.parse(schemaFile);</span><br><span class="line">RuntimeWiring wiring = buildRuntimeWiring();</span><br><span class="line">GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, wiring);</span><br></pre></td></tr></table></figure><p>另外在建造者模式的基础上，<code>TypeResolver</code>和<code>DataFetcher</code>可以使用<code>WiringFactory</code>接口来注入。这会允许更多的动态运行时，通过schema的定义去判断应该注入什么东西。你可以通过阅读SDL来判断生成哪种runtime。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RuntimeWiring <span class="title">buildDynamicRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WiringFactory dynamicWiringFactory = <span class="keyword">new</span> WiringFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;dataFetcher&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive = getDirective(definition, <span class="string">&quot;dataFetcher&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createDataFetcher(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .wiringFactory(dynamicWiringFactory).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个schema定义"><a href="#创建一个schema定义" class="headerlink" title="创建一个schema定义"></a>创建一个schema定义</h2><p>当schema生成时，<code>DataFetcher</code>和<code>TypeResolver</code>可以在类型创建时提供：</p><p>来活了，未完待续。。。</p>]]></content>
    
    
    <summary type="html">本文基于GraphQl-java:v1.6版本官方文档中文翻译。</summary>
    
    
    
    
    <category term="GraphQl" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQl/"/>
    
  </entry>
  
  <entry>
    <title>对SpringGateway+Security+OAuth2.0的认识</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/</id>
    <published>2021-01-12T09:49:10.000Z</published>
    <updated>2021-01-19T03:26:45.381Z</updated>
    
    <content type="html"><![CDATA[<p>趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。</p><a id="more"></a><h2 id="OAuth2-0-四种授权模式"><a href="#OAuth2-0-四种授权模式" class="headerlink" title="OAuth2.0 四种授权模式"></a>OAuth2.0 四种授权模式</h2><table><thead><tr><th>模式</th><th>refresh_token</th><th>用途</th></tr></thead><tbody><tr><td>authorization_code</td><td>true</td><td>允许用户通过第三方应用登录自身获取资源，前提是用户已登录自身服务。</td></tr><tr><td>implicit</td><td>false</td><td>简化模式，跳过了获取授权码过程。</td></tr><tr><td>password</td><td>true</td><td>账号密码模式，用于高度授信场景，比如登录微信、QQ自身｜</td></tr><tr><td>client_credentials</td><td>false</td><td>客户端模式，用于高度授信的其他服务，如企业自己的其他服务，或高度加密的硬件客户端，登录过程完全不需要用户操作。</td></tr></tbody></table><h2 id="Security、ResourceServer、ClientServer各自的作用和关系"><a href="#Security、ResourceServer、ClientServer各自的作用和关系" class="headerlink" title="Security、ResourceServer、ClientServer各自的作用和关系"></a>Security、ResourceServer、ClientServer各自的作用和关系</h2><ul><li><p>SpringSecurity:鉴权方式的配置，比如哪些接口需要鉴权，还要排除调登录注册和登出接口等等。还有用户信息的存放、认证，Token Provider 的配置等等。</p></li><li><p>ResourceServer:是指需要收到保护的资源。比我的一个服务有大量接口，需要采用Security保护，那这个服务就是个ResourceServer。怎么保护呢？通过集成SpringSecurity来保护。每当有请求要访问我们的接口，ResourceServer都需要向token_provider验证token的有效性。</p></li><li><p>ClientServer:是用来在服务端获取access_token和refresh_token用的，并且可以自动使用refresh_token去刷新access_token。向谁获取？可以是微信、微博、github等等。</p></li><li><p>TokenProvider:用来提供token的服务。比如微信、支付宝、github,也可以是自己搭建的Keycloak服务。</p></li></ul><h2 id="网关统一用户认证"><a href="#网关统一用户认证" class="headerlink" title="网关统一用户认证"></a>网关统一用户认证</h2><p>很简单，说白了就是在Gateway集成Security，这样以来Gateway就成了一个ResourceServer，并且可以为所有路由做用户认证。</p><p>但是！<strong>具体的鉴权还是需要各个服务自己去做</strong>，毕竟网关不知道具体的服务需要具体哪一项权限。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="直接使用微信、支付宝的token来做自己的有效性验证可以码？"><a href="#直接使用微信、支付宝的token来做自己的有效性验证可以码？" class="headerlink" title="直接使用微信、支付宝的token来做自己的有效性验证可以码？"></a>直接使用微信、支付宝的token来做自己的有效性验证可以码？</h3><p>当然可以！只不过，人家的token验证只有在调用他们的服务时才会生效，如果不调用他们的服务，我们自己不知道人家的token是否有效（超时过期）。</p><p>那么该怎么实现？当我们自己的接口被访问时，先去调个人家的服务，最好是无关痛痒的服务，单纯为了验证人家的token是否有效。</p><p>但是这样以来就大大降低了接口的请求速度，而且也不优雅，平衡下来还不许自己搭建帐号体系来的实在！</p><h3 id="采用授权码方式让自己的客户端访问自己服务？"><a href="#采用授权码方式让自己的客户端访问自己服务？" class="headerlink" title="采用授权码方式让自己的客户端访问自己服务？"></a>采用授权码方式让自己的客户端访问自己服务？</h3><p>这就叫脱了裤子放屁，为安全而安全！</p><p>用微信的第三方登录举例，假如我们没有登录微信，当使用微信时，依然需要用帐号密码方式先登录微信。因为你在操作授权登录时，是先调起微信的页面或者它SDK的页面，是在人家的页面里面玩的，对于微信来讲，他自己的页面就是高度授信的，所以追本溯源，授权码登录方式还是基于帐号密码之上的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="spring" scheme="https://vee-zhang.github.io/Vee-blog/tags/spring/"/>
    
    <category term="cloud" scheme="https://vee-zhang.github.io/Vee-blog/tags/cloud/"/>
    
    <category term="security" scheme="https://vee-zhang.github.io/Vee-blog/tags/security/"/>
    
    <category term="oauth2.0" scheme="https://vee-zhang.github.io/Vee-blog/tags/oauth2-0/"/>
    
  </entry>
  
  <entry>
    <title>开篇第一章</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-01-07T08:30:36.000Z</published>
    <updated>2021-01-19T03:26:45.381Z</updated>
    
    <content type="html"><![CDATA[<p>这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建pub.dev私服及上传package</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</id>
    <published>2021-01-06T08:57:01.000Z</published>
    <updated>2021-01-19T03:26:45.381Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h2><p>首先到我的<a href="https://gitee.com/william198824/pub_server">码云</a>clone个项目下来,然后习惯性<code>flutter pub get</code>。</p><p>接下来修改配置，修改<code>pub_server/example/src/example.dart</code>文件,找到<code>argsParser()</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArgParser argsParser() &#123;</span><br><span class="line">  <span class="keyword">var</span> parser = ArgParser();</span><br><span class="line"></span><br><span class="line">  parser.addOption(<span class="string">&#x27;directory&#x27;</span>,</span><br><span class="line">      abbr: <span class="string">&#x27;d&#x27;</span>, defaultsTo: <span class="string">&#x27;pub_server-repository-data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//host地址</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;host&#x27;</span>, abbr: <span class="string">&#x27;h&#x27;</span>, defaultsTo: <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;port&#x27;</span>, abbr: <span class="string">&#x27;p&#x27;</span>, defaultsTo: <span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我的8080端口已经被jenkies占用了，所以只能把pub的端口改为9090。要注意的是，<strong>host默认是localhost，只支持本机访问</strong>，如果我们要挂到服务上，需要把这里改为<code>0.0.0.0</code>之后，我们才能通过ip或者域名访问服务。</p><p>然后启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart example/example.dart -d /tmp/package-db</span><br></pre></td></tr></table></figure><blockquote><p>如果出现「To make the pub client use this repository configure…」表示服务启动成功！</p></blockquote><h2 id="创建测试package"><a href="#创建测试package" class="headerlink" title="创建测试package"></a>创建测试package</h2><p>怎么创建，不说了，这里只贴出yaml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lk_dio</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">用于来康科技公司的网络请求层封装，包括平台、大脑的接口调用规则和token有效期验证及自动刷新机制。</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">William</span> <span class="string">&lt;自己的邮箱@enn.cn&gt;</span></span><br><span class="line"><span class="attr">homepage:</span> <span class="string">&#x27;http://项目主页地址.com&#x27;</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">&#x27;http://localhost:9090&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.7.0 &lt;3.0.0&quot;</span></span><br><span class="line">  <span class="attr">flutter:</span> <span class="string">&quot;&gt;=1.17.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter:</span></span><br></pre></td></tr></table></figure><p>配置好之后,可以在本地直接依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lk_dio:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">user/william/lk_dio</span></span><br></pre></td></tr></table></figure><p>当然也可以发布到我们的pub私服上，发布之前可以通过命令检查错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure><p>按照提示解决问题，然后发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure><p>出现如下信息表明发布成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   &#x27;-- helloworld.dart</span><br><span class="line">|-- pubspec.yaml</span><br><span class="line">&#x27;-- test</span><br><span class="line">    &#x27;-- helloworld_test.dart</span><br><span class="line"></span><br><span class="line">Looks great! Are you ready to upload your package (y/n)? y</span><br><span class="line">Uploading...</span><br><span class="line">Successfully uploaded package.</span><br></pre></td></tr></table></figure><p>但是如果不FQ，是一定不会成功的，你看到的将是如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br></pre></td></tr></table></figure><p>失败的原因就是需要google的认证，怎么办，fq? 有没有更好的办法？</p><h2 id="绕过google认证"><a href="#绕过google认证" class="headerlink" title="绕过google认证"></a>绕过google认证</h2><p>再clone<a href="https://gitee.com/william198824/pub">这个项目</a>之后<code>flutter pub get</code>，然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart --snapshot=mypub.dart.snapshot bin/pub.dart </span><br></pre></td></tr></table></figure><p>完事后会自动生成一个<code>mypub.dart.snapshot</code>。</p><p>复制之后放入${flutterSDK Path}/bin/cache/dart-sdk/bin/snapshots/ 目录下</p><p>用txt编辑器打开${flutterSDK Path}/bin/cache/dart-sdk/bin/pub文件，将倒数第三行的：<code>pub.dart.snapshot</code> 替换为 <code>mypub.dart.snapshot</code>,然后重新发布package就OK了。</p><h2 id="依赖自己的package"><a href="#依赖自己的package" class="headerlink" title="依赖自己的package"></a>依赖自己的package</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lk_dio:#这里要与之前一致</span></span><br><span class="line">  <span class="attr">hosted:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">lk_dio</span> <span class="comment">#这里要与之前一致</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://localhost:9090</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">^1.0.0</span></span><br></pre></td></tr></table></figure><p>添加了依赖之后，我<code>flutter pub get</code>，本机没问题，项目正常跑，万分激动，但是。。。</p><p>当我把server发布到公司服务器后，<strong>publish失败！</strong>经查，是运维没有开放9090端口，找过运维之后问题解决。</p><p>然后我再添加依赖，运行pub get，竟然卡住不动了，内心瞬间一万只草泥马德，上传可以下载就不行怪了！后来发现server的配置文件中有个配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><code>standalone</code>好像是独立部署的意思。</p><p>把这里的<code>defaultTo</code>的值改为<code>true</code>,重新部署、启动，再重新下载依赖pub get，等等足足71秒后竟然成功了！后来运维解释，之所以这么慢是因为从北京访问我们盐城的服务器，而且没有CDN加速。</p><h2 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h2><p><a href="https://www.jianshu.com/p/59f4778864f0">https://www.jianshu.com/p/59f4778864f0</a></p>]]></content>
    
    
    <summary type="html">事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！</summary>
    
    
    
    <category term="technology" scheme="https://vee-zhang.github.io/Vee-blog/categories/technology/"/>
    
    
    <category term="pub" scheme="https://vee-zhang.github.io/Vee-blog/tags/pub/"/>
    
    <category term="flutter" scheme="https://vee-zhang.github.io/Vee-blog/tags/flutter/"/>
    
    <category term="dart" scheme="https://vee-zhang.github.io/Vee-blog/tags/dart/"/>
    
  </entry>
  
</feed>
