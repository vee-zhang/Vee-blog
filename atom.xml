<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vee&#39;s blog</title>
  
  <subtitle>make world better !</subtitle>
  <link href="https://vee-zhang.github.io/Vee-blog/atom.xml" rel="self"/>
  
  <link href="https://vee-zhang.github.io/Vee-blog/"/>
  <updated>2021-05-07T03:16:57.852Z</updated>
  <id>https://vee-zhang.github.io/Vee-blog/</id>
  
  <author>
    <name>Vee Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SharedPreferences解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/04/30/SharedPreferences%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/04/30/SharedPreferences%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-04-30T06:22:41.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SharedPreferences解读"><a href="#SharedPreferences解读" class="headerlink" title="SharedPreferences解读"></a>SharedPreferences解读</h1><h2 id="getSharedPreferences"><a href="#getSharedPreferences" class="headerlink" title="getSharedPreferences"></a>getSharedPreferences</h2><p>我们通过这个方法拿到SP，该方法在Activity中内置，最终调用的是ContextWrapper的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mBase.getSharedPreferences(name, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextWrapper里面调用的mBase的对应方法，通过百度，查到mBase其实就是传说中的<code>ContextImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file;</span><br><span class="line"><span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">file = mSharedPrefsPaths.get(name);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">file = getSharedPreferencesPath(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到文件后加入缓存，下次再拿文件就快了</span></span><br><span class="line">mSharedPrefsPaths.put(name, file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用重载方法执行真正的逻辑</span></span><br><span class="line"><span class="keyword">return</span> getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是用来获取文件，并且把文件放入ArrayMap缓存起来以备以后再次获取file可以提高效率。key就是文件的path，value就是文件映射的File对象。</p><p>然后使用文件作为参数，调用了同名的重载方法。</p><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>上述代码中出现了一个<code>file</code>局部变量，它是个什么角色呢，下一步我们就要来揭开它神秘的面纱。</p><p>首先看到<code>Synchronized</code>关键字，并且充当了<code>ContextIml</code>的类锁，那么带来线程安全的同时，会使所有并发访问该类的操作阻塞。那么会不会造成UI线程卡顿呢？会，但是不明显。</p><p><code>mSharedPrefsPaths = new ArrayMap&lt;&gt;();</code>，那么不用想，mSharedPrefsPaths是个ArrayMap，一定是个内存缓存。</p><p>此处代码不重要，请直接看下面文字结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到SP文件地址</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getSharedPreferencesPath</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> makeFilename(getPreferencesDir(), name + <span class="string">&quot;.xml&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到SP所在目录</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">getPreferencesDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (mPreferencesDir == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建File对象</span></span><br><span class="line">mPreferencesDir = <span class="keyword">new</span> File(getDataDir(), <span class="string">&quot;shared_prefs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确保文件一定存在</span></span><br><span class="line"><span class="keyword">return</span> ensurePrivateDirExists(mPreferencesDir);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到数据目录，里面包括SP文件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDataDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">File res = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isCredentialProtectedStorage()) &#123;</span><br><span class="line">res = mPackageInfo.getCredentialProtectedDataDirFile();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDeviceProtectedStorage()) &#123;</span><br><span class="line">res = mPackageInfo.getDeviceProtectedDataDirFile();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = mPackageInfo.getDataDirFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!res.exists() &amp;&amp; android.os.Process.myUid() == android.os.Process.SYSTEM_UID) &#123;</span><br><span class="line">Log.wtf(TAG, <span class="string">&quot;Data directory doesn&#x27;t exist for package &quot;</span> + getPackageName(),</span><br><span class="line"><span class="keyword">new</span> Throwable());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">&quot;No data directory found for package &quot;</span> + getPackageName());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">&quot;No package details found for package &quot;</span> + getPackageName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">makeFilename</span><span class="params">(File base, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name.indexOf(File.separatorChar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> File res = <span class="keyword">new</span> File(base, name);</span><br><span class="line"><span class="comment">// We report as filesystem access here to give us the best shot at</span></span><br><span class="line"><span class="comment">// detecting apps that will pass the path down to native code.</span></span><br><span class="line">BlockGuard.getVmPolicy().onPathAccess(res.getPath());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;File &quot;</span> + name + <span class="string">&quot; contains a path separator&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码没必要研究，就是经过一系列拼拼凑凑，最后拿到/data/data/包名/shared_prefs/[name].xml 文件，然后调用<code>ensurePrivateDirExists</code>方法确保文件一定存在(不存在就创建)。</p><h3 id="getSharedPreferences-重载方法"><a href="#getSharedPreferences-重载方法" class="headerlink" title="getSharedPreferences 重载方法"></a>getSharedPreferences 重载方法</h3><p>接下来调用了一个重载方法，主要是创建<code>SharedPreferenceImpl</code>对象，通过缓存进arrayMap，并且以file作为key一一绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">SharedPreferencesImpl sp;</span><br><span class="line"><span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line"><span class="comment">//获取缓存，该缓存把file和SharedPreferencesImpl一一绑定</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;file, sharedpreferencesimpl=<span class="string">&quot;&quot;</span>sharedpreferencesimpl<span class="string">&quot;&quot;</span>&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">sp = cache.get(file);</span><br><span class="line"><span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">checkMode(mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SharedPreferencesImpl</span></span><br><span class="line">sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line"><span class="comment">//缓存SP</span></span><br><span class="line">cache.put(file, sp);</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果系统版本小于Android3.0，就调用此方法把File一次性读取出来</span></span><br><span class="line">sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayMap&lt;file, sharedpreferencesimpl=<span class="string">&quot;&quot;</span>sharedpreferencesimpl<span class="string">&quot;&quot;</span>&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line"><span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">ArrayMap&lt;file, sharedpreferencesimpl=<span class="string">&quot;&quot;</span>sharedpreferencesimpl<span class="string">&quot;&quot;</span>&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line"><span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个重载方法，主要是创建<code>SharedPreferencesImpl</code>对象并且缓存，File作为key，SharedPreferencesImpl作为value，保证了File和SharedPreferencesImpl的一一对应。</p><p>这里还区分了系统版本，3.0以下版本，通过<code>sp.startReloadIfChangedUnexpectedly();</code>，创建一个子线程，把文件内容全都读取到SharedPreferencesImpl中。</p><h3 id="SharedPreferencesImpl构造方法"><a href="#SharedPreferencesImpl构造方法" class="headerlink" title="SharedPreferencesImpl构造方法"></a>SharedPreferencesImpl构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    <span class="comment">//创建备份文件对象</span></span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    mThrowable = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始加载</span></span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个同名文件，以.bak作为后缀</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File <span class="title">makeBackupFile</span><span class="params">(File prefsFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(prefsFile.getPath() + <span class="string">&quot;.bak&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，在sp所在目录中先创建了一个以“.bak”为后缀的备份文件的对象，然后在子线程中从硬盘加载文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在子线程加载文件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">// 变更标志位</span></span><br><span class="line">        mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开启子线程从硬盘加载文件</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;SharedPreferencesImpl-load&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//dlc机制</span></span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果备份文件实体存在，则从备份恢复sp文件</span></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Map&lt;string, object=<span class="string">&quot;object&quot;</span>&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    StructStat stat = <span class="keyword">null</span>;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//读取文件内容</span></span><br><span class="line">                str = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//采用poll方式解析xml</span></span><br><span class="line">                map = (Map&lt;string, object=<span class="string">&quot;object&quot;</span>&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;Cannot read &quot;</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span></span><br><span class="line">        <span class="comment">// ignoring.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//变更标志位</span></span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//唯一唤醒锁的时机</span></span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getXXX"><a href="#getXXX" class="headerlink" title="getXXX()"></a>getXXX()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, <span class="meta">@Nullable</span> String defValue)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意这个锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//持续等待</span></span><br><span class="line">awaitLoadedLocked();</span><br><span class="line">String v = (String)mMap.get(key);</span><br><span class="line"><span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mLock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的就是，<code>getXXX()</code>方法与构造方法中读取文件的地方是共享同一把锁<code>mLock</code>，从而使这两个方法存在互斥关系。如果文件很大，那么程序运行<code>sharedPreferenceImpl</code>构造方法的耗时就会比较长，此时调用<code>getXXX()</code>方法因为互斥锁的关系，就会持续等待，一直到构造方法执行完毕之后才能返回结果，导致主线程被阻塞，出现UI卡顿，甚至出现ANR。</p><h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><p><code>getSharedPreferences(String name,int mode)</code>方法用来初始化SP，主要就是创建xml文件，进而使用文件和mode创建<code>getSharedPreferencesImpl</code>对象并且返回。</p><p>而在创建<code>getSharedPreferencesImpl</code>时就会开启一个子线程从硬盘解析xml文件到内存中，同时创建一个以.bat为后缀的备份文件。</p><p>如果在构造方法读取文件期间调用了<code>getXXX()</code>方法，后者会持续等待前者完成之后才执行，会造成UI卡顿甚至ANR。</p><p>当开启<strong>多进程模式</strong>时，每次调用<code>getSharedPreferences()</code>时都会重新读取文件。因为SP不知道文件是否已被更新，所以只能每次重新读取。</p><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>按照SP的使用流程，下一步就是要获取到<code>Editor</code>对象了，我们通过<code>Editor</code>提供的<code>putXXX()</code>方法来向SP中写入数据。</p><p><code>Editor</code>是一个接口，提供了一些列的put虚方法。接口是不能直接调用的，所以我们调用的其实是他的实现类——<code>EditorImpl</code>，它是<code>getSharedPreferencesImpl</code>的<strong>内部匿名类</strong>，由于内部匿名类持有外部类的引用，那么它就可以访问外层类的成员！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又看到了这把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//持续等待</span></span><br><span class="line">awaitLoadedLocked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建EditorImpl</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用<code>sp.editor()</code>方法，也会共享<code>mLock</code>这把锁，那么同样也存在上面说的问题，会出现卡顿。</p><h3 id="EditorImpl定义和Put操作"><a href="#EditorImpl定义和Put操作" class="headerlink" title="EditorImpl定义和Put操作"></a>EditorImpl定义和Put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line"> <span class="comment">//一把锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mEditorLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;string, object=<span class="string">&quot;&quot;</span>object<span class="string">&quot;&quot;</span>&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志位</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mClear = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//喜闻乐见的putString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, <span class="meta">@Nullable</span> String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">mModified.put(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>代码很简单，put操作其实就是对HashMap缓存进行写入，同时为了保证线程安全，加了锁。每个PUT操作都是互斥关系。改动并没有即时提交到硬盘文件，也没有提交到真正的缓存mMap，而是提交到了editor内部的缓存<strong>mModified</strong>里面了。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line"><span class="comment">//为何不设置为null?;</span></span><br><span class="line">mModified.put(key, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我看到<code>remove()</code>方法定义时，我惊呆了！mModified里面放了this，而this又持有了mModified，这不就造成循环引用了吗，不会出问题吗？希望日后能找到答案吧。</p><p>我觉得一般人都会设置null吧。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">mClear = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clear</code>方法也是非常奇怪，只是设置了一下标志位，并没有做其他的事情。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>怎样解决卡顿问题？</p><ol><li>尽量把大文件拆分成多个小文件。</li><li>尽量提前初始化sp。</li><li>然后尽量不要在初始化之后马上就用sp。</li></ol><h3 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交到内存</span></span><br><span class="line">MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"><span class="comment">//子线程写入文件</span></span><br><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//计数锁等待</span></span><br><span class="line">mcr.writtenToDiskLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知监视器</span></span><br><span class="line">notifyListeners(mcr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回读写结果true or false</span></span><br><span class="line"><span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commit方法通过计数锁阻塞了当前线程，等待子线程中的写操作完成，才会被唤醒，充分体现了线程协作的思想。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交到内存</span></span><br><span class="line"><span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实并不起作用，迷之操作</span></span><br><span class="line"><span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//计数锁开始等待</span></span><br><span class="line">mcr.writtenToDiskLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加生命周期回调</span></span><br><span class="line">QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用计数锁阻塞当前线程</span></span><br><span class="line">awaitCommit.run();</span><br><span class="line"><span class="comment">//移除生命周期回调</span></span><br><span class="line">QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程写入文件</span></span><br><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知监视器</span></span><br><span class="line">notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这两个方法主要干了三件事：</p><ol><li>调用<code>commitToMemory()</code>方法从<code>mModified</code>提交改动到<code>mMap</code>；</li><li>调用<code>SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);</code>把改动写入文件；</li><li>调用<code>notifyListeners(mcr);</code>通知监视器。</li></ol><p>不同点在于，<code>commit</code>方法在写入文件时，通过计数锁阻塞了当前线程，那么如果在主线程调用<code>commit</code>的话，就会造成卡顿了。而<code>apply</code>方法是把计数锁放到了另一个子线程中去执行了，所以阻塞的是另一个子线程，在一般情况下对主线程没有影响。</p><p>但是，当生命周期处于<code>handleStopService()</code> 、 <code>handlePauseActivity()</code> 、 <code>handleStopActivity()</code>时，会调用 <code>QueuedWork</code>的<code>waitToFinish()</code>方法，在这个方法中会遍历执行所有的<code>finisher</code>，所以如果内容很多，**<code>Apply</code>方法还是会引起ANR**。</p><p>最后，<code>apply</code>方法没有返回写入的成功失败。</p><p>怎么解决ANR问题？</p><p>我觉得在子线程中调用commit方法应该是个不错的选择吧。</p><h3 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h3><p><code>commit</code>和<code>apply</code>两个方法都是在主线程调用了这个方法完成写入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*使已经提交给内存的结果排队，以将其写入磁盘。它们将按入队的顺序一次写入磁盘</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;</span><br><span class="line"><span class="comment">//commit-true apply-false</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">mDiskWritesInFlight--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply会执行</span></span><br><span class="line"><span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//主要是为了移除Finisher</span></span><br><span class="line">postWriteRunnable.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// commit执行</span></span><br><span class="line"><span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line"><span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">writeToDiskRunnable.run();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply执行</span></span><br><span class="line">QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里先定义了一个<code>Runnable</code>叫做writeToDiskRunnable ，一看名字就知道是用来IO写磁盘的。所以其中必然有<code>writeToFile</code>方法的调用啦。由于在同一线程顺序执行，<code>writeToFile</code>方法中必然会把<code>mcr.writtenToDiskLatch.countDown()</code>，所以后面的<code>postWriteRunnable.run();</code>只是为了移除finisher，而之前的<code>awaitCommit</code>这个Runnable中的<code>mcr.writtenToDiskLatch.await();</code>并没有起什么作用。</p><p>我们看到，系统通过变换<code>mDiskWritesInFlight</code>尽可能把<code>commit</code>转换为<code>apply</code>去执行。</p><p><code>commit</code>在当前线程就直接<code>run</code>了，而<code>apply</code>则是提交给了<code>QueuedWork.queue(writeToDiskRunnable,false)</code>。</p><h3 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if any changes were made</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line"><span class="keyword">boolean</span> keysCleared = <span class="keyword">false</span>;</span><br><span class="line">List&lt;String&gt; keysModified = <span class="keyword">null</span>;</span><br><span class="line">Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</span><br><span class="line">Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换对象</span></span><br><span class="line">mapToWriteToDisk = mMap;</span><br><span class="line">mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样是转换对象</span></span><br><span class="line"><span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又一把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line"><span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个标志位，为true说明调用过editor.clear()方法</span></span><br><span class="line"><span class="keyword">if</span> (mClear) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">changesMade = <span class="keyword">true</span>;</span><br><span class="line">mapToWriteToDisk.clear();</span><br><span class="line">&#125;</span><br><span class="line">keysCleared = <span class="keyword">true</span>;</span><br><span class="line">mClear = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历拷贝</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">String k = e.getKey();</span><br><span class="line">Object v = e.getValue();</span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;<span class="comment">//说明被editor.remove()过了</span></span><br><span class="line"><span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">mapToWriteToDisk.remove(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">Object existingValue = mapToWriteToDisk.get(k);</span><br><span class="line"><span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;<span class="comment">//如果值没变就跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mapToWriteToDisk.put(k, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changesMade = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">keysModified.add(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除editor缓存，释放内存</span></span><br><span class="line">mModified.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">mCurrentMemoryStateGeneration++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commitToMemory</code>方法顾名思义就是把<code>editor</code>的<code>mModified</code>中的值提交到<code>sharedferenceImpl</code>的<code>mMap</code>。</p><p>这里加了<code>SharedPreferencesImpl.this.mLock</code>，说明多次调用<code>commit</code>或<code>apply</code>方法都会阻塞执行，而且在进行<code>commit</code>或者<code>apply</code>还没结束时就调用<code>getXXX()</code>，依然会造成卡顿。</p><p>而这里出现的第二把锁<code>mEditorLock</code>是为了保证<code>mModified</code>的线程安全。</p><h4 id="MemoryCommitResult"><a href="#MemoryCommitResult" class="headerlink" title="MemoryCommitResult"></a>MemoryCommitResult</h4><p>MemoryCommitResult是一个打包类，它把当前的内存缓存、内存状态、监听回调、写入结果全部装箱到一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCommitResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存状态版本号</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> keysCleared;</span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">final</span> List&lt;string&gt; keysModified;</span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">final</span> Set&lt;onsharedpreferencechangelistener&gt; listeners;</span><br><span class="line"><span class="keyword">final</span> Map&lt;string, object=<span class="string">&quot;&quot;</span>object<span class="string">&quot;&quot;</span>&gt; mapToWriteToDisk;</span><br><span class="line"><span class="keyword">final</span> CountDownLatch writtenToDiskLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mWritingToDiskLock&quot;)</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> writeToDiskResult = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> wasWritten = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MemoryCommitResult</span><span class="params">(<span class="keyword">long</span> memoryStateGeneration, <span class="keyword">boolean</span> keysCleared,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> List&lt;string&gt; keysModified,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> Set&lt;onsharedpreferencechangelistener&gt; listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;string, object=<span class="string">&quot;&quot;</span>object<span class="string">&quot;&quot;</span>&gt; mapToWriteToDisk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.memoryStateGeneration = memoryStateGeneration;</span><br><span class="line"><span class="keyword">this</span>.keysCleared = keysCleared;</span><br><span class="line"><span class="keyword">this</span>.keysModified = keysModified;</span><br><span class="line"><span class="keyword">this</span>.listeners = listeners;</span><br><span class="line"><span class="keyword">this</span>.mapToWriteToDisk = mapToWriteToDisk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唯一提供的方法，用来变更标记为，储存写入结果</span></span><br><span class="line"><span class="comment">//只有这里能唤醒计数锁！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDiskWriteResult</span><span class="params">(<span class="keyword">boolean</span> wasWritten, <span class="keyword">boolean</span> result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.wasWritten = wasWritten;</span><br><span class="line">writeToDiskResult = result;</span><br><span class="line">writtenToDiskLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply方法的QueuedWork机制"><a href="#apply方法的QueuedWork机制" class="headerlink" title="apply方法的QueuedWork机制"></a>apply方法的QueuedWork机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span> 很奇怪为啥好东西都不让我们用呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWork</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delay for delayed runnables, as big as possible but low enough to be barely perceivable */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 我是一把锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used to make sure that only one thread is processing work items at a time. This means that</span></span><br><span class="line"><span class="comment">     * they are processed in the order added.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is separate from &#123;<span class="doctag">@link</span> #sLock&#125; as this is held the whole time while work is processed</span></span><br><span class="line"><span class="comment">     * and we do not want to stall the whole class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object sProcessingWork = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; sFinishers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler sHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Work queued via &#123;<span class="doctag">@link</span> #queue&#125; */</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; sWork = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sCanDelay = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFinisher</span><span class="params">(Runnable finisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sFinishers.add(finisher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFinisher</span><span class="params">(Runnable finisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sFinishers.remove(finisher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发要立即处理的排队工作。排队的工作在异步的单独线程上处理。在执行该操作的同时，还要处理该线程上的所有修整器。可以以某种方式实施整理器，以检查排队的工作是否完成。在Activity基类的onPause（）， BroadcastReceiver的onReceive之后，Service命令处理之后等等被调用（因此，异步工作永远不会丢失）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hadMessages = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除loop</span></span><br><span class="line">            <span class="keyword">if</span> (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123;</span><br><span class="line">                handler.removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We should not delay any work as this might delay the finishers</span></span><br><span class="line">            sCanDelay = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程使用自检</span></span><br><span class="line">        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//系统偷偷的写入了一次，而且是在**主线程**直接调用的</span></span><br><span class="line">            processPendingWork();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事后检查机制，保证所有finisher都被执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Runnable finisher;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">                    finisher = sFinishers.poll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove调finisher，所以大多数情况会走到这里</span></span><br><span class="line">                <span class="keyword">if</span> (finisher == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                finisher.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sCanDelay = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//同一个方法在7.0上的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable toFinish;</span><br><span class="line">        <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          toFinish.run();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一看就懂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPendingWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> !sWork.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步任务调度,其实就是切换到工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shouldDelayapply=false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sWork.add(work);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</span><br><span class="line">                handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *每次都会启动一个HandlerThread</span></span><br><span class="line"><span class="comment">     * 获取一个单例的Handler，当然这玩意的looper就是handlerThread的looper</span></span><br><span class="line"><span class="comment"> * queue方法和waitToFinish中调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;queued-work-looper&quot;</span>,</span><br><span class="line">                        Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">                handlerThread.start();</span><br><span class="line"></span><br><span class="line">                sHandler = <span class="keyword">new</span> QueuedWorkHandler(handlerThread.getLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sHandler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *自定义的Handler</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWorkHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_RUN = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        QueuedWorkHandler(Looper looper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.what == MSG_RUN) &#123;</span><br><span class="line"><span class="comment">//切换到了handlerThread所在线程</span></span><br><span class="line">                processPendingWork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里又是一把锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sProcessingWork) &#123;</span><br><span class="line">            LinkedList&lt;Runnable&gt; work;</span><br><span class="line"><span class="comment">//这里的锁注意一下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line"><span class="comment">//浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用</span></span><br><span class="line">                work = (LinkedList&lt;Runnable&gt;) sWork.clone();</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">                sWork.clear();</span><br><span class="line"><span class="comment">//解除loop，退出死循环</span></span><br><span class="line">                getHandler().removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历执行task</span></span><br><span class="line">            <span class="keyword">if</span> (work.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Runnable w : work) &#123;</span><br><span class="line">                    w.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity在OnPause时会调用ActivityThread的<code>handleStopActivity</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">performStopActivityInner(r, stopInfo, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">reason);</span><br><span class="line"></span><br><span class="line">updateVisibility(r, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.0及以后版本，确保所有挂起的写入全都提交到文件</span></span><br><span class="line"><span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">QueuedWork.waitToFinish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopInfo.setActivity(r);</span><br><span class="line">stopInfo.setState(r.state);</span><br><span class="line">stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">pendingActions.setStopInfo(stopInfo);</span><br><span class="line">mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.0及以后系统，当发生cresh或者Activity、broaderCaster、service生命周期发生改变时，主线程会自动调用<code>QueuedWork.waitToFinish()</code>把当前挂起的修改写入到文件系统中！！！如果没有任何修改，那么就会遍历执行所有的finisher！！！这就是<code>apply</code>方法提交也会导致ANR的秘密！！！</p><h4 id="最重要的方法writeToFile"><a href="#最重要的方法writeToFile" class="headerlink" title="最重要的方法writeToFile"></a>最重要的方法writeToFile</h4><h5 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足写入条件，并且备份文件</span></span><br><span class="line"><span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line"><span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果硬盘状态版本号低于内存状态版本号，那么只需要写入</span></span><br><span class="line"><span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFromSyncCommit) &#123;<span class="comment">//commit</span></span><br><span class="line">needsWrite = <span class="keyword">true</span>;<span class="comment">//变更标志位</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;<span class="comment">//apply</span></span><br><span class="line"><span class="comment">//无需保持中间状态。只需等待最新状态保持不变即可。</span></span><br><span class="line"><span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">needsWrite = <span class="keyword">true</span>;<span class="comment">//变更标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要写入，那么直接设置结果</span></span><br><span class="line"><span class="keyword">if</span> (!needsWrite) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定备份文件是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果备份不存在，则把文件内容备份</span></span><br><span class="line"><span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果已存在备份，则删掉文件</span></span><br><span class="line">mFile.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真正的写入"><a href="#真正的写入" class="headerlink" title="真正的写入"></a>真正的写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试写入文件，删除备份并尽可能自动地返回true。如果发生任何异常，请删除新文件。下次我们将从备份中还原。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果拿不到输出流就直接返回结果：失败</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行写入操作</span></span><br><span class="line">XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存写入的时间点</span></span><br><span class="line">writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写完了，关闭输出流</span></span><br><span class="line">str.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文件权限</span></span><br><span class="line">ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取文件系统中的文件状态</span></span><br><span class="line"><span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">mStatTimestamp = stat.st_mtim;</span><br><span class="line">mStatSize = stat.st_size;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line"><span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入成功后删除备份</span></span><br><span class="line">mBackupFile.delete();</span><br><span class="line"></span><br><span class="line">mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">mSyncTimes.add((<span class="keyword">int</span>) fsyncDuration);</span><br><span class="line">mNumSync++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;writeToFile: Got exception:&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;writeToFile: Got exception:&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理干净没有写入成功的文件</span></span><br><span class="line"><span class="keyword">if</span> (mFile.exists()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mFile.delete()) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Couldn&#x27;t clean up partially-written file &quot;</span> + mFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回结果：失败</span></span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这段逻辑真的好长，最后回顾起来却很简单，它只干了3件事情：</p><ul><li>用xml文件生成一个备份，用来做失败还原</li><li>用XmlUtil执行写入，写入成功后删除备份返回结果</li><li>写入失败则清理文件，保留备份</li></ul><h3 id="notifyListeners"><a href="#notifyListeners" class="headerlink" title="notifyListeners"></a>notifyListeners</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || (mcr.keysModified == <span class="keyword">null</span> &amp;&amp; !mcr.keysCleared)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前是主线程，就遍历MemoryCommitResult中listener</span></span><br><span class="line"><span class="keyword">if</span> (mcr.keysCleared &amp;&amp; Compatibility.isChangeEnabled(CALLBACK_ON_CLEAR_CHANGE)) &#123;</span><br><span class="line"><span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line"><span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果当前是子线程，就切换到主线程重新调用方法</span></span><br><span class="line">ActivityThread.sMainThreadHandler.post(() -&gt; notifyListeners(mcr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了这个方法，我才知道SP还可以注册监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val sp = getSharedPreferences(<span class="string">&quot;我擦&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line">        </span><br><span class="line">val listener = object: SharedPreferences.OnSharedPreferenceChangeListener&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onSharedPreferenceChanged</span><span class="params">(sharedPreferences: SharedPreferences?, key: String?)</span> </span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.registerOnSharedPreferenceChangeListener(listener)</span><br><span class="line"></span><br><span class="line">sp.unregisterOnSharedPreferenceChangeListener(listener)</span><br></pre></td></tr></table></figure><p>从代码看得出，这个方法一定是在主线程内完成的。那么如果监听太多，或者监听里面有耗时操作，那么必定还是会ANR。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SharedPreferences解读&quot;&gt;&lt;a href=&quot;#SharedPreferences解读&quot; class=&quot;headerlink&quot; title=&quot;SharedPreferences解读&quot;&gt;&lt;/a&gt;SharedPreferences解读&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="Android" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/18/HandlerThread%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/18/HandlerThread%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-18T06:22:41.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">Handler workHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;handler&quot;</span>, <span class="string">&quot;收到消息: &quot;</span> + msg.obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(workHandler);</span><br><span class="line"></span><br><span class="line">msg.obj = <span class="string">&quot;我发了一条消息&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">msg.sendToTarget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">mHandlerThread.quit();</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread，本身就是线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部持有looper</span></span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部持有handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">     * setup before Looper loops.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Process是进程的帮助类，可提供进程信息</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化loop</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化内部Handler，但是外部不能调用此方法</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getThreadHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线程id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerThread</code>本身就是一个线程，只不过它持有<code>Looper</code>,在<code>run()</code>方法内部实现了<code>Looper.prepary()</code>和<code>Looper.loop()</code>。所以任务也只能串行。</p><p>使用完要手动退出，否则线程一直存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AsyncTask解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/17/AsyncTask%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/17/AsyncTask%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-17T08:59:41.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv = findViewById(R.id.tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask(<span class="keyword">this</span>.tv);</span><br><span class="line">        task.execute(<span class="string">&quot;我是&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Float</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;TextView&gt; tv;</span><br><span class="line"></span><br><span class="line">        MyTask(TextView tv) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tv = <span class="keyword">new</span> WeakReference&lt;TextView&gt;(tv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">            <span class="comment">// 任务执行前回调</span></span><br><span class="line">            tv.get().setText(<span class="string">&quot;即将开始任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... strings)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//后台任务逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (strings.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                        <span class="comment">//报告进度</span></span><br><span class="line">                        publishProgress(<span class="number">0.2f</span> * (i+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> strings[<span class="number">0</span>] + <span class="string">&quot;结果&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Float... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">            tv.get().setText(<span class="string">&quot;任务已执行&quot;</span>+values[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(s);</span><br><span class="line">            <span class="comment">//刷新UI</span></span><br><span class="line">            tv.get().setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要方法：</p><table><thead><tr><th>方法</th><th>线程</th><th>执行</th></tr></thead><tbody><tr><td>onPreExecute</td><td>主线程</td><td>任务开始前执行</td></tr><tr><td>doInBackground</td><td>子线程</td><td>后台任务执行时调用</td></tr><tr><td>onProgressUpdate</td><td>主线程</td><td><code>publishProgress</code>调用时回调</td></tr><tr><td>onPostExecute</td><td>主线程</td><td>任务完成后调用</td></tr><tr><td>onCancelled</td><td>主线程</td><td><code>cancell</code>调用时回调</td></tr></tbody></table><p>核心就这几个方法，只有<code>doInBackground</code>在子线程中调用。然后创建一个AsyncTask的实例，执行<code>execute</code>方法，并传入相应参数就开始执行了。</p><p>同时为避免内存泄露，需要用<strong>弱引用</strong>关联UI。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   最终构造方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到Handler，默认拿到主线程Handler</span></span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Callable，其中调用了doInBackground方法</span></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//调用doInBackground</span></span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//发送Message</span></span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用FutureTask包装Callable，提供启动、取消、监听功能</span></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，Async的主要流程在构造方法中就已经定义好了。</p><p>其中有个mWorker是<code>WorkerRunnable</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    Params[] mParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码才发现，这玩意并不是一个Runnable，而是个Callable，google跟我开了个玩笑。</p><p>接下来就是用<code>FutureTask</code>包装Callable，这样就可以具备启动、取消、完成监听功能。接下来我们去看<code>execute</code>方法。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态final类型的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    sDefaultExecutor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出<code>execute</code>方法只能在主线程中调用。这就是<code>AsyncTask</code>的局限性了：只能用于主线程。</p><p><code>executeOnExecutor</code>方法传入了默认的线程池。这个线程池是在AsyncTask类首次加载时初始化的。它是个static final类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改状态</span></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在MainThread回调onPreExecute</span></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的执行任务</span></span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从switch判断可以知道，AsyncTask是一次性的，不能复用，只有<code>PENDING</code>状态的AsyncTask才能运行。而状态是在类加载时定义的，而且不支持修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</span><br></pre></td></tr></table></figure><p>在这个方法里，首先改变了全局的状态为「执行中」，然后通过<code>exec.execute(mFuture)</code>真正开始执行线程。在这里查看源码，发现<code>FutureTask</code>这个类同时遵循<code>Runnable</code>和<code>Future</code>接口，所以他可以被线程池execute，也能接收到callable的返回值。这也是Callable转Runnable的一种方式。</p><p>然后来看AsyncTask的三种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="comment">//未执行</span></span><br><span class="line">    PENDING,</span><br><span class="line">    <span class="comment">//执行中</span></span><br><span class="line">    RUNNING,</span><br><span class="line">    <span class="comment">//执行完</span></span><br><span class="line">    FINISHED,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publishProgress"><a href="#publishProgress" class="headerlink" title="publishProgress"></a>publishProgress</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报告消息是基于Handler+message的形式实现的。</p><p>这个消息的<code>what</code>是<code>MESSAGE_POST_PROGRESS</code>这个常量。<code>obj</code>是new了一个<code>AsyncTaskResult&lt;Progress&gt;(this, values)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AsyncTask mTask;</span><br><span class="line">    <span class="keyword">final</span> Data[] mData;</span><br><span class="line"></span><br><span class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收消息的Handler，依靠这个Handler切换回主线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onPostExecute"><a href="#onPostExecute" class="headerlink" title="onPostExecute"></a>onPostExecute</h3><p>这个方法是在构造方法的<code>WorkerRunnable</code>中的逻辑执行完毕，最后finally里面调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            result = doInBackground(mParams);</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">            mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> tr;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个方法当然也是通过发送消息的方式达到线程间通信的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Handler的handleMessage中通过what做判断，如果是postResult，就调用<code>finish()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTask的流程已经通了，最后再来看一下它是怎么玩线程池的。</p><h3 id="AsyncTask工作线程池的实现"><a href="#AsyncTask工作线程池的实现" class="headerlink" title="AsyncTask工作线程池的实现"></a>AsyncTask工作线程池的实现</h3><p>它这里是自定义了一个线程池代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可作为栈或队列使用，性能较高</span></span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在队尾添加元素</span></span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//poll()拿出队首元素</span></span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这货实际上是<code>THREAD_POOL_EXECUTOR</code>这个线程池的代理，作用就是维护任务队列。</p><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数，一直处于活动状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//最大线程数，当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//活跃时间，线程池中大于核心线程数的那部分线程，在执行完任务之后，在线程池中存活的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;AsyncTask #&quot;</span> + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), sThreadFactory);</span><br><span class="line">    threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行这个静态代码块，初始化线程池。</p><p>我们看这里的线程池最大核心数只有1，那就是<strong>只能串行</strong>，最大线程数20，最多能有19个线程排队等待。</p><h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数&amp;最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACKUP_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler sRunOnSerialPolicy =</span><br><span class="line">            <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        android.util.Log.w(LOG_TAG, <span class="string">&quot;Exceeded ThreadPoolExecutor pool size&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBackupExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sBackupExecutorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">                sBackupExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                        BACKUP_POOL_SIZE, BACKUP_POOL_SIZE, KEEP_ALIVE_SECONDS,</span><br><span class="line">                        TimeUnit.SECONDS, sBackupExecutorQueue, sThreadFactory);</span><br><span class="line">                sBackupExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sBackupExecutor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果被拒绝，就新创建一个线程池去执行，这都可以？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AsyncTask类首次加载的时候初始化两个静态的线程池，<code>SerialExecutor</code>是个代理，内部维护着<code>Runnable</code>队列，实际通过调用threadPoolExecutor来执行任务。由于线程池不能保证线程执行的先后，所以AsyncTask通过加入外部队列的方式保障了任务执行的顺序。</p><p>AsyncTask的构造方法内部初始化了<code>Callable</code>，AsyncTask的主要流程都定义在<code>Callable</code>的<code>call()</code>方法内部，然后通过<code>FutureTask</code>包装<code>Callable</code>转换为<code>Runnable</code>传给线程池执行，同时可以取消任务或者获取返回值，最后通过内部的<code>Handler</code>发送消息切换回主线程。</p><p>由于内部的Handler在创建时传入<code>Looper.getMainLooper()</code>，所以默认线程就是主线程，并且<code>execute()</code>方法带有<code>@MainThread</code>注解，导致AsyncTask只能在主线程中使用。</p><p>AsyncTask初始化时状态为<code>pending</code>，在任务执行过程中变换为<code>Running</code>或<code>finished</code>，不可手动更改状态，导致AsyncTask不能复用。</p><h3 id="如何正确配置线程池的参数"><a href="#如何正确配置线程池的参数" class="headerlink" title="如何正确配置线程池的参数"></a>如何正确配置线程池的参数</h3><p>前面我们讲到了手动创建线程池涉及到的几个参数，那么我们要如何设置这些参数才算是正确的应用呢？实际上，需要根据任务的特性来分析。</p><p>任务的性质：CPU密集型、IO密集型和混杂型<br>任务的优先级：高中低<br>任务执行的时间：长中短<br>任务的依赖性：是否依赖数据库或者其他系统资源<br>不同的性质的任务，我们采取的配置将有所不同。在《Java并发编程实践》中有相应的计算公式。</p><p>通常来说，如果任务属于CPU密集型，那么我们可以将线程池数量设置成CPU的个数，以减少线程切换带来的开销。如果任务属于IO密集型，我们可以将线程池数量设置得更多一些，比如CPU个数*2。</p><p>PS：我们可以通过Runtime.getRuntime().availableProcessors()来获取CPU的个数。</p><p>作者：juconcurrent<br>链接：<a href="https://www.jianshu.com/p/7ab4ae9443b9">https://www.jianshu.com/p/7ab4ae9443b9</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Android AsyncTask" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/17/ThreadLocal%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/17/ThreadLocal%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-17T02:59:56.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从Set方法入手"><a href="#从Set方法入手" class="headerlink" title="从Set方法入手"></a>从Set方法入手</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，threadLocal的核心其实是<code>ThreadLocalMap</code>对象。</p><p><code>set</code>方法的作用是初始化内部的<code>ThreadLocalMap</code>，并将元素放入<code>ThreadLocalMap</code>中暂存，当前的ThreadLocal对象为key。</p><p>然后关注<code>createMap()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程中都有一个<code>threadLocals</code>对象，每次调用<code>createMap()</code>方法时都会给线程的<code>threadLocals</code>创建一个新的<code>ThreadLocalMap</code>，那么每次调用<code>set()</code>方法，其实是set给当前线程的<code>ThreadLocalMap</code>。</p><p>结论：<code>ThreadLocal</code>的<code>set</code>方法其实是把值存到了当前线程内部的<code>threadLocals</code>，而<code>threadLocals</code>是一个<code>ThreadLocalMap</code>类型的map（map嵌套），key就是当前的<code>ThreadLocal</code>。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocal内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap其实是个简化的HashMap，内部是个<code>Entry</code>类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="真的线程安全？"><a href="#真的线程安全？" class="headerlink" title="真的线程安全？"></a>真的线程安全？</h2><p>大部分博客都说<code>ThreadLocal</code>是把变量在每个线程生成变量副本，线程只能操作属于自己的副本，从而不会相互影响，并且线程安全。</p><p>但是我翻来覆去的看代码，也没有看到打破引用的代码啊，没有<code>clone</code>，没有<code>new</code>，那怎么能叫副本呢？那应该不管怎么赋值，都是共享变量的引用才对啊。那么在不同线程中操作同一共享变量，又没加锁，还谈什么线程安全？</p><p>那就写个例子来印证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随便创建一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor tpe = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击按钮后让线程池执行两个任务</span></span><br><span class="line">    Data data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Data();</span><br><span class="line">        tpe.execute(<span class="keyword">new</span> MyRunnable1(data));</span><br><span class="line">        tpe.execute(<span class="keyword">new</span> MyRunnable2(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等10秒之后点第二个按钮展示结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toastResult</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;toastResult: &quot;</span> + data);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;toastResult: &quot;</span> + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Data&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Data data;</span><br><span class="line"></span><br><span class="line">        MyRunnable1(Data data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mThreadLocal.set(data);</span><br><span class="line">            mThreadLocal.get().name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            mThreadLocal.get().age = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;线程1： &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务2 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Data&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Data data;</span><br><span class="line"></span><br><span class="line">        MyRunnable2(Data data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;线程2：&quot;</span> + data);</span><br><span class="line">                mThreadLocal.set(data);</span><br><span class="line">                mThreadLocal.get().name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">                mThreadLocal.get().age = <span class="number">20</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">        String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Data(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Data() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑：创建一个变量，然后分别在两个线程中用set进各自的ThreadLocal，然后get各自的变量副本，修改值，打印当前值。最后等个20秒以后点一下获取结果按钮。</p><p>但是当我最后获取结果的时候，发现原始的Data数据变了，变成了任务2中的赋值结果！而且在两个任务执行期间，<code>threadLocal.get()</code>也能看到其他变量对data的修改结果，果然跟我的猜测不错！</p><p>通过印证，我发现ThreadLocal并不能解决线程安全问题，也并不是什么共享变量的副本。他的作用只是把数据与线程绑定，而且通过弱引用的方式避免线程作用域内的对象内存泄露。</p><h2 id="为什么Looper采用ThreadLocal？"><a href="#为什么Looper采用ThreadLocal？" class="headerlink" title="为什么Looper采用ThreadLocal？"></a>为什么Looper采用ThreadLocal？</h2><p>因为一般我们操作线程的变量，都要在线程里面去改它。我们可能new一个Thread或者new一个Runnable，通过构造方法或者在run方法里面去写变量赋值。那么问题来了，如果你拿不到线程，不能修改线程呢？比如ActivityThread。</p><p>而Looper的源码里面没有一句操作线程的代码，而是巧用了ThreadLocal完成了Looper自己与线程的绑定！！！</p><p>所以ThreadLocal的应用场景是：<strong>不需要在线程中做操作，只需要把变量与线程绑定时就用ThreadLocal!ThreadLocal就是个中介者模式！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从Set方法入手&quot;&gt;&lt;a href=&quot;#从Set方法入手&quot; class=&quot;headerlink&quot; title=&quot;从Set方法入手&quot;&gt;&lt;/a&gt;从Set方法入手&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Parcelable解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/12/Parcelable%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/12/Parcelable%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-12T06:43:10.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法内读取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Data</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成器常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Data&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Data&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用构造方法生成一个实例</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Data <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Data(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成对应类型的数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Data[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Data[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========以下是getter和setter访问器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parcelable</code>使用：</p><ol><li>继承<code>Parcelable</code>接口；</li><li>声明构造方法，从<code>Parcel</code>中序列化数据；</li><li>重写<code>writeToParcel(Parcel dest, int flags)</code>方法，用来反序列化；</li><li>创建<code>Creator&lt;Data&gt;</code>类型的<code>CREATOR</code>，其内部实现了反序列化对象和数组的方法；</li><li>重写<code>describeContents()</code>方法。</li></ol><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>我们知道，序列化和反序列化都离不开<code>Parcel</code>对象，那他是个啥？</p><p>序列化的调用顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的自定义类中：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dest.writeString(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用Parcel类中：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString16NoHelper</span><span class="params">(<span class="meta">@Nullable</span> String val)</span> </span>&#123;</span><br><span class="line">    nativeWriteString16(mNativePtr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地JNI方法</span></span><br><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteString16</span><span class="params">(<span class="keyword">long</span> nativePtr, String val)</span></span>;</span><br></pre></td></tr></table></figure><p>Parcel用来包装数据，并且提供了大量的read/write方法，最终会调用本地方法<strong>通过<code>Binder</code>读写数据到一块共享内存</strong>。</p><p>这里就与<code>Serializable</code>有很大的不同。**<code>Serializable</code>的原理是通过IO将数据写到一个文件中**。</p><p>那么而这对比，肯定内存的读写性能要高于硬盘文件系统啊，这就是为什么Parcelable比Serializable快很多的原因。</p><h2 id="Parcel的创建"><a href="#Parcel的创建" class="headerlink" title="Parcel的创建"></a>Parcel的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//池子内最大6个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sOwnedPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sHolderPool = <span class="keyword">new</span> Parce[POOL_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parcel <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Parcel[] pool = sOwnedPool;</span><br><span class="line">    <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">        Parcel p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            p = pool[i];</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//池子中取出一个</span></span><br><span class="line">                pool[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//重置属性</span></span><br><span class="line">                p.mReadWriteHelper = ReadWriteHelper.DEFAULT;</span><br><span class="line">                <span class="comment">//返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果池子是空的则new一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Parcel(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parcel的回收"><a href="#Parcel的回收" class="headerlink" title="Parcel的回收"></a>Parcel的回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RECYCLE) mStack = <span class="keyword">null</span>;</span><br><span class="line">    freeBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Parcel[] pool;</span><br><span class="line">    <span class="keyword">if</span> (mOwnsNativeParcelObject) &#123;</span><br><span class="line">        pool = sOwnedPool;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNativePtr = <span class="number">0</span>;</span><br><span class="line">        pool = sHolderPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pool[i] = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢？本来这个Parcel是自由的，有个民警同志带着这个parcel去看守所转了一圈，一旦发现有空牢房，就把Parcel扔进去，就算回收了。等刑满社会需要Parcel的时候再放出来给社会做贡献。</p><h2 id="Parcel的销毁"><a href="#Parcel的销毁" class="headerlink" title="Parcel的销毁"></a>Parcel的销毁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Client did not call Parcel.recycle()&quot;</span>, mStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resetSqaushingState();</span><br><span class="line">    <span class="keyword">if</span> (mNativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwnsNativeParcelObject) &#123;</span><br><span class="line">            nativeDestroy(mNativePtr);</span><br><span class="line">            updateNativeSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mNativePtr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>竟然是重写<code>finalize()</code>方法手动销毁的！</p><p><strong><code>finalize()</code>方法会在GC时回调，用来释放非Java对象，比如JNI中的C/C++对象</strong>。此处是为了调用nativeDestroy(mNativePtr)方法释放本地C++对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="Android" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Binder解析</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/12/Binder%E8%A7%A3%E6%9E%90/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/12/Binder%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-12T03:06:25.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AIDL的全称是：Android接口定义语言(即 Android Interface Definition Language)，他定义的只不过是一套模板，实际起作用的是AS通过解释这个模板自动生成的<code>android.os.IInterface</code>的子类接口。作用是依靠<code>Service</code>中转，通过Binder机制来做IPC。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>AIDL支持的数据类型：</p><ul><li>byte</li><li>char</li><li>short</li><li>int</li><li>long</li><li>float</li><li>double</li><li>boolean</li><li>Parcelable</li><li>List</li><li>Map</li></ul><h3 id="定向Tag"><a href="#定向Tag" class="headerlink" title="定向Tag"></a>定向Tag</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookInOut</span><span class="params">(inout Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookIn</span><span class="params">(in Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookOut</span><span class="params">(out Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>in 数据只能由客户端流向服务端</li><li>out 数据只能由服务端流向客户端</li><li>inout 数据可在服务端与客户端之间双向流通</li></ul><p>如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。</p><blockquote><p>引自<a href="https://www.jianshu.com/p/29999c1a93cd">https://www.jianshu.com/p/29999c1a93cd</a></p></blockquote><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名与项目包名一致</span></span><br><span class="line"><span class="keyword">package</span> com.vee.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   自动生成的接口</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *    我们自己声明的业务函数</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 本接口的默认实现，其中业务方法`getName`返回null;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *   静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 用来标记当前Binder，所以采用全类名表示</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.vee.aidltest.IMyAidlInterface&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   构造方法中调用对象方法。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.vee.aidltest.IMyAidlInterface))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((com.vee.aidltest.IMyAidlInterface)iin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回当前Binder对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span>&#123;</span><br><span class="line">        java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (code)&#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">            &#123;</span><br><span class="line">            reply.writeString(descriptor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_getName:</span><br><span class="line">            &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            java.lang.String _arg0;</span><br><span class="line">            _arg0 = data.readString();</span><br><span class="line">            java.lang.String _result = <span class="keyword">this</span>.getName(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeString(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   自动生成的静态代理，在客户端回调</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">        Proxy(android.os.IBinder remote)&#123;</span><br><span class="line">            mRemote = remote;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mRemote;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">            android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">            java.lang.String _result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultImpl().getName();</span><br><span class="line">            &#125;</span><br><span class="line">            _reply.readException();</span><br><span class="line">            _result = _reply.readString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.IMyAidlInterface sDefaultImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   用来标记我们自己定义的方法，前缀确定</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当处于客户端时调用，这里就是生成代理</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setDefaultImpl</span><span class="params">(com.vee.aidltest.IMyAidlInterface impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;setDefaultImpl() called twice&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   当处于客户端时用来获取代理对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.<span class="function">IMyAidlInterface <span class="title">getDefaultImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DESCRIPTOR"><a href="#DESCRIPTOR" class="headerlink" title="DESCRIPTOR"></a>DESCRIPTOR</h4><p>Binder的唯一标识，一般用当前Binder的类名表示，比如本例中的<code>com.ryg.chapter_2.aidl.IBookManager</code>。</p><h4 id="asInterface-android-os-IBinder-obj"><a href="#asInterface-android-os-IBinder-obj" class="headerlink" title="asInterface(android.os.IBinder obj)"></a>asInterface(android.os.IBinder obj)</h4><p>用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。</p><h4 id="asBinder"><a href="#asBinder" class="headerlink" title="asBinder"></a>asBinder</h4><p>此方法用于返回当前Binder对象。</p><h4 id="onTransact-重要"><a href="#onTransact-重要" class="headerlink" title="onTransact:重要"></a>onTransact:重要</h4><p>这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为<code>public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   用来标记我们自己定义的方法，前缀确定</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。</p><p>然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值（如果目标方法有返回值的话），而有异常的话也会写进reply。reply也是个Parcel，所以这里是把数据写进了流。</p><p>onTransact方法的执行过程就是这样的。需要注意的是，如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p><h4 id="Proxy-getName"><a href="#Proxy-getName" class="headerlink" title="Proxy#getName"></a>Proxy#getName</h4><p>这个方法运行在客户端。</p><p>首先从Parcel的缓存池中拿到两个parcel对象分别是<code>_data</code>和<code>_reply</code>，然后把参数<code>name</code>写进<code>_data</code>，</p><p>然后调用<code>mRemote</code>对象的<code>transact()</code>方法发起RPC请求，同时挂起当前线程。</p><p>这里调用<code>transact()</code>时传递了<code>Stub.TRANSACTION_getName</code>，RPC到服务端时也是依靠方法ID去调用方法的。</p><p>然后服务端的<code>transact</code>方法会回调，知道RPC过程结束返回后，当前线程继续执行，并从_reply中读取服务端<code>transact</code>方法的返回值或者异常。</p><p>最后先回收刚刚拿到的Parc#el，然后返回<code>_result</code>给客户端。</p><p>这里的<code>mRemote</code>是个<code>IBinder</code>类型，但是后者其实是<code>Binder</code>的接口，那么可以断定<code>mRemote</code>其实就是个<code>Binder</code>。</p><h2 id="提取一下重点"><a href="#提取一下重点" class="headerlink" title="提取一下重点"></a>提取一下重点</h2><p>两个端：</p><ul><li>server</li><li>client</li></ul><p>两个标记：</p><ul><li>DESCRIPTOR：当前Binder的唯一标志</li><li>TRANSACTION_getName：方法的唯一标志</li></ul><p>两个个类型：</p><ul><li>abstract class <code>Stub</code> extends android.os.Binder implements IMyAidlInterface</li><li>static class <code>Proxy</code> implements IMyAidlInterface</li></ul><p>5个方法：</p><ul><li>asInterface</li><li>asBinder</li><li>业务方法</li><li>transact</li><li>onTransact</li></ul><h2 id="梳理流程"><a href="#梳理流程" class="headerlink" title="梳理流程"></a>梳理流程</h2><p><img src="../resource/binder%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt="binder通信机制"></p><ol><li>服务端向<code>ServiceManager</code>注册Binder。</li><li>客户端(通过<code>bindService()</code>回调)拿到Binder，调用<code>Stub.asInterface(binderObj)</code>。在这个方法中通过<code>DESCRIPTOR</code>标志在<code>ServiceManager</code>中去找Binder，如果找到直接返回，找不到就创建这个binder的Proxy对象。Proxy对象中包含被代理的业务方法。</li><li>客户端调用Proxy中代理的业务方法，此时创建两个Parcel：<code>_data</code>和<code>_reply</code>。然后调用代理中的binder的<code>transact()</code>方法，传入<code>TRANSACTION_getName</code>方法标记、_data、_reply，这样就执行了服务端binder中的业务逻辑方法，此时线程挂起。</li><li>客户端调用服务端的<code>transact()</code>方法会回调服务端的<code>onTransact()</code>方法。在这个方法中会根据<code>TRANSACTION_getName</code>判断应该调用哪个业务逻辑方法，然后挂起线程，执行对应的业务逻辑方法，最后在reply中写入异常或结果。</li><li>客户端继续执行<code>transact()</code>方法，从_reply中读取异常或返回值，再继续线程，最后回收_data和_reply并返回_reply中读到的结果。</li></ol><h2 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AIDL&quot;&gt;&lt;a href=&quot;#AIDL&quot; class=&quot;headerlink&quot; title=&quot;AIDL&quot;&gt;&lt;/a&gt;AIDL&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h</summary>
      
    
    
    
    
    <category term="Android binder" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-binder/"/>
    
  </entry>
  
  <entry>
    <title>Android中Message的一辈子</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/09/Android%E4%B8%ADMessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/09/Android%E4%B8%ADMessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</id>
    <published>2021-03-09T12:51:17.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare();</span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure><p>Looper.prepare()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化阶段主要做了四件事：</p><ol><li>依赖ThreadLocal给当前线程创建Looper的独立对象；</li><li>在Looper构造方法中创建MessageQueue；</li><li>创建Handler对象;</li><li>启动循环获取消息。</li></ol><h2 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方式1:</span></span><br><span class="line">Message.obtain();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line">mHandler.obtainMessage();</span><br></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1:</span></span><br><span class="line">mHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2:</span></span><br><span class="line">msg.sendToTarget();</span><br></pre></td></tr></table></figure><p>最终调用<code>MessageQueue.enqueueMessage(Message msg, long when)</code>。</p><p>所谓的发送消息，其实是干了3件事：</p><ol><li>把消息的状态改为inUse；</li><li>重组MessageQueue中的mMessages链条，把新消息放在队首；</li><li>唤醒Looper所在线程，开始循环处理消息。</li></ol><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>Looper的<code>looper</code>方法中循环调用MessageQueue的<code>next</code>方法读取新的message，如果有新消息，就调用handler的<code>dispatchMessage(msg)</code>，进而调用<code>handleCallback()</code>或者调用<code>handleMessage</code>方法。最后通过msg的<code>msg.recycleUnchecked();</code>完成消息的回收复用。</p><p>而此时，如果没有消息，或者下一个消息是延迟消息且还没到时间，looper会回调所有的idleHandler，然后通过linux的epoll机制进入休眠，降低cpu负载，直到调用Looper对象的<code>quitSafely()</code>，进一步调MessageQueue的<code>quit()</code>方法，更改<code>mQuitting</code>标记，使MessageQueue的<code>next</code>方法返回null，跳出Lopper的<code>loop</code>循环，释放了线程。</p><blockquote><p>明天补一张生命周期时序图吧，今天先到这了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Android handler Message Looper" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-handler-Message-Looper/"/>
    
  </entry>
  
  <entry>
    <title>MessageQueue解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/04/MessageQueue%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/04/MessageQueue%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-04T12:01:35.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>handler发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//最后调用的是queue.enqueueMessage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper循环读取消息并发送给Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// 从MessageQueue中取出Message</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//调用Handler的dispatchMessage</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论如何都会回收消息</span></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Message mMessages;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//发送的消息必须是闲置状态的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123; <span class="comment">//mQuitting是一个状态，只有MessageQueue的quit方法调用时才这个状态才会为true</span></span><br><span class="line">            msg.recycle();<span class="comment">//回收</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse(); <span class="comment">//改状态为使用中</span></span><br><span class="line">        msg.when = when;<span class="comment">//注意这里赋值</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点是时间的比较，如果新的msg的时间早于当前的message，那么就把新的msg放在头部。</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();<span class="comment">//如果是异步消息</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//又一个死循环，用来向下遍历队列，</span></span><br><span class="line">                prev = p;<span class="comment">//把当前的msg设为前一个msg</span></span><br><span class="line">                p = p.next;<span class="comment">//当前的msg指向下一个msg</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;<span class="comment">//如果我们设置时间的早于msg的时间，那么就停止遍历</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);<span class="comment">//唤醒线程处理消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，<code>enqueueMessage</code>的作用是采用<code>synchronized</code>同步阻塞的方式操作Message链条的头部，依据Message的延迟时间，打断链条重新排序，同时修改msg的状态，利用共享内存（mMessages）达到线程间通信的目的。</p><p>那么所谓的<code>Handler.sendMessage(msg)</code>是真的发送消息吗？并不是！它只是修改了Looper中持有的MessageQueue中的mMessages的链条顺序，然后等待<code>Looper</code>不断循环获取，再传递回<code>mHandler.dispatchMessage(msg)</code>而已。但这一改加一取，就能达到线程间通信的效果，并让我一直误以为是真的通过序列化之后发送出去。</p><blockquote><p>不看不知道，一看好鸡贼！</p></blockquote><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当loop执行了quit后，程序可能会重启looper，就会返回到这里。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">//只有在第一次遍历时是-1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//用来在线程要进入阻塞之前跟内核线程发送消息，防止用户线程长时间的持有某个对象</span></span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);<span class="comment">//告诉linux的epoll：你丫可以睡nextPollTimeoutMillis这么长时间了！直到handler发送消息调用`mQueue.enqueueMessage()`方法时会被唤醒，或者当前消息到时间时也会被唤醒。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试检索下一个msg，找到就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//靠栅栏停滞，找到下一个异步msg</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//下一个消息还没到时间。设置一个唤醒时段</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是异步消息，prevMsg就是null</span></span><br><span class="line">                        mMessages = msg.next;<span class="comment">//往上提一位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;<span class="comment">//打断链条单独取出</span></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();<span class="comment">//改变状态为使用中</span></span><br><span class="line">                    <span class="keyword">return</span> msg;<span class="comment">//返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果当前没有消息，把唤醒时钟设为-1，那么意味着线程会沉睡Integer.MaxValue</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///接下来就是喜闻乐见的idleHandler了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();<span class="comment">//如果没有添加过idleHandler，那么就是0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有idleHandler需要执行，那就继续loop</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化一个固定长度的数组</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历执行所有的idleHandler.</span></span><br><span class="line">        <span class="comment">//只有在第一次循环时才会执行到这个代码块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// 强行释放数组中的idleHandler，不会影响ArrayList中的idleHandler和当前正在使用的idleHandler。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();<span class="comment">//回调queueIdle方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重置计数</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment">* waiting for more messages.</span></span><br><span class="line"><span class="comment">* 当线程将要锁定（等待更多消息）时就会回调queueIdle方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当MessqgeQueue已经处理完所有的message，并且将要进入睡眠和等待时这个方法才会被调用。</span></span><br><span class="line"><span class="comment">    * 返回true可以使IdleHandler保持激活状态，那么当下次线程空闲了还会调用，返回false就会移除IdleHandler。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来这玩意根本不是什么Handler的子类，而是MessageQueue的一个内部静态类而已！</p><p>然后我就不太明白这个玩意了，去百了个度，拿到答案如下：</p><p>之前做过冷启动优化，在冷启动的场景有很多的任务其实并不需要马上启动，通常的做法就是做一个延迟启动，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">mHandler.postDelayed(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>将任务延迟启动1000ms，但是这个延迟启动的时间不好确定，只能是自己预估的，对于一些高端手机1000ms可能多了，一些低端手机可能1000ms还不够。这个时候IdelHandler就可以解决这个问题，它能够在CPU空闲的时候再执行指定的任务。</p><p>使用方法也很简单，如下所示，调用addIdleHandler方法就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.IdleHandler idleHandler = <span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Looper.getMainLooper().getQueue().addIdleHandler(idleHandler);</span><br></pre></td></tr></table></figure><p>引自<a href="https://blog.csdn.net/hbdatouerzi/article/details/104148722"></a></p><blockquote><p>我惊叹啊，还能这么玩啊～～想到以前面试官问过我怎么做延迟启动，我回答ContentProvider和StartUp，我觉得是没错的，但是她想要的应该就是这个IdleHandler。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加时有非空判断和线程安全。</p><p>然后具体的操作也是在MessqgeQueue的<code>next</code>方法中进行的。那么IdleHandler怎么判断线程是否空闲呢？看<code>next</code>方法中这一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件1:没有msg或msg还没到执行的时候</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">        <span class="comment">//msg时间晚于当前时间</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件2:looper没有停止</span></span><br><span class="line"><span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件3:不存在IdleHandler的话就重新遍历</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以判断线程是否将进入空闲，也就是IdleHandler的执行时机，是依据：</p><ol><li>MessageQueue中没有消息或当前消息不必马上执行；</li><li>Looper没有释放；</li><li>队列中存在IdleHandler。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;handler发送消息：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="Android Handler Looper Message MessageQueue" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-Handler-Looper-Message-MessageQueue/"/>
    
  </entry>
  
  <entry>
    <title>Handler解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/04/Handler%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/04/Handler%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-04T02:40:11.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中可以看到，<code>handler</code>持有<code>Looper</code>的<code>MessageQueue</code>。</p><h2 id="obtainMessage"><a href="#obtainMessage" class="headerlink" title="obtainMessage"></a>obtainMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler的<code>obtainMessage()</code>其实还是调用<code>Message.obtain()</code>方法，所以直接调用后者反而效率更高。</p><h2 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//最后调用的是queue.enqueueMessage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessage</code>最后是通过<code>MessageQueue</code>的<code>enqueueMessage</code>实现消息的发送。</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>post其实也是基于消息实现的，但与发送消息不同的是，<code>post</code>是先创建个消息，然后把<code>Runnable</code>类型的参数赋值给msg的<code>callback</code>。前面解读<code>Message</code>的时候了解到，<code>callback</code>是在handler接收到消息的时候才执行，它与handler在同一线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   把Runnable添加到message中，并且在handler所在线程运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();<span class="comment">//从message回收池中取一个闲置msg</span></span><br><span class="line">    m.callback = r;<span class="comment">//赋值callback</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="postDelayed"><a href="#postDelayed" class="headerlink" title="postDelayed"></a>postDelayed</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般面试的会考这个方法，我感觉也没啥啊，无非就是个<code>SystemClock.uptimeMillis()</code>加上设定的延迟时间。</p><p><code>SystemClock.uptimeMillis()</code>是从系统启动后开始累计的时间，并且在系统进入深度睡眠的时候暂停累计。</p><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>前面在<a href="Looper%E8%A7%A3%E8%AF%BB.md">Looper解读</a>里了解到，Looper在<code>loop</code>方法中死循环读取message，然后通过<code>msg.target.dispatchMessage(msg);</code>方法发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Handle system messages here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到，<strong>如果msg的callback不为空，那么就处理callback,反之则处理msg</strong>。这就是为什么给msg添加了callback之后，Handler的<code>handleMessage</code>不会再回调的原因。</p><p>handleCallback:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在当前线程去跑Runnable类型的callback。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构造方法&quot;&gt;&lt;a href=&quot;#构造方法&quot; class=&quot;headerlink&quot; title=&quot;构造方法&quot;&gt;&lt;/a&gt;构造方法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Message解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/03/Message%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/03/Message%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-03T07:03:03.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们都知道创建Message的时候有两种方式：</p><ul><li>构造方法创建（不推荐）。</li><li><code>Message.obtain();</code>（推荐）.</li></ul><p>为了防止OOM，我们一般都是直接用第二种方式，直接从回收池里面拿闲置。那么这个闲置的Message是从哪创建的呢？为什么我们不用先new一个Message，回收池里面就有呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 池子</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">private static Message sPool;</span></span><br><span class="line"><span class="comment">private static int sPoolSize = 0;</span></span><br><span class="line"><span class="comment">private static final int MAX_POOL_SIZE = 50;</span></span><br><span class="line"><span class="comment"><span class="doctag">@UnsupportedAppUsage</span></span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">//打断了链条</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出，<code>obtain()</code>方法检查池子为null,就会自动<code>new</code>一个message出来。而如果不为空，则抽取出来清一下状态返回，并把原来的<code>next</code>前置给<code>sPool</code>，最后把<code>size</code>自减1。</p><p>这里的<code>sPoll</code>比较有意思，叫池子，但其实是个单向链，我觉得叫队列更合适。但是看到后面会发现还是应该叫池子。</p><p>所以，**<code>Message</code>的实质是单向链+Size整数，最多不能超过50个！**</p><h2 id="回收复用指定的Message"><a href="#回收复用指定的Message" class="headerlink" title="回收复用指定的Message"></a>回收复用指定的Message</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but copies the values of an existing</span></span><br><span class="line"><span class="comment"> * message (including its target) into the new one.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orig Original message to copy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.what = orig.what;</span><br><span class="line">    m.arg1 = orig.arg1;</span><br><span class="line">    m.arg2 = orig.arg2;</span><br><span class="line">    m.obj = orig.obj;</span><br><span class="line">    m.replyTo = orig.replyTo;</span><br><span class="line">    m.sendingUid = orig.sendingUid;</span><br><span class="line">    m.workSourceUid = orig.workSourceUid;</span><br><span class="line">    <span class="keyword">if</span> (orig.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.data = <span class="keyword">new</span> Bundle(orig.data);</span><br><span class="line">    &#125;</span><br><span class="line">    m.target = orig.target;</span><br><span class="line">    m.callback = orig.callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要回收并且复用指定的Message，那么就把该message传递到obtain方法中。在方法内部，其实是通过copy值给回收的message来完成。</p><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p><code>obtain</code>方法可以传递一个Handler对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * Same as &#123;@link #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;&#x2F;em&gt; member on the Message returned.</span><br><span class="line">    * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;&#x2F;em&gt; member.</span><br><span class="line">    * @return A Message object from the global pool.</span><br><span class="line">    *&#x2F;</span><br><span class="line">public static Message obtain(Handler h) &#123;</span><br><span class="line">    Message m &#x3D; obtain();</span><br><span class="line">    m.target &#x3D; h;</span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指定了对象，就可以通过<code>sendToTarget()</code>方法直接发送Message了。</p><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain(Handler)&#125;, but assigns a callback Runnable on</span></span><br><span class="line"><span class="comment">     * the Message that is returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Handler to assign to the returned Message object&#x27;s &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback Runnable that will execute when the message is handled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.callback = callback;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>obtain</code>方法还可以传递一个<code>Runnable</code>，作用是当message发送到Handler时就会执行这个<code>runnable</code>。而且这个<strong>callback竟然与Handler在同一线程中！！！</strong></p><p>但是一旦给消息设置了<code>callback</code>，实测Handler的<code>handleMessage</code>会失效，这是为啥，要想一想了。</p><h2 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h2><ul><li><code>mHandler.send(msg);</code></li><li><code>msg.sendToTarget();</code></li><li>Parcelable</li></ul><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>设置消息是否异步，这意味着它不受{@link Looper}同步障碍的约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方式我平时很少使用，听说是可以提升消息的重要性，如果标明异步，那么MessageQueue将会由近及远优先处理异步消息，然后再处理同步消息。</p><h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先检测是否在使用中，检测通过才真正的回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回收一个可能正在使用中的Message。</span></span><br><span class="line"><span class="comment"> *   当队列中的Message被释放时，由MessageQueue 和 Looper在内部调用此方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool; <span class="comment">// 添加入链条</span></span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是把当前的Message对象回滚到初始状态，并且标记为「正在使用」。把当前的Message赋值给了<code>next</code>，并且<code>sPoolSize++</code>,表示多了个闲置。</p><p><code>MAX_POOL_SIZE</code>常量的值为50，那么就是<strong>一个App最多能有50个闲置的message</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Message</code>的原理是<strong>整数sPoolSize+静态单向链sPoll</strong>，平时我们使用的message都是从<code>sPoll</code>中取<strong>队首</strong>，状态改为闲置，回收后把状态改成「使用中」，并插回到<strong>队首</strong>，遵循「后进先出」原则，并在<strong>填充</strong>和<strong>回收</strong>时通过<code>synchronized</code>保障线程安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;p&gt;我们都知道创建Message的时候有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造方法创建（不推荐）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Messa</summary>
      
    
    
    
    
    <category term="android message" scheme="https://vee-zhang.github.io/Vee-blog/tags/android-message/"/>
    
  </entry>
  
  <entry>
    <title>Looper解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/02/Looper%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/02/Looper%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-02T09:30:46.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="../resource/handler%E7%9B%B8%E5%85%B3/Looper.dotuml.png" alt="类图"></p><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法中创建MessageQueue，并引用当前线程。</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">private Looper(boolean quitAllowed) &#123;</span></span><br><span class="line"><span class="comment">    mQueue = new MessageQueue(quitAllowed);</span></span><br><span class="line"><span class="comment">    mThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Looper.prepare()</code>方法只是为了初始化<code>ThreadLocal</code>。</p><p>之前了解过，<code>ThreadLocal</code>可以包证多线程访问共享变量的线程安全问题。他不像<code>synchronized</code>靠阻塞实现线程安全，而是通过对变量拷贝的方式，使每一个线程都操作自己的拷贝，实现线程安全，所以效率要优于<code>synchronized</code>。<a href="https://www.jianshu.com/p/6fc3bba12f38">详情看这里</a>和<a href="http://www.jasongj.com/java/threadlocal/">这里</a></p><p>ThreadLocal在此处的使用是为了保证每个线程都只能分配到一个Looper对象，多次调用<code>Looper.prepary()</code>方法会抛出异常。而且在其他线程去操作这个Looper对象可以保证线程安全，比如在主线程中调用<code>mHandler.getLooper().quitSafely()</code>来终止子线程的Looper对象的<code>loop()</code>循环。</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p>只看核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//其实就是从threadLocal中取出looper</span></span><br><span class="line">    <span class="comment">//省略判空</span></span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>; <span class="comment">//改变状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//拿到MessageQueue</span></span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来就是启动个死循环，为什么不用while而用for呢？</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// 从MessageQueue中取出Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果池子里面没有msg了则终止循环，所以这里并不是一个真正的死循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//调用Handler的dispatchMessage</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无论如何都会回收消息</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里死循环的写法比较特殊，为什么不用<code>while(true)</code>或者<code>do-while(true)</code>呢？一开始总是想不明白。后来发现，用while系列循环，无论如何都要传递个表达式进去，那么就涉及到了内存占用。而用空for循环，则不必创建任何变量或结构体，能够最大限度的降低内存占用，真是学到了。</p><p>今天又突然想到，既然涉及到表达式，那么每次循环的时候都需要判断表达式是否成立，无可避免浪费了cpu，同时带来了cpu计算单元做无效计算带来的性能损失。</p><h2 id="主线程中为何不ANR也不会内存泄露"><a href="#主线程中为何不ANR也不会内存泄露" class="headerlink" title="主线程中为何不ANR也不会内存泄露"></a>主线程中为何不ANR也不会内存泄露</h2><p>我们都知道线程一旦运行完毕就会回收，那么主线程中没有执行任何动作时为何不会回收呢？原因就是因为looper在死循环，阻塞了主线程的回收，那么相应的一旦不再死循环，程序也就退出了。Android同时利用Looper的死循环，发送消息，比如通知View重绘等等。</p><h2 id="会不会阻塞子线程呢？"><a href="#会不会阻塞子线程呢？" class="headerlink" title="会不会阻塞子线程呢？"></a>会不会阻塞子线程呢？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">        Message msg = Message.obtain(handler, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;&quot;</span>, <span class="string">&quot;run: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        msg.sendToTarget();</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;这里永远都不会执行&quot;</span>, <span class="string">&quot;run:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用<strong>Profile</strong>持续观察之后发现：答案是会！CPU会一直被占用，线程池也无法回收该线程！</p><h2 id="终止loop"><a href="#终止loop" class="headerlink" title="终止loop"></a>终止loop</h2><p>所以为了尽可能减少CPU浪费，应该调用<code>handler.getLooper().quitSafely();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看<code>mQueue.quit(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是修改了<code>mQuitting = true;</code>，这就是个标记，用来判断是否终止死循环。造成的效果呢当然是在<code>loop</code>方法的死循环中调用<code>mqueue.next()</code>时，会收到下面的影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dispose() &#123;</span><br><span class="line">    if (mPtr !&#x3D; 0) &#123;</span><br><span class="line">        nativeDestroy(mPtr);</span><br><span class="line">        mPtr &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br></pre></td></tr></table></figure><p>直接返回null，而在Looper的<code>loop</code>方法的死循环中有这样的判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line">if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; No message indicates that the message queue is quitting.</span><br><span class="line">    me.mLogging.println(&quot;注意啦，真的停啦～～～&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>queue.next</code>返回null那么就终止循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../resource/handler%E7%9B%B8%E5%85%B3/Looper.dotuml.png&quot; alt</summary>
      
    
    
    
    
    <category term="android" scheme="https://vee-zhang.github.io/Vee-blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment在Activity中的生命周期</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-02-26T03:17:35.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记忆方式"><a href="#记忆方式" class="headerlink" title="记忆方式"></a>记忆方式</h2><p>Fragment的<code>onAttach</code>,<code>onCreate</code>,<code>onCreateView</code>,<code>onViewCreated</code>在附加到Activity时执行，如<code>setContentView</code>或者<code>add</code>,<code>replace</code>时。</p><p>Fragment的<code>onResume</code>是在Activity的<code>onResume</code>执行完之后才会执行，而其他生命周期都在Activity的<code>super.onXXX</code>内执行。</p><p>跳转时，前一个页面的生命周期走到<code>onPause</code>时暂停，等待后一个页面的生命周期走到<code>onResume</code>之后，再继续执行<code>onStop</code>；同理，返回时后一个页面走到<code>onPause</code>时暂停，前一个页面<code>onRestart</code>,<code>onStart</code>,<code>onResume</code>之后，再继续执行剩下的<code>onStop</code>,<code>onDestory</code>。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/source/resource/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="生命周期"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onCreate: 前</span><br><span class="line">D: FirstActivity&#39;s super.onCreate: 后</span><br><span class="line">D: FirstActivity&#39;s setContentView: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onAttach: </span><br><span class="line">D: FirstFragment&#39;s onCreate: </span><br><span class="line">D: FirstFragment&#39;s onCreateView: </span><br><span class="line">D: FirstFragment&#39;s onViewCreated: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s setContentView: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onActivityCreated: </span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><p>fragment的<code>onAttach</code>，<code>onCreate</code>，<code>onCreateView</code>，<code>onViewCreated</code>是在Activity的<code>setContentView</code>中执行的。</p><p>想一下就知道，Activity的<code>setContentView</code>的目的是从xml中加载View，而我把fragment写在了xml里面。</p><blockquote><p>这里有个小插曲，事实证明，Activity的<code>super.onCreate</code>可以写在<code>setContentView</code>之后，但是xml中存在fragment时就会报错。</p></blockquote><p>fragment的<code>onActivityCreated</code>、<code>onStart</code>是在Activity的<code>super.onStart</code>方法中执行。</p><p>fragment的<code>onResume</code>是在activity的<code>super.onResume</code>之后执行。</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 前</span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 后</span><br><span class="line">D: SecondActivity&#39;s setContentView: 前</span><br><span class="line">D: SecondFragment&#39;s onAttach: </span><br><span class="line">D: SecondFragment&#39;s onCreate: </span><br><span class="line">D: SecondFragment&#39;s onCreateView: </span><br><span class="line">D: SecondFragment&#39;s onViewCreated: </span><br><span class="line">D: SecondActivity&#39;s setContentView: 后</span><br><span class="line">D: SecondActivity&#39;s super.onStart: 前</span><br><span class="line">D: SecondFragment&#39;s onActivityCreated: </span><br><span class="line">D: SecondFragment&#39;s onStart: </span><br><span class="line">D: SecondActivity&#39;s super.onStart: 后</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 前</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 后</span><br><span class="line">D: SecondFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><p>fragment的<code>onPause</code>是在Activity的<code>super.onPause</code>中执行。</p><p>当第二个含有fragment的Activity可见后，上一个Activity的生命周期才会继续。</p><p>然后上一个fragment的<code>onStop</code>在Activity的<code>onStop</code>中执行。</p><p><strong>注意</strong>，前一个Activity执行到<code>onPause</code>，然后第二个Activity生命周期完成后，前一个Activity才会执行<code>onStop</code>。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D: SecondActivity&#39;s super.onPause: 前</span><br><span class="line">D: SecondFragment&#39;s onPause: </span><br><span class="line">D: SecondActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onStop: 前</span><br><span class="line">D: SecondFragment&#39;s onStop: </span><br><span class="line">D: SecondActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: SecondFragment&#39;s onDestroyView: </span><br><span class="line">D: SecondFragment&#39;s onDestroy: </span><br><span class="line">D: SecondFragment&#39;s onDetach: </span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 后</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先执行第二个Activity的<code>onPause</code>。</p><p>再回调前一个Activity的<code>onRestart</code>。</p><p>fragment的<code>onStart</code>在Activity的<code>super.onStart</code>中执行。</p><p>fragment的<code>onResume</code>在Activity的<code>super.onResume</code>中执行。</p><p>fragment的<code>onStop</code>在Activity的<code>super.onStop</code>中执行。</p><p>fragment的<code>onDestroyView</code>、<code>onDestroy</code>、<code>onDetach</code>在Activity的<code>super.onDestroy</code>中执行。</p><p><strong>注意</strong>fragment的<code>onResume</code>是在Activity的<code>onResume</code>之后执行的！！！</p><h2 id="退入后台"><a href="#退入后台" class="headerlink" title="退入后台"></a>退入后台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><h2 id="回到前台"><a href="#回到前台" class="headerlink" title="回到前台"></a>回到前台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: FirstFragment&#39;s onDestroyView: </span><br><span class="line">D: FirstFragment&#39;s onDestroy: </span><br><span class="line">D: FirstFragment&#39;s onDetach: </span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 后</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记忆方式&quot;&gt;&lt;a href=&quot;#记忆方式&quot; class=&quot;headerlink&quot; title=&quot;记忆方式&quot;&gt;&lt;/a&gt;记忆方式&lt;/h2&gt;&lt;p&gt;Fragment的&lt;code&gt;onAttach&lt;/code&gt;,&lt;code&gt;onCreate&lt;/code&gt;,&lt;code&gt;onC</summary>
      
    
    
    
    
    <category term="android,生命周期,fragment,activity" scheme="https://vee-zhang.github.io/Vee-blog/tags/android-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-fragment-activity/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL-Java(二)DataFetching</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E4%BA%8C)DataFetcher/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E4%BA%8C)DataFetcher/</id>
    <published>2021-01-23T14:28:28.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphQL如何获取数据"><a href="#GraphQL如何获取数据" class="headerlink" title="GraphQL如何获取数据"></a>GraphQL如何获取数据</h2><p>每个field都有一个<code>graphql.schema.DataFetcher与之对应</code>。</p><p>一些File会使用特定的data fetcher，这种DataFetcher知道怎么去访问数据库获取field的信息，然后大多数的dataFetcher则是简单的从内存中的object获取数据。在获取数据时，会参照field的名字and Plain Old Java Object (POJO) patterns to get the data.</p><p>所以可以像这样来声明一个type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">    products(match : String) : [Product]   # a list of products</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Product &#123;</span><br><span class="line">    id : ID</span><br><span class="line">    name : String</span><br><span class="line">    description : String</span><br><span class="line">    cost : Float</span><br><span class="line">    tax : Float</span><br><span class="line">    launchDate(dateFormat : String &#x3D; &quot;dd, MMM, yyyy&#39;) : String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Query.products</code>这个field有一个data fetcher，用来获取从数据库中获取<code>Product</code>类型的fields集合。它带有一个<code>match</code>参数，可以过滤出我们想要的product：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher productsDataFetcher = <span class="keyword">new</span> DataFetcher&lt;List&lt;ProductDTO&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProductDTO&gt; <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        DatabaseSecurityCtx ctx = environment.getContext();</span><br><span class="line"></span><br><span class="line">        List&lt;ProductDTO&gt; products;</span><br><span class="line">        String match = environment.getArgument(<span class="string">&quot;match&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (match != <span class="keyword">null</span>) &#123;</span><br><span class="line">            products = fetchProductsFromDatabaseWithMatching(ctx, match);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products = fetchAllProductsFromDatabase(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>DataFetcher</code>相互之间传递着一个<code>graphql.schema.DataFetchingEnvironment</code>对象，这个对象包含正在获取的field、传递给field的参数arguments、和其他信息诸如field的类型，它父级的类型query root object或者query context object。</p><p>要注意的是，data fetcher的编码是基于context object作为一个安全程序来处理数据库的访问。这是一个基本技术来提供一个底层调用上下文。</p><p>当我们有一个<code>ProductDTO</code>的列表，我们不需要为每一个field都搞一个data fetcher。graphql-java 有一个聪明的<code>graphql.schema.PropertyDataFetcher</code>知道怎么去根据名称追踪POJO的结构。在本例中就是有个带有name的field，然后<code>graphql.schema.PropertyDataFetcher</code>将尝试通过POJO的<code>public String getName()</code>方法来获取数据。</p><p><code>graphql.schema.PropertyDataFetcher</code>是默认的DataFetcher。</p><p>你仍然可以在DTO的方法中使用<code>graphql.schema.PropertyDataFetcher</code>来访问。这允许你在数据发送出去之前先做修改。比如，我们有个<code>launchDate</code>字段携带者一个可选的<code>dateFormat</code>参数。我们可以在ProductDTO中写个逻辑做日期时间的格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ID id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> Double cost;</span><br><span class="line">    <span class="keyword">private</span> Double tax;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime launchDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLaunchDate</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        String dateFormat = environment.getArgument(<span class="string">&quot;dateFormat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> yodaTimeFormatter(launchDate,dateFormat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定制PropertyDataFetcher"><a href="#定制PropertyDataFetcher" class="headerlink" title="定制PropertyDataFetcher"></a>定制PropertyDataFetcher</h2><p>像之前讲的一样，<code>graphql.schema.PropertyDataFetcher</code>是默认的data fetcher，并且它在获取数据时使用标准结构。</p><p>它支持POJO和map。假设有个field叫<code>fieldX</code>，它将会寻找一个POJO也叫做<code>fieldX</code>，或者在Map中去找一个key也叫做<code>fieldX</code>。</p><p>然而，你在定义的schema与POJO有一点不通，比如<code>Product.description</code>对应着POJO中的<code>getDesc()</code>.</p><p>你可以在SDL中使用<code>@fetch</code>注解来做匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">directive @fetch(from : String!) on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type Product &#123;</span><br><span class="line">    id : ID</span><br><span class="line">    name : String</span><br><span class="line">    description : String @fetch(from:&quot;desc&quot;)</span><br><span class="line">    cost : Float</span><br><span class="line">    tax : Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将告诉<code>graphql.schema.PropertyDataFetcher</code>在获取数据时应该使用名为<code>desc</code>的属性来对应SDL中的<code>description</code>字段。</p><p>如果你不用SDL,而是喜欢手写代码，那么可以直接指定Data Fetcher:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GraphQLFieldDefinition descriptionField = GraphQLFieldDefinition.newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;description&quot;</span>)</span><br><span class="line">                .type(Scalars.GraphQLString)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        GraphQLCodeRegistry codeRegistry = GraphQLCodeRegistry.newCodeRegistry()</span><br><span class="line">                .dataFetcher(</span><br><span class="line">                        coordinates(<span class="string">&quot;ObjectType&quot;</span>, <span class="string">&quot;description&quot;</span>),</span><br><span class="line">                        PropertyDataFetcher.fetching(<span class="string">&quot;desc&quot;</span>))</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h2 id="DataFetchingEnvironment中有意思的部分"><a href="#DataFetchingEnvironment中有意思的部分" class="headerlink" title="DataFetchingEnvironment中有意思的部分"></a>DataFetchingEnvironment中有意思的部分</h2><p>每一个data fetcher都传递了一个<code>graphql.schema.DataFetchingEnvironment</code>对象。它知道我们正在获取什么东西，并且知道提供了哪些参数。</p><ul><li><code>&lt;T&gt; T getSource()</code>-获取field的信息。这个对象就是父级获取到的结果，他一个内存中的DTO对象，并且通过POJO的getters获取到值。在复杂的场景中，你可以通过检查它来获取field的特定信息。当graphql的field tree执行后返回的每一个field的值，都会成为子级的<code>source</code>。</li><li><code>&lt;T&gt; T getRoot()</code>-用来查看graphql的查询query。在顶层级中，root和source是一样的。root object在查询期间是不会改变的，它可能为null，所以尽量不要用这玩意。</li><li><code>Map&lt;String, Object&gt; getArguments()</code>-用来获取field提供的参数。</li><li><code>&lt;T&gt; T getContext()</code>-当query第一次执行时，才会设置好context，并让其停留在query的生命周期上。所以context的生命周期与query一致。context可以是任何值，主要是data fetcher在获取数据时需要这玩意。所以只需要把它注入给data fetcher就行了，其他场景都用不到。（日了狗了，讲了这么长一串，最后特么没点鸟用）</li><li><code>ExecutionStepInfo getExecutionStepInfo()</code>-用来获取<code>ExecutionStepInfo</code>。当query执行后，<code>ExecutionStepInfo</code>存放了所有field的类型信息。</li><li><code>DataFetchingFieldSelectionSet getSelectionSet()</code>-用来获取选项集。所谓「选项集」就是当前执行中的field之后的哪些被「选中」的子filed们。这对于展望接下来将要执行的field的信息。（我感觉就像是音乐播放器在播放收藏的专辑一样，比如当前播放到了费玉清的《天之大》，那么我们就可以通过这个方法去查看《天之大》下面有哪些歌将要被播放了）。</li><li><code>ExecutionId getExecutionId()</code>-所有的查询都有一个unique id。可以把id作为log日志的tag，用来打印特定的query。</li></ul><h3 id="ExecutionStepInfo好玩的地方"><a href="#ExecutionStepInfo好玩的地方" class="headerlink" title="ExecutionStepInfo好玩的地方"></a>ExecutionStepInfo好玩的地方</h3><p>一个graphql query在执行时会生成一个call tree，就是「调用树」。<code>graphql.execution.ExecutionStepInfo.getParentTypeInfo</code>允许你向上导航，看到是什么类型的field被带到了当前的执行过程。</p><p>在整个执行期间，就形成了一个树形path，<code>graphql.execution.ExecutionStepInfo.getPath</code>方法可以返回这个树形path的描述。这在日志打印和调试query时比较有用。而且可以查看到非空类型的名称和折叠后的列表。</p><p>一句话总结就是，主要用于调试和排错。</p><h3 id="DataFetchingFieldSelectionSet有趣的地方"><a href="#DataFetchingFieldSelectionSet有趣的地方" class="headerlink" title="DataFetchingFieldSelectionSet有趣的地方"></a>DataFetchingFieldSelectionSet有趣的地方</h3><p>想象一下有个query就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    products &#123;</span><br><span class="line">        # the fields below represent the selection set</span><br><span class="line">        name</span><br><span class="line">        description</span><br><span class="line">        sellingLocations &#123;</span><br><span class="line">            state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Product</code>的所有子field，对于<code>Product</code>来讲就是<code>selection fields</code>。当我们想要知道哪些子级field正在被请求时非常有用。举例来讲，我们的POJO中可能有很多属性，数据库表中的字段也与之一一对应。但是我们跑个graphql查询时可能不需要返回全部的字段，我们只要我们需要的字段就行了，此时data fetcher去查数据库时也不需要查出所有的列，也是按需获取就行了。那怎么在代码里感知到我们具体请求的哪些字段呢？就是靠这个<code>DataFetchingFieldSelectionSet</code>。</p><p>比如上例中我们请求了<code>sellingLocations</code>字段，或者我们使用更高效的查询：同时查出<code>products</code>和<code>sellingLocations</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphQL如何获取数据&quot;&gt;&lt;a href=&quot;#GraphQL如何获取数据&quot; class=&quot;headerlink&quot; title=&quot;GraphQL如何获取数据&quot;&gt;&lt;/a&gt;GraphQL如何获取数据&lt;/h2&gt;&lt;p&gt;每个field都有一个&lt;code&gt;graphql.s</summary>
      
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL-Java(零)从SpringBoot服务端开始</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E9%9B%B6)%E5%85%A5%E9%97%A8/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E9%9B%B6)%E5%85%A5%E9%97%A8/</id>
    <published>2021-01-23T08:38:19.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.graphql-java:graphql-java:14.1&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;com.graphql-java:graphql-java-spring-boot-starter-webmvc:1.0&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.guava:guava:26.0-jre&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义Schema"><a href="#定义Schema" class="headerlink" title="定义Schema"></a>定义Schema</h2><p>在<code>src/main/resources</code>中创建<code>schema.graphqls</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  bookById(id: ID): Book </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Book &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">  pageCount: Int</span><br><span class="line">  author: Author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Author &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  firstName: String</span><br><span class="line">  lastName: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个顶级字段：<code>bookById</code>，它用来返回特定ID的book；</p><p>并且定义了一个Boo类，其中包含<code>id</code>,<code>name</code>,<code>pageCount</code>,<code>author</code>。<code>author</code>是另一个类型。</p><h2 id="解析Schema"><a href="#解析Schema" class="headerlink" title="解析Schema"></a>解析Schema</h2><p>在项目中创建一个<code>GraphQLProvider</code>类型的java文件，用来创建GraphQL实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQL graphQL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQL <span class="title">graphQL</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> graphQL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用Guava Resources读取资源文件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = Resources.getResource(<span class="string">&quot;schema.graphqls&quot;</span>);</span><br><span class="line">        String sdl = Resources.toString(url, Charsets.UTF_8);</span><br><span class="line">        GraphQLSchema graphQLSchema = buildSchema(sdl);</span><br><span class="line">        <span class="keyword">this</span>.graphQL = GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(String sdl)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> we will create the schema here later </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过google的Guava <code>Resources</code>来读取Schema.graphql文件，并且通过<code>@Bean</code>注解把GraphQL实例暴露出去，GraphQL Java Spring adapter会使用这个GraphQL实例来把schema匹配到`/graphql’路径，以后通过这个路径调用所有接口。</p><p>接下来实现buildSchema方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">GraphQLDataFetchers graphQLDataFetchers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构建调用模型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sdl 从资源文件获取到的sdl语言内容</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(String sdl)</span> </span>&#123;</span><br><span class="line">    TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> SchemaParser().parse(sdl);</span><br><span class="line">    RuntimeWiring runtimeWiring = buildWiring();</span><br><span class="line">    SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line">    <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RuntimeWiring <span class="title">buildWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .type(newTypeWiring(<span class="string">&quot;Query&quot;</span>)</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;bookById&quot;</span>, graphQLDataFetchers.getBookByIdDataFetcher()))</span><br><span class="line">            .type(newTypeWiring(<span class="string">&quot;Book&quot;</span>)</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;author&quot;</span>, graphQLDataFetchers.getAuthorDataFetcher()))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeDefinitionRegistry</code> 是SDL转换成的java对象。<code>RuntimeWiring</code>才是真正的重点，主要作用是注册了两个<code>DataFetchers</code>：</p><ul><li>一个用来根据ID查book；</li><li>一个用来获取特定book的作者。</li></ul><p>仔细看代码会发现，在构建<code>RuntimeWiring</code>时用到的字符串参数，全都是我们在SDL中定义好的type，所以这里的作用是告诉GraphQL Adapter怎么去根据SDL拿对应的数据。</p><h2 id="DataFetchers"><a href="#DataFetchers" class="headerlink" title="DataFetchers"></a>DataFetchers</h2><p>DataFetcher是一个接口，用来根据SDL中的field来获取对应的数据，所以它内部只有一个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，SDL中每一个field都对应一个<code>DataFetcher</code>，如果没有特别指定一个<code>DataFetcher</code>，默认会采用<code>PropertyDataFetcher</code>。所以在上面生成<code>RuntimeWiring</code>的代码中，并没有对author注册dataFetcher，而是让他直接采用了默认的<code>PropertyDataFetcher</code>。</p><p>接下来我们就来实现<code>DataFetcher</code>了，创建一个<code>GraphQLDataFetchers</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLDataFetchers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; books = Arrays.asList(</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;223&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-1&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Moby Dick&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;635&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-2&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Interview with the vampire&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;371&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-3&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; authors = Arrays.asList(</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Joanne&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Rowling&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Herman&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Melville&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Anne&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Rice&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getBookByIdDataFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataFetchingEnvironment -&gt; &#123;</span><br><span class="line">            String bookId = dataFetchingEnvironment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> books</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(book -&gt; book.get(<span class="string">&quot;id&quot;</span>).equals(bookId))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getAuthorDataFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataFetchingEnvironment -&gt; &#123;</span><br><span class="line">            Map&lt;String,String&gt; book = dataFetchingEnvironment.getSource();</span><br><span class="line">            String authorId = book.get(<span class="string">&quot;authorId&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> authors</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(author -&gt; author.get(<span class="string">&quot;id&quot;</span>).equals(authorId))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全都是mock数据，亮点是采用了java的新特性，通过流式调用来处理集合，并且还有lamda表达式的书写。</p><p>上面的代码中，我们可以看到，<code>DataFetcher</code>是<code>DataFetchingEnvironment</code>，三个查询方法也都是返回<code>DataFetchingEnvironment</code>的实例，其中需要关注的是：</p><ul><li><code>getArgument(&quot;id&quot;)</code>用来获取参数。</li><li><code>getSource()</code>用来获取对象。</li></ul><p>根据我们在SDL中的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  bookById(id: ID): Book </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询book时需要传递一个id，所以这个id怎么获取呢？通过<code>dataFetchingEnvironment.getArgument(&quot;id&quot;)</code>就能获取到。</p><p>然后根据SDL中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Book &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String</span><br><span class="line">  pageCount: Int</span><br><span class="line">  author: Author</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询特定book的作者，那么需要一个特定的book实例，通过<code>getSource()</code>可以获取到父级的book实例。</p><p>在GraphQL中，<strong>每一个field的DataFetcher是从上到下，从父到子被调用的，并且父级的结果可以从子级的<code>DataFetcherEnvironment</code>的<code>getSource()</code>方法中取到</strong>。</p><h3 id="Default-DataFetchers"><a href="#Default-DataFetchers" class="headerlink" title="Default DataFetchers"></a>Default DataFetchers</h3><p>前面说过，如果不给field指定一个DataFetcher，那么将默认使用<code>PropertyDataFetcher</code>。在这个demo里，意味着<code>Book.id</code>, <code>Book.name</code>, <code>Book.pageCount</code>, <code>Author.id</code>, <code>Author.firstName</code>, <code>Author.lastName</code>都对应着一个<code>PropertyDataFetcher</code>。</p><p><code>PropertyDataFetcher</code>会通过多种方式从Java对象中找到对应的属性，如果是<code>java.util.Map</code>，就通过Key去找。这里要求field的名字与key一致。如果不一致就会返回null。（这里我翻译的不太对味，但是意思还是很明确的）。</p><h2 id="Try-API"><a href="#Try-API" class="headerlink" title="Try API"></a>Try API</h2><p>直接rest_client了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;localhost:9000&#x2F;graphql</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">X-REQUEST-TYPE: GraphQL</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    bookById(id:&quot;book-1&quot;)&#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        pageCount</span><br><span class="line">        author &#123;</span><br><span class="line">            firstName</span><br><span class="line">            lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 23 Jan 2021 13:35:24 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;bookById&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;book-1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Harry Potter and the Philosopher&#39;s Stone&quot;,</span><br><span class="line">      &quot;pageCount&quot;: 223,</span><br><span class="line">      &quot;author&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;Joanne&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;Rowling&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入依赖&quot;&gt;&lt;a href=&quot;#引入依赖&quot; class=&quot;headerlink&quot; title=&quot;引入依赖&quot;&gt;&lt;/a&gt;引入依赖&lt;/h2&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQl-Java(一)Schema</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/</id>
    <published>2021-01-19T02:13:53.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p><a href="https://github.com/graphql-java/graphql-java/releases">版本列表</a></p><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.graphql-java:graphql-java:15.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Schema——大纲"><a href="#Schema——大纲" class="headerlink" title="Schema——大纲"></a>Schema——大纲</h2><p>创建一个Schema有两种方式：</p><ol><li>推荐SDL(special graphql dsl): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Foo &#123;</span><br><span class="line">    bar: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>java code: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType fooType = newObject()</span><br><span class="line">    .name(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li></ol><h2 id="DataFetcher-and-TypeResolver"><a href="#DataFetcher-and-TypeResolver" class="headerlink" title="DataFetcher and TypeResolver"></a>DataFetcher and TypeResolver</h2><p><code>DataFetcher</code>用来向field提供数据，每一个<code>field</code>都包含一个DataFetcher,默认采用<code>PropertyDataFetcher</code>。</p><p><code>PropertyDataFetcher</code> 从<code>Map</code>或者<code>Java Bean</code>中获取数据，所以当field name与map的key，或者类的元素名称的相匹配，就不需要定义<code>DataFetcher</code>了。</p><p><code>TypeResolver</code>帮助<code>graphql-java</code>判断值的类型。</p><p>想象一下，你有一个接口MagicUserType，用来解析一系列java类Wizard,Witch和Necromancer。类型检查器负责检查一个运行时对象，并且判断用哪个<code>GraphqlObjectType</code>去响应这个对象，对应的应该用哪个<code>data fetchers</code>和field去运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TypeResolver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLObjectType <span class="title">getType</span><span class="params">(TypeResolutionEnvironment env)</span> </span>&#123;</span><br><span class="line">        Object javaObject = env.getObject();</span><br><span class="line">        <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Wizard) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WizardType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Witch) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WitchType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;NecromancerType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用SDL创建一个Schema"><a href="#用SDL创建一个Schema" class="headerlink" title="用SDL创建一个Schema"></a>用SDL创建一个Schema</h2><p>当通过schema创建一个SDL，你应该定义好<code>DataFetcher</code>和<code>TypeResolver</code>。</p><p>比如创建一个starWarsSchema.graphqls:</p><blockquote><p>这货是星战迷，日了，好多电影里自创的名词。幸亏前阵子看了《曼达洛人》，要不然都翻译不了这破官文。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query: QueryType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QueryType &#123;</span><br><span class="line">    hero(episode: Episode): Character &#x2F;&#x2F;英雄</span><br><span class="line">    human(id : String) : Human  &#x2F;&#x2F;人类</span><br><span class="line">    droid(id: ID!): Droid   &#x2F;&#x2F;德鲁伊</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BGM枚举</span><br><span class="line">enum Episode &#123;</span><br><span class="line">    NEWHOPE &#x2F;&#x2F;新希望军</span><br><span class="line">    EMPIRE  &#x2F;&#x2F;帝国军</span><br><span class="line">    JEDI    &#x2F;&#x2F;绝地武士</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色接口</span><br><span class="line">interface Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]! &#x2F;&#x2F;出现的时候播放对应的BGM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    homePlanet: String  &#x2F;&#x2F;母星</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    primaryFunction: String &#x2F;&#x2F;超能力</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个静态文件<code>starWarsSchema.graphqls</code>包含了field和type的定义，但是你还需要一个<code>runtimeWiring（运行时注入）</code>来把这个静态文件转换为一个可运行的schema。</p><p><code>runtimeWiring</code>必须包含<code>DataFetcher</code>、<code>TypeResolver</code>和自定义的<code>Scalar</code>。</p><p>你可以用下面的建造者模式+lambda表达式去创建报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">RuntimeWiring <span class="title">buildRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .scalar(CustomScalar)</span><br><span class="line">            <span class="comment">// this uses builder function lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;QueryType&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;hero&quot;</span>, <span class="keyword">new</span> StaticDataFetcher(StarWarsData.getArtoo()))</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;human&quot;</span>, StarWarsData.getHumanDataFetcher())</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;droid&quot;</span>, StarWarsData.getDroidDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            .type(<span class="string">&quot;Human&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// you can use builder syntax if you don&#x27;t like the lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;Droid&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// or full builder syntax if that takes your fancy</span></span><br><span class="line">            .type(</span><br><span class="line">                    newTypeWiring(<span class="string">&quot;Character&quot;</span>)</span><br><span class="line">                            .typeResolver(StarWarsData.getCharacterTypeResolver())</span><br><span class="line">                            .build()</span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，你可以把静态的大纲和注入结合到一起来创建一个可运行的schema：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line"></span><br><span class="line">File schemaFile = loadSchema(<span class="string">&quot;starWarsSchema.graphqls&quot;</span>);</span><br><span class="line"></span><br><span class="line">TypeDefinitionRegistry typeRegistry = schemaParser.parse(schemaFile);</span><br><span class="line">RuntimeWiring wiring = buildRuntimeWiring();</span><br><span class="line">GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, wiring);</span><br></pre></td></tr></table></figure><p>另外在建造者模式的基础上，<code>TypeResolver</code>和<code>DataFetcher</code>可以使用<code>WiringFactory</code>接口来注入。这会允许更多的动态运行时，通过schema的定义去判断应该注入什么东西。你可以通过阅读SDL来判断生成哪种runtime。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RuntimeWiring <span class="title">buildDynamicRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WiringFactory dynamicWiringFactory = <span class="keyword">new</span> WiringFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;dataFetcher&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive = getDirective(definition, <span class="string">&quot;dataFetcher&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createDataFetcher(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .wiringFactory(dynamicWiringFactory).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个schema定义"><a href="#创建一个schema定义" class="headerlink" title="创建一个schema定义"></a>创建一个schema定义</h2><p>当schema生成时，<code>DataFetcher</code>和<code>TypeResolver</code>可以在类型创建时提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher&lt;Foo&gt; fooDataFetcher = <span class="keyword">new</span> DataFetcher&lt;Foo&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// environment.getSource() is the value of the surrounding</span></span><br><span class="line">        <span class="comment">// object. In this case described by objectType</span></span><br><span class="line">        Foo value = perhapsFromDatabase(); <span class="comment">// Perhaps getting from a DB or whatever</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GraphQLObjectType objectType = newObject()</span><br><span class="line">        .name(<span class="string">&quot;ObjectType&quot;</span>)</span><br><span class="line">        .field(newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .type(GraphQLString)</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQLCodeRegistry codeRegistry = newCodeRegistry()</span><br><span class="line">        .dataFetcher(</span><br><span class="line">                coordinates(<span class="string">&quot;ObjectType&quot;</span>, <span class="string">&quot;foo&quot;</span>),</span><br><span class="line">                fooDataFetcher)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="GraphQl支持的类型"><a href="#GraphQl支持的类型" class="headerlink" title="GraphQl支持的类型"></a>GraphQl支持的类型</h2><ul><li>Scalar——标量</li><li>Object——对象</li><li>Interface——接口</li><li>Union——联合</li><li>InputObject——输入对象</li><li>Enum——枚举</li></ul><h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><p>graphql-java支持下面几种标量：</p><h4 id="标准标量："><a href="#标准标量：" class="headerlink" title="标准标量："></a>标准标量：</h4><ul><li>GraphQLString</li><li>GraphQLBoolean</li><li>GraphQLInt</li><li>GraphQLFloat</li><li>GraphQLID</li></ul><h4 id="扩展标量："><a href="#扩展标量：" class="headerlink" title="扩展标量："></a>扩展标量：</h4><ul><li>GraphQLLong</li><li>GraphQLShort</li><li>GraphQLByte</li><li>GraphQLFloat(怎么重复了？)</li><li>GraphQLBigDecimal</li><li>GraphQLBigInteger</li></ul><p>**注意：你的客户端可能不能理解扩展标量的语意，比如把Java中的long(最大值26^3-1)匹配给JavaScript的Number类型(最大值2^53 - 1)可能会出问题。</p><blockquote><p>这里用了两个may be，我觉得身为一个官文，这样写是不对的。会就是会，may be什么鬼。</p></blockquote><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Simpson应该是卡通片《辛普森一家》中的一类怪物</span><br><span class="line">type SimpsonCharacter &#123;</span><br><span class="line">    name: String</span><br><span class="line">    mainCharacter: Boolean &#x2F;&#x2F;是否是主角</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType simpsonCharacter = newObject()</span><br><span class="line">    .name(<span class="string">&quot;SimpsonCharacter&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;A Simpson character&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;The name of the character.&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;mainCharacter&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;One of the main Simpson characters?&quot;</span>)</span><br><span class="line">            .type(GraphQLBoolean))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Interfaces 是类型的抽象定义，哇塞！</p><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;滑稽角色</span><br><span class="line">interface ComicCharacter &#123;</span><br><span class="line">    name: String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GraphQLInterfaceType comicCharacter = newInterface()</span><br><span class="line">    .name(<span class="string">&quot;ComicCharacter&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;An abstract comic character.&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;The name of the character.&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Cat &#123;</span><br><span class="line">    name: String;</span><br><span class="line">    lives: Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog &#123;</span><br><span class="line">    name: String;</span><br><span class="line">    bonesOwned: int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union Pet &#x3D; Cat | Dog</span><br></pre></td></tr></table></figure><blockquote><p>我擦，《猫狗大战》</p></blockquote><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TypeResolver typeResolver = <span class="keyword">new</span> TypeResolver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLObjectType <span class="title">getType</span><span class="params">(TypeResolutionEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (env.getObject() <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">return</span> CatType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (env.getObject() <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="keyword">return</span> DogType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">GraphQLUnionType PetType = newUnionType()</span><br><span class="line">        .name(<span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .possibleType(CatType)</span><br><span class="line">        .possibleType(DogType)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQLCodeRegistry codeRegistry = newCodeRegistry()</span><br><span class="line">        .typeResolver(<span class="string">&quot;Pet&quot;</span>, typeResolver)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    RED</span><br><span class="line">    GREEN</span><br><span class="line">    BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GraphQLEnumType colorEnum = newEnum()</span><br><span class="line">    .name(<span class="string">&quot;Color&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;Supported colors.&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;RED&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;GREEN&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;BLUE&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="ObjectInputType"><a href="#ObjectInputType" class="headerlink" title="ObjectInputType"></a>ObjectInputType</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input Character &#123;</span><br><span class="line">    name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GraphQLInputObjectType inputObjectType = newInputObject()</span><br><span class="line">    .name(<span class="string">&quot;inputObjectType&quot;</span>)</span><br><span class="line">    .field(newInputObjectField()</span><br><span class="line">            .name(<span class="string">&quot;field&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="类型关系和递归"><a href="#类型关系和递归" class="headerlink" title="类型关系和递归"></a>类型关系和递归</h2><p>GraphQL支持递归（哇塞！）：比如一个<code>Person</code>类内部含有一个<code>List&lt;Friend&gt;</code>，我们可以声明一个类<code>graphql-java</code>并持有一个<code>GraphQLTypeReference</code>类型的属性。当schema创建时，<code>GraphQLTypeReference</code>会被实际的类型替换掉。(答不对题，文彩太差了)。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType person = newObject()</span><br><span class="line">    .name(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;friends&quot;</span>)</span><br><span class="line">            .type(GraphQLList</span><br><span class="line">            .list(GraphQLTypeReference.typeRef(<span class="string">&quot;Person&quot;</span>))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>当schema通过SDL创建时，不需要对递归类型做特殊处理，递归已经自动完成了。</p><blockquote><p>所以你就可以不给出个SDL的例子吗，作者？</p></blockquote><h2 id="Schema-SDL-的模块化"><a href="#Schema-SDL-的模块化" class="headerlink" title="Schema SDL 的模块化"></a>Schema SDL 的模块化</h2><p>一个巨大的schema文件是不方便浏览的（我想起了操哥写过的300行的函数和嵌套了7层的if）。我们可以通过两种技术使之<strong>模块化</strong>。</p><p>NO.1 在逻辑单元(java代码)中合并多个Schema SDL文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line"></span><br><span class="line">File schemaFile1 = loadSchema(<span class="string">&quot;starWarsSchemaPart1.graphqls&quot;</span>);</span><br><span class="line">File schemaFile2 = loadSchema(<span class="string">&quot;starWarsSchemaPart2.graphqls&quot;</span>);</span><br><span class="line">File schemaFile3 = loadSchema(<span class="string">&quot;starWarsSchemaPart3.graphqls&quot;</span>);</span><br><span class="line"></span><br><span class="line">TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> TypeDefinitionRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">// each registry is merged into the main registry</span></span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile1));</span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile2));</span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile3));</span><br><span class="line"></span><br><span class="line">GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, buildRuntimeWiring());</span><br></pre></td></tr></table></figure><p>NO.2 Graphql SDL的类型系统针对多模块具备了另一个构造函数，你可以使用<code>type extensions</code>去把额外的field和insterfaces添加到类型中。</p><p>想象你开始的时候写了这么个type：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Human &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一部分文件中可以通过extend这个type来添加更多的图形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extend type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以添加更多文件，它们最终会被整合到一起（不允许重复定义字段）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extend type Human &#123;</span><br><span class="line">    homePlanet: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终当所有type的继承者汇集到一起时，在运行时中type会变成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    homePlanet: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在顶级中很有用，你可以使用继承来向顶级的schema「query」中添加新的字段。团队开发中可以采用这种形式来向所有的query默认提供顶级query。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query: CombinedQueryFromMultipleTeams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    createdTimestamp: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># maybe the invoicing system team puts in this set of attributes</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    invoicing: Invoicing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># and the billing system team puts in this set of attributes</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    billing: Billing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># and so and so forth</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    auditing: Auditing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅支持-哇塞！"><a href="#订阅支持-哇塞！" class="headerlink" title="订阅支持(哇塞！)"></a>订阅支持(哇塞！)</h2><p>订阅允许你跑个query，并且持续监听这个query返回对象的变化。（这个牛逼了，但是有可能是靠长链接维持的，如果是的话开销就有点大了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subscription foo &#123;</span><br><span class="line">    # normal graphql query</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体请查看<a href="https://www.graphql-java.com/documentation/v16/subscriptions">Subscriptions</a>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>终于翻译完了，作者文彩比较渣，所以翻译的有点累。下一篇准备翻译这个<code>Subscription</code>，看看它的订阅到底是怎么回事。当然在此之前，需要对本篇翻译二次回顾，消化吸收。所以下一篇翻译不知道什么时候能搞出来了。</p><hr><p>翻译完之后的第一次校稿，发现单纯阅读这个Schema篇根本理解不了。原因是按照demo跑完入门代码后，并没有好好阅读理解逻辑，然后中间因为来活了，中断了学习和翻译，特么尴尬了。下一篇还是从quick start开始吧。</p>]]></content>
    
    
    <summary type="html">本文基于GraphQl-java:v1.6版本官方文档中文翻译。</summary>
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQl-Java(三)Execution</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%89)Execution/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%89)Execution/</id>
    <published>2021-01-19T02:13:53.000Z</published>
    <updated>2021-05-07T03:16:57.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h2><p>如果想要在schema里跑个查询，需要用对应的参数创建一个新的<code>GraphQL object</code>，然后执行<code>execute()</code>。该方法会返回一个<code>ExecutionResult</code>，它包含查询结果，或者一个错误列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphQLSchema schema = GraphQLSchema.newSchema()</span><br><span class="line">        .query(queryType)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQL graphQL = GraphQL.newGraphQL(schema)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ExecutionInput executionInput = ExecutionInput.newExecutionInput().query(<span class="string">&quot;query &#123; hero &#123; name &#125; &#125;&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ExecutionResult executionResult = graphQL.execute(executionInput);</span><br><span class="line"></span><br><span class="line">Object data = executionResult.getData();</span><br><span class="line">List&lt;GraphQLError&gt; errors = executionResult.getErrors();</span><br></pre></td></tr></table></figure><p>更多的列子在<a href="https://github.com/graphql-java/graphql-java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy">这里</a></p><h2 id="Data-Fetchers"><a href="#Data-Fetchers" class="headerlink" title="Data Fetchers"></a>Data Fetchers</h2><p>每一个field都对应着一个<code>graphql.schema.DataFetcher</code>，也被称作<strong>resolvers</strong>。</p><p>你可以用基于<code>graphql.schema.PropertyDataFetcher</code>去测试Java POJO对象提供的field。如果你没有为field指定一个<code>data fetcher</code>，那么默认会使用<code>graphql.schema.PropertyDataFetcher</code>。</p><p>然而，你需要通过自定义的data fetcher去获取域的顶层对象，这意味着你可能需要创建一个数据库，或者通过http调用其他服务获取。</p><p><code>graphql-java</code>并不关注如何获取对象，这些逻辑需要你自己去处理。</p><p>一个data fetcher可能像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher userDataFetcher = <span class="keyword">new</span> DataFetcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetchUserFromDatabase(environment.getArgument(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个<code>DataFetcher</code>实际上都包含在<code>graphql.schema.DataFetchingEnvironment</code>对象中，而<code>graphql.schema.DataFetchingEnvironment</code>对象同时包含了正在获取的字段、已提供给字段的参数、字段的父级对象、查询根对象或者查询上下文。</p><p>在上面的示例中，执行将等待数据提取程序返回后再继续。您可以通过向数据返回 CompletionStage 来异步执行 DataFetcher，本页面将对此进行更详细的解释。</p><h2 id="Exceptions-while-fetching-data"><a href="#Exceptions-while-fetching-data" class="headerlink" title="Exceptions while fetching data"></a>Exceptions while fetching data</h2><p>如果在数据读取器调用期间发生异常，那么默认情况下执行策略将生成 graphql。然后将其添加到结果的错误列表中。记住，graphql 允许带有错误的部分结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataFetcherExceptionHandler</span> <span class="keyword">implements</span> <span class="title">DataFetcherExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(DataFetcherExceptionHandlerParameters handlerParameters)</span> </span>&#123;</span><br><span class="line">        Throwable exception = handlerParameters.getException();</span><br><span class="line">        SourceLocation sourceLocation = handlerParameters.getField().getSourceLocation();</span><br><span class="line">        ExecutionPath path = handlerParameters.getPath();</span><br><span class="line"></span><br><span class="line">        ExceptionWhileDataFetching error = <span class="keyword">new</span> ExceptionWhileDataFetching(path, exception, sourceLocation);</span><br><span class="line">        handlerParameters.getExecutionContext().addError(error);</span><br><span class="line">        log.warn(error.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您抛出的异常本身是一个 GraphqlError，那么它将把消息和自定义扩展属性从该异常转移到 exceptionwhiledatatfetching 对象中。这允许您将自己的定制属性放置到发送回调用者的 graphql 错误中。</p><p>例如，假设您的数据读取器抛出此异常。Foo 和 fizz 属性将包含在结果 graphql 错误中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomRuntimeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> <span class="keyword">implements</span> <span class="title">GraphQLError</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; customAttributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        customAttributes.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        customAttributes.put(<span class="string">&quot;fizz&quot;</span>, <span class="string">&quot;whizz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customAttributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SourceLocation&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorType <span class="title">getErrorType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorType.DataFetchingException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>翻译到这里先停一下吧，单纯的翻译只是浪费时间。前段时间项目紧，没时间吃透这个graphql，所以现在想直接从个人网盘项目里面尝试一下。</p></blockquote>]]></content>
    
    
    <summary type="html">本文基于GraphQl-java:v1.6版本官方文档中文翻译。</summary>
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>对SpringGateway+Security+OAuth2.0的认识</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/</id>
    <published>2021-01-12T09:49:10.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<p>趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。</p><a id="more"></a><h2 id="OAuth2-0-四种授权模式"><a href="#OAuth2-0-四种授权模式" class="headerlink" title="OAuth2.0 四种授权模式"></a>OAuth2.0 四种授权模式</h2><table><thead><tr><th>模式</th><th>refresh_token</th><th>用途</th></tr></thead><tbody><tr><td>authorization_code</td><td>true</td><td>允许用户通过第三方应用登录自身获取资源，前提是用户已登录自身服务。</td></tr><tr><td>implicit</td><td>false</td><td>简化模式，跳过了获取授权码过程。</td></tr><tr><td>password</td><td>true</td><td>账号密码模式，用于高度授信场景，比如登录微信、QQ自身｜</td></tr><tr><td>client_credentials</td><td>false</td><td>客户端模式，用于高度授信的其他服务，如企业自己的其他服务，或高度加密的硬件客户端，登录过程完全不需要用户操作。</td></tr></tbody></table><h2 id="Security、ResourceServer、ClientServer各自的作用和关系"><a href="#Security、ResourceServer、ClientServer各自的作用和关系" class="headerlink" title="Security、ResourceServer、ClientServer各自的作用和关系"></a>Security、ResourceServer、ClientServer各自的作用和关系</h2><ul><li><p>SpringSecurity:鉴权方式的配置，比如哪些接口需要鉴权，还要排除调登录注册和登出接口等等。还有用户信息的存放、认证，Token Provider 的配置等等。</p></li><li><p>ResourceServer:是指需要收到保护的资源。比我的一个服务有大量接口，需要采用Security保护，那这个服务就是个ResourceServer。怎么保护呢？通过集成SpringSecurity来保护。每当有请求要访问我们的接口，ResourceServer都需要向token_provider验证token的有效性。</p></li><li><p>ClientServer:是用来在服务端获取access_token和refresh_token用的，并且可以自动使用refresh_token去刷新access_token。向谁获取？可以是微信、微博、github等等。</p></li><li><p>TokenProvider:用来提供token的服务。比如微信、支付宝、github,也可以是自己搭建的Keycloak服务。</p></li></ul><h2 id="网关统一用户认证"><a href="#网关统一用户认证" class="headerlink" title="网关统一用户认证"></a>网关统一用户认证</h2><p>很简单，说白了就是在Gateway集成Security，这样以来Gateway就成了一个ResourceServer，并且可以为所有路由做用户认证。</p><p>但是！<strong>具体的鉴权还是需要各个服务自己去做</strong>，毕竟网关不知道具体的服务需要具体哪一项权限。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="直接使用微信、支付宝的token来做自己的有效性验证可以码？"><a href="#直接使用微信、支付宝的token来做自己的有效性验证可以码？" class="headerlink" title="直接使用微信、支付宝的token来做自己的有效性验证可以码？"></a>直接使用微信、支付宝的token来做自己的有效性验证可以码？</h3><p>当然可以！只不过，人家的token验证只有在调用他们的服务时才会生效，如果不调用他们的服务，我们自己不知道人家的token是否有效（超时过期）。</p><p>那么该怎么实现？当我们自己的接口被访问时，先去调个人家的服务，最好是无关痛痒的服务，单纯为了验证人家的token是否有效。</p><p>但是这样以来就大大降低了接口的请求速度，而且也不优雅，平衡下来还不许自己搭建帐号体系来的实在！</p><h3 id="采用授权码方式让自己的客户端访问自己服务？"><a href="#采用授权码方式让自己的客户端访问自己服务？" class="headerlink" title="采用授权码方式让自己的客户端访问自己服务？"></a>采用授权码方式让自己的客户端访问自己服务？</h3><p>这就叫脱了裤子放屁，为安全而安全！</p><p>用微信的第三方登录举例，假如我们没有登录微信，当使用微信时，依然需要用帐号密码方式先登录微信。因为你在操作授权登录时，是先调起微信的页面或者它SDK的页面，是在人家的页面里面玩的，对于微信来讲，他自己的页面就是高度授信的，所以追本溯源，授权码登录方式还是基于帐号密码之上的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="spring" scheme="https://vee-zhang.github.io/Vee-blog/tags/spring/"/>
    
    <category term="cloud" scheme="https://vee-zhang.github.io/Vee-blog/tags/cloud/"/>
    
    <category term="security" scheme="https://vee-zhang.github.io/Vee-blog/tags/security/"/>
    
    <category term="oauth2.0" scheme="https://vee-zhang.github.io/Vee-blog/tags/oauth2-0/"/>
    
  </entry>
  
  <entry>
    <title>开篇第一章</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-01-07T08:30:36.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<p>这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建pub.dev私服及上传package</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</id>
    <published>2021-01-06T08:57:01.000Z</published>
    <updated>2021-05-07T03:16:57.852Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h2><p>首先到我的<a href="https://gitee.com/william198824/pub_server">码云</a>clone个项目下来,然后习惯性<code>flutter pub get</code>。</p><p>接下来修改配置，修改<code>pub_server/example/src/example.dart</code>文件,找到<code>argsParser()</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArgParser argsParser() &#123;</span><br><span class="line">  <span class="keyword">var</span> parser = ArgParser();</span><br><span class="line"></span><br><span class="line">  parser.addOption(<span class="string">&#x27;directory&#x27;</span>,</span><br><span class="line">      abbr: <span class="string">&#x27;d&#x27;</span>, defaultsTo: <span class="string">&#x27;pub_server-repository-data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//host地址</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;host&#x27;</span>, abbr: <span class="string">&#x27;h&#x27;</span>, defaultsTo: <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;port&#x27;</span>, abbr: <span class="string">&#x27;p&#x27;</span>, defaultsTo: <span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我的8080端口已经被jenkies占用了，所以只能把pub的端口改为9090。要注意的是，<strong>host默认是localhost，只支持本机访问</strong>，如果我们要挂到服务上，需要把这里改为<code>0.0.0.0</code>之后，我们才能通过ip或者域名访问服务。</p><p>然后启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart example/example.dart -d /tmp/package-db</span><br></pre></td></tr></table></figure><blockquote><p>如果出现「To make the pub client use this repository configure…」表示服务启动成功！</p></blockquote><h2 id="创建测试package"><a href="#创建测试package" class="headerlink" title="创建测试package"></a>创建测试package</h2><p>怎么创建，不说了，这里只贴出yaml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lk_dio</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">用于来康科技公司的网络请求层封装，包括平台、大脑的接口调用规则和token有效期验证及自动刷新机制。</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">William</span> <span class="string">&lt;自己的邮箱@enn.cn&gt;</span></span><br><span class="line"><span class="attr">homepage:</span> <span class="string">&#x27;http://项目主页地址.com&#x27;</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">&#x27;http://localhost:9090&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.7.0 &lt;3.0.0&quot;</span></span><br><span class="line">  <span class="attr">flutter:</span> <span class="string">&quot;&gt;=1.17.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter:</span></span><br></pre></td></tr></table></figure><p>配置好之后,可以在本地直接依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lk_dio:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">user/william/lk_dio</span></span><br></pre></td></tr></table></figure><p>当然也可以发布到我们的pub私服上，发布之前可以通过命令检查错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure><p>按照提示解决问题，然后发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure><p>出现如下信息表明发布成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   &#x27;-- helloworld.dart</span><br><span class="line">|-- pubspec.yaml</span><br><span class="line">&#x27;-- test</span><br><span class="line">    &#x27;-- helloworld_test.dart</span><br><span class="line"></span><br><span class="line">Looks great! Are you ready to upload your package (y/n)? y</span><br><span class="line">Uploading...</span><br><span class="line">Successfully uploaded package.</span><br></pre></td></tr></table></figure><p>但是如果不FQ，是一定不会成功的，你看到的将是如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br></pre></td></tr></table></figure><p>失败的原因就是需要google的认证，怎么办，fq? 有没有更好的办法？</p><h2 id="绕过google认证"><a href="#绕过google认证" class="headerlink" title="绕过google认证"></a>绕过google认证</h2><p>再clone<a href="https://gitee.com/william198824/pub">这个项目</a>之后<code>flutter pub get</code>，然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart --snapshot=mypub.dart.snapshot bin/pub.dart </span><br></pre></td></tr></table></figure><p>完事后会自动生成一个<code>mypub.dart.snapshot</code>。</p><p>复制之后放入${flutterSDK Path}/bin/cache/dart-sdk/bin/snapshots/ 目录下</p><p>用txt编辑器打开${flutterSDK Path}/bin/cache/dart-sdk/bin/pub文件，将倒数第三行的：<code>pub.dart.snapshot</code> 替换为 <code>mypub.dart.snapshot</code>,然后重新发布package就OK了。</p><h2 id="依赖自己的package"><a href="#依赖自己的package" class="headerlink" title="依赖自己的package"></a>依赖自己的package</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lk_dio:#这里要与之前一致</span></span><br><span class="line">  <span class="attr">hosted:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">lk_dio</span> <span class="comment">#这里要与之前一致</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://localhost:9090</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">^1.0.0</span></span><br></pre></td></tr></table></figure><p>添加了依赖之后，我<code>flutter pub get</code>，本机没问题，项目正常跑，万分激动，但是。。。</p><p>当我把server发布到公司服务器后，<strong>publish失败！</strong>经查，是运维没有开放9090端口，找过运维之后问题解决。</p><p>然后我再添加依赖，运行pub get，竟然卡住不动了，内心瞬间一万只草泥马德，上传可以下载就不行怪了！后来发现server的配置文件中有个配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><code>standalone</code>好像是独立部署的意思。</p><p>把这里的<code>defaultTo</code>的值改为<code>true</code>,重新部署、启动，再重新下载依赖pub get，等等足足71秒后竟然成功了！后来运维解释，之所以这么慢是因为从北京访问我们盐城的服务器，而且没有CDN加速。</p><h2 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h2><p><a href="https://www.jianshu.com/p/59f4778864f0">https://www.jianshu.com/p/59f4778864f0</a></p>]]></content>
    
    
    <summary type="html">事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！</summary>
    
    
    
    <category term="technology" scheme="https://vee-zhang.github.io/Vee-blog/categories/technology/"/>
    
    
    <category term="pub" scheme="https://vee-zhang.github.io/Vee-blog/tags/pub/"/>
    
    <category term="flutter" scheme="https://vee-zhang.github.io/Vee-blog/tags/flutter/"/>
    
    <category term="dart" scheme="https://vee-zhang.github.io/Vee-blog/tags/dart/"/>
    
  </entry>
  
</feed>
