<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vee&#39;s blog</title>
  
  <subtitle>make world better !</subtitle>
  <link href="https://vee-zhang.github.io/Vee-blog/atom.xml" rel="self"/>
  
  <link href="https://vee-zhang.github.io/Vee-blog/"/>
  <updated>2021-03-01T06:47:06.053Z</updated>
  <id>https://vee-zhang.github.io/Vee-blog/</id>
  
  <author>
    <name>Vee Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fragment在Activity中的生命周期</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-02-26T03:17:35.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/source/resource/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="生命周期"></p><p>ss</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onCreate: 前</span><br><span class="line">D: FirstActivity&#39;s super.onCreate: 后</span><br><span class="line">D: FirstActivity&#39;s setContentView: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onAttach: </span><br><span class="line">D: FirstFragment&#39;s onCreate: </span><br><span class="line">D: FirstFragment&#39;s onCreateView: </span><br><span class="line">D: FirstFragment&#39;s onViewCreated: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s setContentView: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onActivityCreated: </span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><p>fragment的<code>onAttach</code>，<code>onCreate</code>，<code>onCreateView</code>，<code>onViewCreated</code>是在Activity的<code>setContentView</code>中执行的。</p><p>想一下就知道，Activity的<code>setContentView</code>的目的是从xml中加载View，而我把fragment写在了xml里面。</p><blockquote><p>这里有个小插曲，事实证明，Activity的<code>super.onCreate</code>可以写在<code>setContentView</code>之后，但是xml中存在fragment时就会报错。</p></blockquote><p>fragment的<code>onActivityCreated</code>、<code>onStart</code>是在Activity的<code>super.onStart</code>方法中执行。</p><p>fragment的<code>onResume</code>是在activity的<code>super.onResume</code>之后执行。</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 前</span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 后</span><br><span class="line">D: SecondActivity&#39;s setContentView: 前</span><br><span class="line">D: SecondFragment&#39;s onAttach: </span><br><span class="line">D: SecondFragment&#39;s onCreate: </span><br><span class="line">D: SecondFragment&#39;s onCreateView: </span><br><span class="line">D: SecondFragment&#39;s onViewCreated: </span><br><span class="line">D: SecondActivity&#39;s setContentView: 后</span><br><span class="line">D: SecondActivity&#39;s super.onStart: 前</span><br><span class="line">D: SecondFragment&#39;s onActivityCreated: </span><br><span class="line">D: SecondFragment&#39;s onStart: </span><br><span class="line">D: SecondActivity&#39;s super.onStart: 后</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 前</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 后</span><br><span class="line">D: SecondFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><p>fragment的<code>onPause</code>是在Activity的<code>super.onPause</code>中执行。</p><p>当第二个含有fragment的Activity可见后，上一个Activity的生命周期才会继续。</p><p>然后上一个fragment的<code>onStop</code>在Activity的<code>onStop</code>中执行。</p><p><strong>注意</strong>，前一个Activity执行到<code>onPause</code>，然后第二个Activity生命周期完成后，前一个Activity才会执行<code>onStop</code>。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D: SecondActivity&#39;s super.onPause: 前</span><br><span class="line">D: SecondFragment&#39;s onPause: </span><br><span class="line">D: SecondActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onStop: 前</span><br><span class="line">D: SecondFragment&#39;s onStop: </span><br><span class="line">D: SecondActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: SecondFragment&#39;s onDestroyView: </span><br><span class="line">D: SecondFragment&#39;s onDestroy: </span><br><span class="line">D: SecondFragment&#39;s onDetach: </span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 后</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先执行第二个Activity的<code>onPause</code>。</p><p>再回调前一个Activity的<code>onRestart</code>。</p><p>fragment的<code>onStart</code>在Activity的<code>super.onStart</code>中执行。</p><p>fragment的<code>onResume</code>在Activity的<code>super.onResume</code>中执行。</p><p>fragment的<code>onStop</code>在Activity的<code>super.onStop</code>中执行。</p><p>fragment的<code>onDestroyView</code>、<code>onDestroy</code>、<code>onDetach</code>在Activity的<code>super.onDestroy</code>中执行。</p><p><strong>注意</strong>    fragment的<code>onResume</code>是在Activity的<code>onResume</code>之后执行的！！！</p><h2 id="退入后台"><a href="#退入后台" class="headerlink" title="退入后台"></a>退入后台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><h2 id="回到前台"><a href="#回到前台" class="headerlink" title="回到前台"></a>回到前台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: FirstFragment&#39;s onDestroyView: </span><br><span class="line">D: FirstFragment&#39;s onDestroy: </span><br><span class="line">D: FirstFragment&#39;s onDetach: </span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 后</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/source/resource/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.sv</summary>
      
    
    
    
    
    <category term="android,生命周期,fragment,activity" scheme="https://vee-zhang.github.io/Vee-blog/tags/android-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-fragment-activity/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL-Java(二)DataFetching</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E4%BA%8C)DataFetcher/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E4%BA%8C)DataFetcher/</id>
    <published>2021-01-23T14:28:28.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphQL如何获取数据"><a href="#GraphQL如何获取数据" class="headerlink" title="GraphQL如何获取数据"></a>GraphQL如何获取数据</h2><p>每个field都有一个<code>graphql.schema.DataFetcher与之对应</code>。</p><p>一些File会使用特定的data fetcher，这种DataFetcher知道怎么去访问数据库获取field的信息，然后大多数的dataFetcher则是简单的从内存中的object获取数据。在获取数据时，会参照field的名字and Plain Old Java Object (POJO) patterns to get the data.</p><p>所以可以像这样来声明一个type:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">    products(match : String) : [Product]   # a list of products</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Product &#123;</span><br><span class="line">    id : ID</span><br><span class="line">    name : String</span><br><span class="line">    description : String</span><br><span class="line">    cost : Float</span><br><span class="line">    tax : Float</span><br><span class="line">    launchDate(dateFormat : String &#x3D; &quot;dd, MMM, yyyy&#39;) : String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Query.products</code>这个field有一个data fetcher，用来获取从数据库中获取<code>Product</code>类型的fields集合。它带有一个<code>match</code>参数，可以过滤出我们想要的product：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher productsDataFetcher = <span class="keyword">new</span> DataFetcher&lt;List&lt;ProductDTO&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProductDTO&gt; <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        DatabaseSecurityCtx ctx = environment.getContext();</span><br><span class="line"></span><br><span class="line">        List&lt;ProductDTO&gt; products;</span><br><span class="line">        String match = environment.getArgument(<span class="string">&quot;match&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (match != <span class="keyword">null</span>) &#123;</span><br><span class="line">            products = fetchProductsFromDatabaseWithMatching(ctx, match);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            products = fetchAllProductsFromDatabase(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个<code>DataFetcher</code>相互之间传递着一个<code>graphql.schema.DataFetchingEnvironment</code>对象，这个对象包含正在获取的field、传递给field的参数arguments、和其他信息诸如field的类型，它父级的类型query root object或者query context object。</p><p>要注意的是，data fetcher的编码是基于context object作为一个安全程序来处理数据库的访问。这是一个基本技术来提供一个底层调用上下文。</p><p>当我们有一个<code>ProductDTO</code>的列表，我们不需要为每一个field都搞一个data fetcher。graphql-java 有一个聪明的<code>graphql.schema.PropertyDataFetcher</code>知道怎么去根据名称追踪POJO的结构。在本例中就是有个带有name的field，然后<code>graphql.schema.PropertyDataFetcher</code>将尝试通过POJO的<code>public String getName()</code>方法来获取数据。</p><p><code>graphql.schema.PropertyDataFetcher</code>是默认的DataFetcher。</p><p>你仍然可以在DTO的方法中使用<code>graphql.schema.PropertyDataFetcher</code>来访问。这允许你在数据发送出去之前先做修改。比如，我们有个<code>launchDate</code>字段携带者一个可选的<code>dateFormat</code>参数。我们可以在ProductDTO中写个逻辑做日期时间的格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ID id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> Double cost;</span><br><span class="line">    <span class="keyword">private</span> Double tax;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime launchDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLaunchDate</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        String dateFormat = environment.getArgument(<span class="string">&quot;dateFormat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> yodaTimeFormatter(launchDate,dateFormat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定制PropertyDataFetcher"><a href="#定制PropertyDataFetcher" class="headerlink" title="定制PropertyDataFetcher"></a>定制PropertyDataFetcher</h2><p>像之前讲的一样，<code>graphql.schema.PropertyDataFetcher</code>是默认的data fetcher，并且它在获取数据时使用标准结构。</p><p>它支持POJO和map。假设有个field叫<code>fieldX</code>，它将会寻找一个POJO也叫做<code>fieldX</code>，或者在Map中去找一个key也叫做<code>fieldX</code>。</p><p>然而，你在定义的schema与POJO有一点不通，比如<code>Product.description</code>对应着POJO中的<code>getDesc()</code>.</p><p>你可以在SDL中使用<code>@fetch</code>注解来做匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">directive @fetch(from : String!) on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type Product &#123;</span><br><span class="line">    id : ID</span><br><span class="line">    name : String</span><br><span class="line">    description : String @fetch(from:&quot;desc&quot;)</span><br><span class="line">    cost : Float</span><br><span class="line">    tax : Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将告诉<code>graphql.schema.PropertyDataFetcher</code>在获取数据时应该使用名为<code>desc</code>的属性来对应SDL中的<code>description</code>字段。</p><p>如果你不用SDL,而是喜欢手写代码，那么可以直接指定Data Fetcher:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GraphQLFieldDefinition descriptionField = GraphQLFieldDefinition.newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;description&quot;</span>)</span><br><span class="line">                .type(Scalars.GraphQLString)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        GraphQLCodeRegistry codeRegistry = GraphQLCodeRegistry.newCodeRegistry()</span><br><span class="line">                .dataFetcher(</span><br><span class="line">                        coordinates(<span class="string">&quot;ObjectType&quot;</span>, <span class="string">&quot;description&quot;</span>),</span><br><span class="line">                        PropertyDataFetcher.fetching(<span class="string">&quot;desc&quot;</span>))</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><h2 id="DataFetchingEnvironment中有意思的部分"><a href="#DataFetchingEnvironment中有意思的部分" class="headerlink" title="DataFetchingEnvironment中有意思的部分"></a>DataFetchingEnvironment中有意思的部分</h2><p>每一个data fetcher都传递了一个<code>graphql.schema.DataFetchingEnvironment</code>对象。它知道我们正在获取什么东西，并且知道提供了哪些参数。</p><ul><li><code>&lt;T&gt; T getSource()</code>-获取field的信息。这个对象就是父级获取到的结果，他一个内存中的DTO对象，并且通过POJO的getters获取到值。在复杂的场景中，你可以通过检查它来获取field的特定信息。当graphql的field tree执行后返回的每一个field的值，都会成为子级的<code>source</code>。</li><li><code>&lt;T&gt; T getRoot()</code>-用来查看graphql的查询query。在顶层级中，root和source是一样的。root object在查询期间是不会改变的，它可能为null，所以尽量不要用这玩意。</li><li><code>Map&lt;String, Object&gt; getArguments()</code>-用来获取field提供的参数。</li><li><code>&lt;T&gt; T getContext()</code>-当query第一次执行时，才会设置好context，并让其停留在query的生命周期上。所以context的生命周期与query一致。context可以是任何值，主要是data fetcher在获取数据时需要这玩意。所以只需要把它注入给data fetcher就行了，其他场景都用不到。（日了狗了，讲了这么长一串，最后特么没点鸟用）</li><li><code>ExecutionStepInfo getExecutionStepInfo()</code>-用来获取<code>ExecutionStepInfo</code>。当query执行后，<code>ExecutionStepInfo</code>存放了所有field的类型信息。</li><li><code>DataFetchingFieldSelectionSet getSelectionSet()</code>-用来获取选项集。所谓「选项集」就是当前执行中的field之后的哪些被「选中」的子filed们。这对于展望接下来将要执行的field的信息。（我感觉就像是音乐播放器在播放收藏的专辑一样，比如当前播放到了费玉清的《天之大》，那么我们就可以通过这个方法去查看《天之大》下面有哪些歌将要被播放了）。</li><li><code>ExecutionId getExecutionId()</code>-所有的查询都有一个unique id。可以把id作为log日志的tag，用来打印特定的query。</li></ul><h3 id="ExecutionStepInfo好玩的地方"><a href="#ExecutionStepInfo好玩的地方" class="headerlink" title="ExecutionStepInfo好玩的地方"></a>ExecutionStepInfo好玩的地方</h3><p>一个graphql query在执行时会生成一个call tree，就是「调用树」。<code>graphql.execution.ExecutionStepInfo.getParentTypeInfo</code>允许你向上导航，看到是什么类型的field被带到了当前的执行过程。</p><p>在整个执行期间，就形成了一个树形path，<code>graphql.execution.ExecutionStepInfo.getPath</code>方法可以返回这个树形path的描述。这在日志打印和调试query时比较有用。而且可以查看到非空类型的名称和折叠后的列表。</p><p>一句话总结就是，主要用于调试和排错。</p><h3 id="DataFetchingFieldSelectionSet有趣的地方"><a href="#DataFetchingFieldSelectionSet有趣的地方" class="headerlink" title="DataFetchingFieldSelectionSet有趣的地方"></a>DataFetchingFieldSelectionSet有趣的地方</h3><p>想象一下有个query就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    products &#123;</span><br><span class="line">        # the fields below represent the selection set</span><br><span class="line">        name</span><br><span class="line">        description</span><br><span class="line">        sellingLocations &#123;</span><br><span class="line">            state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Product</code>的所有子field，对于<code>Product</code>来讲就是<code>selection fields</code>。当我们想要知道哪些子级field正在被请求时非常有用。举例来讲，我们的POJO中可能有很多属性，数据库表中的字段也与之一一对应。但是我们跑个graphql查询时可能不需要返回全部的字段，我们只要我们需要的字段就行了，此时data fetcher去查数据库时也不需要查出所有的列，也是按需获取就行了。那怎么在代码里感知到我们具体请求的哪些字段呢？就是靠这个<code>DataFetchingFieldSelectionSet</code>。</p><p>比如上例中我们请求了<code>sellingLocations</code>字段，或者我们使用更高效的查询：同时查出<code>products</code>和<code>sellingLocations</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphQL如何获取数据&quot;&gt;&lt;a href=&quot;#GraphQL如何获取数据&quot; class=&quot;headerlink&quot; title=&quot;GraphQL如何获取数据&quot;&gt;&lt;/a&gt;GraphQL如何获取数据&lt;/h2&gt;&lt;p&gt;每个field都有一个&lt;code&gt;graphql.s</summary>
      
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL-Java(零)从SpringBoot服务端开始</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E9%9B%B6)%E5%85%A5%E9%97%A8/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/23/GraphQL-Java(%E9%9B%B6)%E5%85%A5%E9%97%A8/</id>
    <published>2021-01-23T08:38:19.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.graphql-java:graphql-java:14.1&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;com.graphql-java:graphql-java-spring-boot-starter-webmvc:1.0&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.guava:guava:26.0-jre&#x27;</span> <span class="comment">// NEW</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义Schema"><a href="#定义Schema" class="headerlink" title="定义Schema"></a>定义Schema</h2><p>在<code>src/main/resources</code>中创建<code>schema.graphqls</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  bookById(id: ID): Book </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Book &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">  pageCount: Int</span><br><span class="line">  author: Author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Author &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  firstName: String</span><br><span class="line">  lastName: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个顶级字段：<code>bookById</code>，它用来返回特定ID的book；</p><p>并且定义了一个Boo类，其中包含<code>id</code>,<code>name</code>,<code>pageCount</code>,<code>author</code>。<code>author</code>是另一个类型。</p><h2 id="解析Schema"><a href="#解析Schema" class="headerlink" title="解析Schema"></a>解析Schema</h2><p>在项目中创建一个<code>GraphQLProvider</code>类型的java文件，用来创建GraphQL实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GraphQL graphQL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQL <span class="title">graphQL</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> graphQL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用Guava Resources读取资源文件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = Resources.getResource(<span class="string">&quot;schema.graphqls&quot;</span>);</span><br><span class="line">        String sdl = Resources.toString(url, Charsets.UTF_8);</span><br><span class="line">        GraphQLSchema graphQLSchema = buildSchema(sdl);</span><br><span class="line">        <span class="keyword">this</span>.graphQL = GraphQL.newGraphQL(graphQLSchema).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(String sdl)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> we will create the schema here later </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过google的Guava <code>Resources</code>来读取Schema.graphql文件，并且通过<code>@Bean</code>注解把GraphQL实例暴露出去，GraphQL Java Spring adapter会使用这个GraphQL实例来把schema匹配到`/graphql’路径，以后通过这个路径调用所有接口。</p><p>接下来实现buildSchema方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">GraphQLDataFetchers graphQLDataFetchers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构建调用模型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sdl 从资源文件获取到的sdl语言内容</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(String sdl)</span> </span>&#123;</span><br><span class="line">    TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> SchemaParser().parse(sdl);</span><br><span class="line">    RuntimeWiring runtimeWiring = buildWiring();</span><br><span class="line">    SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line">    <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RuntimeWiring <span class="title">buildWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .type(newTypeWiring(<span class="string">&quot;Query&quot;</span>)</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;bookById&quot;</span>, graphQLDataFetchers.getBookByIdDataFetcher()))</span><br><span class="line">            .type(newTypeWiring(<span class="string">&quot;Book&quot;</span>)</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;author&quot;</span>, graphQLDataFetchers.getAuthorDataFetcher()))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TypeDefinitionRegistry</code> 是SDL转换成的java对象。<code>RuntimeWiring</code>才是真正的重点，主要作用是注册了两个<code>DataFetchers</code>：</p><ul><li>一个用来根据ID查book；</li><li>一个用来获取特定book的作者。</li></ul><p>仔细看代码会发现，在构建<code>RuntimeWiring</code>时用到的字符串参数，全都是我们在SDL中定义好的type，所以这里的作用是告诉GraphQL Adapter怎么去根据SDL拿对应的数据。</p><h2 id="DataFetchers"><a href="#DataFetchers" class="headerlink" title="DataFetchers"></a>DataFetchers</h2><p>DataFetcher是一个接口，用来根据SDL中的field来获取对应的数据，所以它内部只有一个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(DataFetchingEnvironment dataFetchingEnvironment)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，SDL中每一个field都对应一个<code>DataFetcher</code>，如果没有特别指定一个<code>DataFetcher</code>，默认会采用<code>PropertyDataFetcher</code>。所以在上面生成<code>RuntimeWiring</code>的代码中，并没有对author注册dataFetcher，而是让他直接采用了默认的<code>PropertyDataFetcher</code>。</p><p>接下来我们就来实现<code>DataFetcher</code>了，创建一个<code>GraphQLDataFetchers</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLDataFetchers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; books = Arrays.asList(</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;223&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-1&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Moby Dick&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;635&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-2&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;book-3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Interview with the vampire&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;pageCount&quot;</span>, <span class="string">&quot;371&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;authorId&quot;</span>, <span class="string">&quot;author-3&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Map&lt;String, String&gt;&gt; authors = Arrays.asList(</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Joanne&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Rowling&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Herman&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Melville&quot;</span>),</span><br><span class="line">            ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;author-3&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Anne&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Rice&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getBookByIdDataFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataFetchingEnvironment -&gt; &#123;</span><br><span class="line">            String bookId = dataFetchingEnvironment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> books</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(book -&gt; book.get(<span class="string">&quot;id&quot;</span>).equals(bookId))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getAuthorDataFetcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataFetchingEnvironment -&gt; &#123;</span><br><span class="line">            Map&lt;String,String&gt; book = dataFetchingEnvironment.getSource();</span><br><span class="line">            String authorId = book.get(<span class="string">&quot;authorId&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> authors</span><br><span class="line">                    .stream()</span><br><span class="line">                    .filter(author -&gt; author.get(<span class="string">&quot;id&quot;</span>).equals(authorId))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .orElse(<span class="keyword">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全都是mock数据，亮点是采用了java的新特性，通过流式调用来处理集合，并且还有lamda表达式的书写。</p><p>上面的代码中，我们可以看到，<code>DataFetcher</code>是<code>DataFetchingEnvironment</code>，三个查询方法也都是返回<code>DataFetchingEnvironment</code>的实例，其中需要关注的是：</p><ul><li><code>getArgument(&quot;id&quot;)</code>用来获取参数。</li><li><code>getSource()</code>用来获取对象。</li></ul><p>根据我们在SDL中的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  bookById(id: ID): Book </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询book时需要传递一个id，所以这个id怎么获取呢？通过<code>dataFetchingEnvironment.getArgument(&quot;id&quot;)</code>就能获取到。</p><p>然后根据SDL中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Book &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String</span><br><span class="line">  pageCount: Int</span><br><span class="line">  author: Author</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询特定book的作者，那么需要一个特定的book实例，通过<code>getSource()</code>可以获取到父级的book实例。</p><p>在GraphQL中，<strong>每一个field的DataFetcher是从上到下，从父到子被调用的，并且父级的结果可以从子级的<code>DataFetcherEnvironment</code>的<code>getSource()</code>方法中取到</strong>。</p><h3 id="Default-DataFetchers"><a href="#Default-DataFetchers" class="headerlink" title="Default DataFetchers"></a>Default DataFetchers</h3><p>前面说过，如果不给field指定一个DataFetcher，那么将默认使用<code>PropertyDataFetcher</code>。在这个demo里，意味着<code>Book.id</code>, <code>Book.name</code>, <code>Book.pageCount</code>, <code>Author.id</code>, <code>Author.firstName</code>, <code>Author.lastName</code>都对应着一个<code>PropertyDataFetcher</code>。</p><p><code>PropertyDataFetcher</code>会通过多种方式从Java对象中找到对应的属性，如果是<code>java.util.Map</code>，就通过Key去找。这里要求field的名字与key一致。如果不一致就会返回null。（这里我翻译的不太对味，但是意思还是很明确的）。</p><h2 id="Try-API"><a href="#Try-API" class="headerlink" title="Try API"></a>Try API</h2><p>直接rest_client了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;localhost:9000&#x2F;graphql</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">X-REQUEST-TYPE: GraphQL</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    bookById(id:&quot;book-1&quot;)&#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        pageCount</span><br><span class="line">        author &#123;</span><br><span class="line">            firstName</span><br><span class="line">            lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 23 Jan 2021 13:35:24 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;bookById&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;book-1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Harry Potter and the Philosopher&#39;s Stone&quot;,</span><br><span class="line">      &quot;pageCount&quot;: 223,</span><br><span class="line">      &quot;author&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;Joanne&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;Rowling&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入依赖&quot;&gt;&lt;a href=&quot;#引入依赖&quot; class=&quot;headerlink&quot; title=&quot;引入依赖&quot;&gt;&lt;/a&gt;引入依赖&lt;/h2&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQl-Java(一)Schema</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%80)Schema/</id>
    <published>2021-01-19T02:13:53.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p><a href="https://github.com/graphql-java/graphql-java/releases">版本列表</a></p><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.graphql-java:graphql-java:15.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Schema——大纲"><a href="#Schema——大纲" class="headerlink" title="Schema——大纲"></a>Schema——大纲</h2><p>创建一个Schema有两种方式：</p><ol><li>推荐SDL(special graphql dsl): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Foo &#123;</span><br><span class="line">    bar: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>java code: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType fooType = newObject()</span><br><span class="line">    .name(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li></ol><h2 id="DataFetcher-and-TypeResolver"><a href="#DataFetcher-and-TypeResolver" class="headerlink" title="DataFetcher and TypeResolver"></a>DataFetcher and TypeResolver</h2><p><code>DataFetcher</code>用来向field提供数据，每一个<code>field</code>都包含一个DataFetcher,默认采用<code>PropertyDataFetcher</code>。</p><p><code>PropertyDataFetcher</code> 从<code>Map</code>或者<code>Java Bean</code>中获取数据，所以当field name与map的key，或者类的元素名称的相匹配，就不需要定义<code>DataFetcher</code>了。</p><p><code>TypeResolver</code>帮助<code>graphql-java</code>判断值的类型。</p><p>想象一下，你有一个接口MagicUserType，用来解析一系列java类Wizard,Witch和Necromancer。类型检查器负责检查一个运行时对象，并且判断用哪个<code>GraphqlObjectType</code>去响应这个对象，对应的应该用哪个<code>data fetchers</code>和field去运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TypeResolver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLObjectType <span class="title">getType</span><span class="params">(TypeResolutionEnvironment env)</span> </span>&#123;</span><br><span class="line">        Object javaObject = env.getObject();</span><br><span class="line">        <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Wizard) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WizardType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Witch) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;WitchType&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;NecromancerType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用SDL创建一个Schema"><a href="#用SDL创建一个Schema" class="headerlink" title="用SDL创建一个Schema"></a>用SDL创建一个Schema</h2><p>当通过schema创建一个SDL，你应该定义好<code>DataFetcher</code>和<code>TypeResolver</code>。</p><p>比如创建一个starWarsSchema.graphqls:</p><blockquote><p>这货是星战迷，日了，好多电影里自创的名词。幸亏前阵子看了《曼达洛人》，要不然都翻译不了这破官文。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query: QueryType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QueryType &#123;</span><br><span class="line">    hero(episode: Episode): Character &#x2F;&#x2F;英雄</span><br><span class="line">    human(id : String) : Human  &#x2F;&#x2F;人类</span><br><span class="line">    droid(id: ID!): Droid   &#x2F;&#x2F;德鲁伊</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BGM枚举</span><br><span class="line">enum Episode &#123;</span><br><span class="line">    NEWHOPE &#x2F;&#x2F;新希望军</span><br><span class="line">    EMPIRE  &#x2F;&#x2F;帝国军</span><br><span class="line">    JEDI    &#x2F;&#x2F;绝地武士</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色接口</span><br><span class="line">interface Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]! &#x2F;&#x2F;出现的时候播放对应的BGM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    homePlanet: String  &#x2F;&#x2F;母星</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    primaryFunction: String &#x2F;&#x2F;超能力</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个静态文件<code>starWarsSchema.graphqls</code>包含了field和type的定义，但是你还需要一个<code>runtimeWiring（运行时注入）</code>来把这个静态文件转换为一个可运行的schema。</p><p><code>runtimeWiring</code>必须包含<code>DataFetcher</code>、<code>TypeResolver</code>和自定义的<code>Scalar</code>。</p><p>你可以用下面的建造者模式+lambda表达式去创建报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">RuntimeWiring <span class="title">buildRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .scalar(CustomScalar)</span><br><span class="line">            <span class="comment">// this uses builder function lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;QueryType&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;hero&quot;</span>, <span class="keyword">new</span> StaticDataFetcher(StarWarsData.getArtoo()))</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;human&quot;</span>, StarWarsData.getHumanDataFetcher())</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;droid&quot;</span>, StarWarsData.getDroidDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            .type(<span class="string">&quot;Human&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// you can use builder syntax if you don&#x27;t like the lambda syntax</span></span><br><span class="line">            .type(<span class="string">&quot;Droid&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                    .dataFetcher(<span class="string">&quot;friends&quot;</span>, StarWarsData.getFriendsDataFetcher())</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// or full builder syntax if that takes your fancy</span></span><br><span class="line">            .type(</span><br><span class="line">                    newTypeWiring(<span class="string">&quot;Character&quot;</span>)</span><br><span class="line">                            .typeResolver(StarWarsData.getCharacterTypeResolver())</span><br><span class="line">                            .build()</span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，你可以把静态的大纲和注入结合到一起来创建一个可运行的schema：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line"></span><br><span class="line">File schemaFile = loadSchema(<span class="string">&quot;starWarsSchema.graphqls&quot;</span>);</span><br><span class="line"></span><br><span class="line">TypeDefinitionRegistry typeRegistry = schemaParser.parse(schemaFile);</span><br><span class="line">RuntimeWiring wiring = buildRuntimeWiring();</span><br><span class="line">GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, wiring);</span><br></pre></td></tr></table></figure><p>另外在建造者模式的基础上，<code>TypeResolver</code>和<code>DataFetcher</code>可以使用<code>WiringFactory</code>接口来注入。这会允许更多的动态运行时，通过schema的定义去判断应该注入什么东西。你可以通过阅读SDL来判断生成哪种runtime。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RuntimeWiring <span class="title">buildDynamicRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WiringFactory dynamicWiringFactory = <span class="keyword">new</span> WiringFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, InterfaceTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TypeResolver <span class="title">getTypeResolver</span><span class="params">(TypeDefinitionRegistry registry, UnionTypeDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive  = getDirective(definition,<span class="string">&quot;specialMarker&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createTypeResolver(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">providesDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getDirective(definition,<span class="string">&quot;dataFetcher&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataFetcher <span class="title">getDataFetcher</span><span class="params">(TypeDefinitionRegistry registry, FieldDefinition definition)</span> </span>&#123;</span><br><span class="line">            Directive directive = getDirective(definition, <span class="string">&quot;dataFetcher&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> createDataFetcher(definition,directive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">            .wiringFactory(dynamicWiringFactory).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个schema定义"><a href="#创建一个schema定义" class="headerlink" title="创建一个schema定义"></a>创建一个schema定义</h2><p>当schema生成时，<code>DataFetcher</code>和<code>TypeResolver</code>可以在类型创建时提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher&lt;Foo&gt; fooDataFetcher = <span class="keyword">new</span> DataFetcher&lt;Foo&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// environment.getSource() is the value of the surrounding</span></span><br><span class="line">        <span class="comment">// object. In this case described by objectType</span></span><br><span class="line">        Foo value = perhapsFromDatabase(); <span class="comment">// Perhaps getting from a DB or whatever</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GraphQLObjectType objectType = newObject()</span><br><span class="line">        .name(<span class="string">&quot;ObjectType&quot;</span>)</span><br><span class="line">        .field(newFieldDefinition()</span><br><span class="line">                .name(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">                .type(GraphQLString)</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQLCodeRegistry codeRegistry = newCodeRegistry()</span><br><span class="line">        .dataFetcher(</span><br><span class="line">                coordinates(<span class="string">&quot;ObjectType&quot;</span>, <span class="string">&quot;foo&quot;</span>),</span><br><span class="line">                fooDataFetcher)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="GraphQl支持的类型"><a href="#GraphQl支持的类型" class="headerlink" title="GraphQl支持的类型"></a>GraphQl支持的类型</h2><ul><li>Scalar——标量</li><li>Object——对象</li><li>Interface——接口</li><li>Union——联合</li><li>InputObject——输入对象</li><li>Enum——枚举</li></ul><h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><p>graphql-java支持下面几种标量：</p><h4 id="标准标量："><a href="#标准标量：" class="headerlink" title="标准标量："></a>标准标量：</h4><ul><li>GraphQLString</li><li>GraphQLBoolean</li><li>GraphQLInt</li><li>GraphQLFloat</li><li>GraphQLID</li></ul><h4 id="扩展标量："><a href="#扩展标量：" class="headerlink" title="扩展标量："></a>扩展标量：</h4><ul><li>GraphQLLong</li><li>GraphQLShort</li><li>GraphQLByte</li><li>GraphQLFloat(怎么重复了？)</li><li>GraphQLBigDecimal</li><li>GraphQLBigInteger</li></ul><p>**注意：你的客户端可能不能理解扩展标量的语意，比如把Java中的long(最大值26^3-1)匹配给JavaScript的Number类型(最大值2^53 - 1)可能会出问题。</p><blockquote><p>这里用了两个may be，我觉得身为一个官文，这样写是不对的。会就是会，may be什么鬼。</p></blockquote><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Simpson应该是卡通片《辛普森一家》中的一类怪物</span><br><span class="line">type SimpsonCharacter &#123;</span><br><span class="line">    name: String</span><br><span class="line">    mainCharacter: Boolean &#x2F;&#x2F;是否是主角</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType simpsonCharacter = newObject()</span><br><span class="line">    .name(<span class="string">&quot;SimpsonCharacter&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;A Simpson character&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;The name of the character.&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;mainCharacter&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;One of the main Simpson characters?&quot;</span>)</span><br><span class="line">            .type(GraphQLBoolean))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>Interfaces 是类型的抽象定义，哇塞！</p><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;滑稽角色</span><br><span class="line">interface ComicCharacter &#123;</span><br><span class="line">    name: String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GraphQLInterfaceType comicCharacter = newInterface()</span><br><span class="line">    .name(<span class="string">&quot;ComicCharacter&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;An abstract comic character.&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;The name of the character.&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Cat &#123;</span><br><span class="line">    name: String;</span><br><span class="line">    lives: Int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Dog &#123;</span><br><span class="line">    name: String;</span><br><span class="line">    bonesOwned: int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">union Pet &#x3D; Cat | Dog</span><br></pre></td></tr></table></figure><blockquote><p>我擦，《猫狗大战》</p></blockquote><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TypeResolver typeResolver = <span class="keyword">new</span> TypeResolver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLObjectType <span class="title">getType</span><span class="params">(TypeResolutionEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (env.getObject() <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">return</span> CatType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (env.getObject() <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="keyword">return</span> DogType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">GraphQLUnionType PetType = newUnionType()</span><br><span class="line">        .name(<span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .possibleType(CatType)</span><br><span class="line">        .possibleType(DogType)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQLCodeRegistry codeRegistry = newCodeRegistry()</span><br><span class="line">        .typeResolver(<span class="string">&quot;Pet&quot;</span>, typeResolver)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    RED</span><br><span class="line">    GREEN</span><br><span class="line">    BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GraphQLEnumType colorEnum = newEnum()</span><br><span class="line">    .name(<span class="string">&quot;Color&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;Supported colors.&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;RED&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;GREEN&quot;</span>)</span><br><span class="line">    .value(<span class="string">&quot;BLUE&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h3 id="ObjectInputType"><a href="#ObjectInputType" class="headerlink" title="ObjectInputType"></a>ObjectInputType</h3><p>SDL Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input Character &#123;</span><br><span class="line">    name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GraphQLInputObjectType inputObjectType = newInputObject()</span><br><span class="line">    .name(<span class="string">&quot;inputObjectType&quot;</span>)</span><br><span class="line">    .field(newInputObjectField()</span><br><span class="line">            .name(<span class="string">&quot;field&quot;</span>)</span><br><span class="line">            .type(GraphQLString))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="类型关系和递归"><a href="#类型关系和递归" class="headerlink" title="类型关系和递归"></a>类型关系和递归</h2><p>GraphQL支持递归（哇塞！）：比如一个<code>Person</code>类内部含有一个<code>List&lt;Friend&gt;</code>，我们可以声明一个类<code>graphql-java</code>并持有一个<code>GraphQLTypeReference</code>类型的属性。当schema创建时，<code>GraphQLTypeReference</code>会被实际的类型替换掉。(答不对题，文彩太差了)。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GraphQLObjectType person = newObject()</span><br><span class="line">    .name(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line">    .field(newFieldDefinition()</span><br><span class="line">            .name(<span class="string">&quot;friends&quot;</span>)</span><br><span class="line">            .type(GraphQLList</span><br><span class="line">            .list(GraphQLTypeReference.typeRef(<span class="string">&quot;Person&quot;</span>))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>当schema通过SDL创建时，不需要对递归类型做特殊处理，递归已经自动完成了。</p><blockquote><p>所以你就可以不给出个SDL的例子吗，作者？</p></blockquote><h2 id="Schema-SDL-的模块化"><a href="#Schema-SDL-的模块化" class="headerlink" title="Schema SDL 的模块化"></a>Schema SDL 的模块化</h2><p>一个巨大的schema文件是不方便浏览的（我想起了操哥写过的300行的函数和嵌套了7层的if）。我们可以通过两种技术使之<strong>模块化</strong>。</p><p>NO.1 在逻辑单元(java代码)中合并多个Schema SDL文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line"></span><br><span class="line">File schemaFile1 = loadSchema(<span class="string">&quot;starWarsSchemaPart1.graphqls&quot;</span>);</span><br><span class="line">File schemaFile2 = loadSchema(<span class="string">&quot;starWarsSchemaPart2.graphqls&quot;</span>);</span><br><span class="line">File schemaFile3 = loadSchema(<span class="string">&quot;starWarsSchemaPart3.graphqls&quot;</span>);</span><br><span class="line"></span><br><span class="line">TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> TypeDefinitionRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">// each registry is merged into the main registry</span></span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile1));</span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile2));</span><br><span class="line">typeRegistry.merge(schemaParser.parse(schemaFile3));</span><br><span class="line"></span><br><span class="line">GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeRegistry, buildRuntimeWiring());</span><br></pre></td></tr></table></figure><p>NO.2 Graphql SDL的类型系统针对多模块具备了另一个构造函数，你可以使用<code>type extensions</code>去把额外的field和insterfaces添加到类型中。</p><p>想象你开始的时候写了这么个type：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Human &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在另一部分文件中可以通过extend这个type来添加更多的图形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extend type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以添加更多文件，它们最终会被整合到一起（不允许重复定义字段）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extend type Human &#123;</span><br><span class="line">    homePlanet: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终当所有type的继承者汇集到一起时，在运行时中type会变成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    friends: [Character]</span><br><span class="line">    appearsIn: [Episode]!</span><br><span class="line">    homePlanet: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在顶级中很有用，你可以使用继承来向顶级的schema「query」中添加新的字段。团队开发中可以采用这种形式来向所有的query默认提供顶级query。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">    query: CombinedQueryFromMultipleTeams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    createdTimestamp: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># maybe the invoicing system team puts in this set of attributes</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    invoicing: Invoicing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># and the billing system team puts in this set of attributes</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    billing: Billing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># and so and so forth</span><br><span class="line">extend type CombinedQueryFromMultipleTeams &#123;</span><br><span class="line">    auditing: Auditing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="订阅支持-哇塞！"><a href="#订阅支持-哇塞！" class="headerlink" title="订阅支持(哇塞！)"></a>订阅支持(哇塞！)</h2><p>订阅允许你跑个query，并且持续监听这个query返回对象的变化。（这个牛逼了，但是有可能是靠长链接维持的，如果是的话开销就有点大了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subscription foo &#123;</span><br><span class="line">    # normal graphql query</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体请查看<a href="https://www.graphql-java.com/documentation/v16/subscriptions">Subscriptions</a>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>终于翻译完了，作者文彩比较渣，所以翻译的有点累。下一篇准备翻译这个<code>Subscription</code>，看看它的订阅到底是怎么回事。当然在此之前，需要对本篇翻译二次回顾，消化吸收。所以下一篇翻译不知道什么时候能搞出来了。</p><hr><p>翻译完之后的第一次校稿，发现单纯阅读这个Schema篇根本理解不了。原因是按照demo跑完入门代码后，并没有好好阅读理解逻辑，然后中间因为来活了，中断了学习和翻译，特么尴尬了。下一篇还是从quick start开始吧。</p>]]></content>
    
    
    <summary type="html">本文基于GraphQl-java:v1.6版本官方文档中文翻译。</summary>
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQl-Java(三)Execution</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%89)Execution/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/19/GraphQl-Java(%E4%B8%89)Execution/</id>
    <published>2021-01-19T02:13:53.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h2><p>如果想要在schema里跑个查询，需要用对应的参数创建一个新的<code>GraphQL object</code>，然后执行<code>execute()</code>。该方法会返回一个<code>ExecutionResult</code>，它包含查询结果，或者一个错误列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphQLSchema schema = GraphQLSchema.newSchema()</span><br><span class="line">        .query(queryType)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">GraphQL graphQL = GraphQL.newGraphQL(schema)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ExecutionInput executionInput = ExecutionInput.newExecutionInput().query(<span class="string">&quot;query &#123; hero &#123; name &#125; &#125;&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ExecutionResult executionResult = graphQL.execute(executionInput);</span><br><span class="line"></span><br><span class="line">Object data = executionResult.getData();</span><br><span class="line">List&lt;GraphQLError&gt; errors = executionResult.getErrors();</span><br></pre></td></tr></table></figure><p>更多的列子在<a href="https://github.com/graphql-java/graphql-java/blob/master/src/test/groovy/graphql/StarWarsQueryTest.groovy">这里</a></p><h2 id="Data-Fetchers"><a href="#Data-Fetchers" class="headerlink" title="Data Fetchers"></a>Data Fetchers</h2><p>每一个field都对应着一个<code>graphql.schema.DataFetcher</code>，也被称作<strong>resolvers</strong>。</p><p>你可以用基于<code>graphql.schema.PropertyDataFetcher</code>去测试Java POJO对象提供的field。如果你没有为field指定一个<code>data fetcher</code>，那么默认会使用<code>graphql.schema.PropertyDataFetcher</code>。</p><p>然而，你需要通过自定义的data fetcher去获取域的顶层对象，这意味着你可能需要创建一个数据库，或者通过http调用其他服务获取。</p><p><code>graphql-java</code>并不关注如何获取对象，这些逻辑需要你自己去处理。</p><p>一个data fetcher可能像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataFetcher userDataFetcher = <span class="keyword">new</span> DataFetcher() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fetchUserFromDatabase(environment.getArgument(<span class="string">&quot;userId&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个<code>DataFetcher</code>实际上都包含在<code>graphql.schema.DataFetchingEnvironment</code>对象中，而<code>graphql.schema.DataFetchingEnvironment</code>对象同时包含了正在获取的字段、已提供给字段的参数、字段的父级对象、查询根对象或者查询上下文。</p><p>在上面的示例中，执行将等待数据提取程序返回后再继续。您可以通过向数据返回 CompletionStage 来异步执行 DataFetcher，本页面将对此进行更详细的解释。</p><h2 id="Exceptions-while-fetching-data"><a href="#Exceptions-while-fetching-data" class="headerlink" title="Exceptions while fetching data"></a>Exceptions while fetching data</h2><p>如果在数据读取器调用期间发生异常，那么默认情况下执行策略将生成 graphql。然后将其添加到结果的错误列表中。记住，graphql 允许带有错误的部分结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataFetcherExceptionHandler</span> <span class="keyword">implements</span> <span class="title">DataFetcherExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(DataFetcherExceptionHandlerParameters handlerParameters)</span> </span>&#123;</span><br><span class="line">        Throwable exception = handlerParameters.getException();</span><br><span class="line">        SourceLocation sourceLocation = handlerParameters.getField().getSourceLocation();</span><br><span class="line">        ExecutionPath path = handlerParameters.getPath();</span><br><span class="line"></span><br><span class="line">        ExceptionWhileDataFetching error = <span class="keyword">new</span> ExceptionWhileDataFetching(path, exception, sourceLocation);</span><br><span class="line">        handlerParameters.getExecutionContext().addError(error);</span><br><span class="line">        log.warn(error.getMessage(), exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您抛出的异常本身是一个 GraphqlError，那么它将把消息和自定义扩展属性从该异常转移到 exceptionwhiledatatfetching 对象中。这允许您将自己的定制属性放置到发送回调用者的 graphql 错误中。</p><p>例如，假设您的数据读取器抛出此异常。Foo 和 fizz 属性将包含在结果 graphql 错误中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomRuntimeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> <span class="keyword">implements</span> <span class="title">GraphQLError</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; customAttributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        customAttributes.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        customAttributes.put(<span class="string">&quot;fizz&quot;</span>, <span class="string">&quot;whizz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> customAttributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SourceLocation&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorType <span class="title">getErrorType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorType.DataFetchingException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>翻译到这里先停一下吧，单纯的翻译只是浪费时间。前段时间项目紧，没时间吃透这个graphql，所以现在想直接从个人网盘项目里面尝试一下。</p></blockquote>]]></content>
    
    
    <summary type="html">本文基于GraphQl-java:v1.6版本官方文档中文翻译。</summary>
    
    
    
    
    <category term="GraphQL" scheme="https://vee-zhang.github.io/Vee-blog/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>对SpringGateway+Security+OAuth2.0的认识</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/12/%E5%AF%B9SpringGateway-Security-OAuth2-0%E7%9A%84%E8%AE%A4%E8%AF%86/</id>
    <published>2021-01-12T09:49:10.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<p>趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。</p><a id="more"></a><h2 id="OAuth2-0-四种授权模式"><a href="#OAuth2-0-四种授权模式" class="headerlink" title="OAuth2.0 四种授权模式"></a>OAuth2.0 四种授权模式</h2><table><thead><tr><th>模式</th><th>refresh_token</th><th>用途</th></tr></thead><tbody><tr><td>authorization_code</td><td>true</td><td>允许用户通过第三方应用登录自身获取资源，前提是用户已登录自身服务。</td></tr><tr><td>implicit</td><td>false</td><td>简化模式，跳过了获取授权码过程。</td></tr><tr><td>password</td><td>true</td><td>账号密码模式，用于高度授信场景，比如登录微信、QQ自身｜</td></tr><tr><td>client_credentials</td><td>false</td><td>客户端模式，用于高度授信的其他服务，如企业自己的其他服务，或高度加密的硬件客户端，登录过程完全不需要用户操作。</td></tr></tbody></table><h2 id="Security、ResourceServer、ClientServer各自的作用和关系"><a href="#Security、ResourceServer、ClientServer各自的作用和关系" class="headerlink" title="Security、ResourceServer、ClientServer各自的作用和关系"></a>Security、ResourceServer、ClientServer各自的作用和关系</h2><ul><li><p>SpringSecurity:鉴权方式的配置，比如哪些接口需要鉴权，还要排除调登录注册和登出接口等等。还有用户信息的存放、认证，Token Provider 的配置等等。</p></li><li><p>ResourceServer:是指需要收到保护的资源。比我的一个服务有大量接口，需要采用Security保护，那这个服务就是个ResourceServer。怎么保护呢？通过集成SpringSecurity来保护。每当有请求要访问我们的接口，ResourceServer都需要向token_provider验证token的有效性。</p></li><li><p>ClientServer:是用来在服务端获取access_token和refresh_token用的，并且可以自动使用refresh_token去刷新access_token。向谁获取？可以是微信、微博、github等等。</p></li><li><p>TokenProvider:用来提供token的服务。比如微信、支付宝、github,也可以是自己搭建的Keycloak服务。</p></li></ul><h2 id="网关统一用户认证"><a href="#网关统一用户认证" class="headerlink" title="网关统一用户认证"></a>网关统一用户认证</h2><p>很简单，说白了就是在Gateway集成Security，这样以来Gateway就成了一个ResourceServer，并且可以为所有路由做用户认证。</p><p>但是！<strong>具体的鉴权还是需要各个服务自己去做</strong>，毕竟网关不知道具体的服务需要具体哪一项权限。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="直接使用微信、支付宝的token来做自己的有效性验证可以码？"><a href="#直接使用微信、支付宝的token来做自己的有效性验证可以码？" class="headerlink" title="直接使用微信、支付宝的token来做自己的有效性验证可以码？"></a>直接使用微信、支付宝的token来做自己的有效性验证可以码？</h3><p>当然可以！只不过，人家的token验证只有在调用他们的服务时才会生效，如果不调用他们的服务，我们自己不知道人家的token是否有效（超时过期）。</p><p>那么该怎么实现？当我们自己的接口被访问时，先去调个人家的服务，最好是无关痛痒的服务，单纯为了验证人家的token是否有效。</p><p>但是这样以来就大大降低了接口的请求速度，而且也不优雅，平衡下来还不许自己搭建帐号体系来的实在！</p><h3 id="采用授权码方式让自己的客户端访问自己服务？"><a href="#采用授权码方式让自己的客户端访问自己服务？" class="headerlink" title="采用授权码方式让自己的客户端访问自己服务？"></a>采用授权码方式让自己的客户端访问自己服务？</h3><p>这就叫脱了裤子放屁，为安全而安全！</p><p>用微信的第三方登录举例，假如我们没有登录微信，当使用微信时，依然需要用帐号密码方式先登录微信。因为你在操作授权登录时，是先调起微信的页面或者它SDK的页面，是在人家的页面里面玩的，对于微信来讲，他自己的页面就是高度授信的，所以追本溯源，授权码登录方式还是基于帐号密码之上的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;趁着下载Keycloak的时候，记录一下自己对SpringCloud中的用户鉴权系统的认识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="spring" scheme="https://vee-zhang.github.io/Vee-blog/tags/spring/"/>
    
    <category term="cloud" scheme="https://vee-zhang.github.io/Vee-blog/tags/cloud/"/>
    
    <category term="security" scheme="https://vee-zhang.github.io/Vee-blog/tags/security/"/>
    
    <category term="oauth2.0" scheme="https://vee-zhang.github.io/Vee-blog/tags/oauth2-0/"/>
    
  </entry>
  
  <entry>
    <title>开篇第一章</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/07/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2021-01-07T08:30:36.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<p>这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是Hexo博客的开篇第一章，也意味着我要迈向新的章节了。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建pub.dev私服及上传package</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/01/06/%E6%90%AD%E5%BB%BApub-dev%E7%A7%81%E6%9C%8D%E5%8F%8A%E4%B8%8A%E4%BC%A0package/</id>
    <published>2021-01-06T08:57:01.000Z</published>
    <updated>2021-03-01T06:47:06.053Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="server配置"><a href="#server配置" class="headerlink" title="server配置"></a>server配置</h2><p>首先到我的<a href="https://gitee.com/william198824/pub_server">码云</a>clone个项目下来,然后习惯性<code>flutter pub get</code>。</p><p>接下来修改配置，修改<code>pub_server/example/src/example.dart</code>文件,找到<code>argsParser()</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArgParser argsParser() &#123;</span><br><span class="line">  <span class="keyword">var</span> parser = ArgParser();</span><br><span class="line"></span><br><span class="line">  parser.addOption(<span class="string">&#x27;directory&#x27;</span>,</span><br><span class="line">      abbr: <span class="string">&#x27;d&#x27;</span>, defaultsTo: <span class="string">&#x27;pub_server-repository-data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//host地址</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;host&#x27;</span>, abbr: <span class="string">&#x27;h&#x27;</span>, defaultsTo: <span class="string">&#x27;localhost&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">  parser.addOption(<span class="string">&#x27;port&#x27;</span>, abbr: <span class="string">&#x27;p&#x27;</span>, defaultsTo: <span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我的8080端口已经被jenkies占用了，所以只能把pub的端口改为9090。要注意的是，<strong>host默认是localhost，只支持本机访问</strong>，如果我们要挂到服务上，需要把这里改为<code>0.0.0.0</code>之后，我们才能通过ip或者域名访问服务。</p><p>然后启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart example/example.dart -d /tmp/package-db</span><br></pre></td></tr></table></figure><blockquote><p>如果出现「To make the pub client use this repository configure…」表示服务启动成功！</p></blockquote><h2 id="创建测试package"><a href="#创建测试package" class="headerlink" title="创建测试package"></a>创建测试package</h2><p>怎么创建，不说了，这里只贴出yaml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lk_dio</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">用于来康科技公司的网络请求层封装，包括平台、大脑的接口调用规则和token有效期验证及自动刷新机制。</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">William</span> <span class="string">&lt;自己的邮箱@enn.cn&gt;</span></span><br><span class="line"><span class="attr">homepage:</span> <span class="string">&#x27;http://项目主页地址.com&#x27;</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">&#x27;http://localhost:9090&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.7.0 &lt;3.0.0&quot;</span></span><br><span class="line">  <span class="attr">flutter:</span> <span class="string">&quot;&gt;=1.17.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter:</span></span><br></pre></td></tr></table></figure><p>配置好之后,可以在本地直接依赖：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lk_dio:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">user/william/lk_dio</span></span><br></pre></td></tr></table></figure><p>当然也可以发布到我们的pub私服上，发布之前可以通过命令检查错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure><p>按照提示解决问题，然后发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure><p>出现如下信息表明发布成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- lib</span><br><span class="line">|   &#x27;-- helloworld.dart</span><br><span class="line">|-- pubspec.yaml</span><br><span class="line">&#x27;-- test</span><br><span class="line">    &#x27;-- helloworld_test.dart</span><br><span class="line"></span><br><span class="line">Looks great! Are you ready to upload your package (y/n)? y</span><br><span class="line">Uploading...</span><br><span class="line">Successfully uploaded package.</span><br></pre></td></tr></table></figure><p>但是如果不FQ，是一定不会成功的，你看到的将是如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pub needs your authorization to upload packages on your behalf.</span><br></pre></td></tr></table></figure><p>失败的原因就是需要google的认证，怎么办，fq? 有没有更好的办法？</p><h2 id="绕过google认证"><a href="#绕过google认证" class="headerlink" title="绕过google认证"></a>绕过google认证</h2><p>再clone<a href="https://gitee.com/william198824/pub">这个项目</a>之后<code>flutter pub get</code>，然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart --snapshot=mypub.dart.snapshot bin/pub.dart </span><br></pre></td></tr></table></figure><p>完事后会自动生成一个<code>mypub.dart.snapshot</code>。</p><p>复制之后放入${flutterSDK Path}/bin/cache/dart-sdk/bin/snapshots/ 目录下</p><p>用txt编辑器打开${flutterSDK Path}/bin/cache/dart-sdk/bin/pub文件，将倒数第三行的：<code>pub.dart.snapshot</code> 替换为 <code>mypub.dart.snapshot</code>,然后重新发布package就OK了。</p><h2 id="依赖自己的package"><a href="#依赖自己的package" class="headerlink" title="依赖自己的package"></a>依赖自己的package</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">lk_dio:#这里要与之前一致</span></span><br><span class="line">  <span class="attr">hosted:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">lk_dio</span> <span class="comment">#这里要与之前一致</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://localhost:9090</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">^1.0.0</span></span><br></pre></td></tr></table></figure><p>添加了依赖之后，我<code>flutter pub get</code>，本机没问题，项目正常跑，万分激动，但是。。。</p><p>当我把server发布到公司服务器后，<strong>publish失败！</strong>经查，是运维没有开放9090端口，找过运维之后问题解决。</p><p>然后我再添加依赖，运行pub get，竟然卡住不动了，内心瞬间一万只草泥马德，上传可以下载就不行怪了！后来发现server的配置文件中有个配置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行模式</span></span><br><span class="line">  parser.addFlag(<span class="string">&#x27;standalone&#x27;</span>, abbr: <span class="string">&#x27;s&#x27;</span>, defaultsTo: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><code>standalone</code>好像是独立部署的意思。</p><p>把这里的<code>defaultTo</code>的值改为<code>true</code>,重新部署、启动，再重新下载依赖pub get，等等足足71秒后竟然成功了！后来运维解释，之所以这么慢是因为从北京访问我们盐城的服务器，而且没有CDN加速。</p><h2 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h2><p><a href="https://www.jianshu.com/p/59f4778864f0">https://www.jianshu.com/p/59f4778864f0</a></p>]]></content>
    
    
    <summary type="html">事情的起因是，在工作项目中，一开始只有我一个人研发，为了方便，我封装了一个网络访问层。但是随着团队规模的拓展，陆续加入了其他人，时间紧项目重，所以后续的伙伴没有时间来问我这个框架怎么使用，所以他们直接上手改了我的封装！但是后期架构要求加入oauth2.0机制，所以需要全局处理token的有效认证，并且自动刷新token。为了满足这一需求，我需要重新编写网络层，同时为了避免伙伴修改我的抽象，我想到了本文的主题——搭建个pub.dev私服吧！</summary>
    
    
    
    <category term="technology" scheme="https://vee-zhang.github.io/Vee-blog/categories/technology/"/>
    
    
    <category term="pub" scheme="https://vee-zhang.github.io/Vee-blog/tags/pub/"/>
    
    <category term="flutter" scheme="https://vee-zhang.github.io/Vee-blog/tags/flutter/"/>
    
    <category term="dart" scheme="https://vee-zhang.github.io/Vee-blog/tags/dart/"/>
    
  </entry>
  
</feed>
