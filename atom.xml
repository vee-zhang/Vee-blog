<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vee&#39;s blog</title>
  
  <subtitle>make world better !</subtitle>
  <link href="https://vee-zhang.github.io/Vee-blog/atom.xml" rel="self"/>
  
  <link href="https://vee-zhang.github.io/Vee-blog/"/>
  <updated>2021-05-10T10:04:03.048Z</updated>
  <id>https://vee-zhang.github.io/Vee-blog/</id>
  
  <author>
    <name>Vee Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对SpringGateway+Security+OAuth2.0的认识</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/05/10/RecyclerView%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/05/10/RecyclerView%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-05-10T09:49:10.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RV是什么"><a href="#RV是什么" class="headerlink" title="RV是什么"></a>RV是什么</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">ScrollingView</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是个<code>ViewGroup</code>，并且遵循了<code>ScrollingView</code>接口，所以支持滑动。</p><p>那么，既然是VG，那么我们就从VG的核心方法入手，他们分别是：</p><ul><li>onMeasure</li><li>onLayout</li><li>onDrow</li></ul><h2 id="RV的状态"><a href="#RV的状态" class="headerlink" title="RV的状态"></a>RV的状态</h2><p>在开始RV的内窥之前，我们先了解一下RV有几种状态，这样有利于我们的理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntDef(flag = true, value = &#123;</span></span><br><span class="line"><span class="meta">        STEP_START, STEP_LAYOUT, STEP_ANIMATIONS</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@interface</span> LayoutState &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LayoutState</span></span><br><span class="line"><span class="keyword">int</span> mLayoutStep = STEP_START;</span><br></pre></td></tr></table></figure><ul><li>STEP_START：开始状态</li><li>STEP_LAYOUT：布局状态</li><li>STEP_ANIMATIONS：动画状态</li></ul><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有设置layoutManager，则采用padding+最小尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断layoutManager中的一个标志位，但是这个标志位已经标明过期了</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        <span class="comment">//拿到mode</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让layoutManager测量</span></span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">                widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="comment">//如果是match_parent或这是个确定的值，而此时没有adapter，那就不玩了</span></span><br><span class="line">        <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是开始状态，</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            <span class="comment">//第一次layout过程</span></span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set dimensions in 2nd step. Pre-layout should happen with old dimensions for</span></span><br><span class="line">        <span class="comment">// consistency</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次layout过程</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从children中获取宽高</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果RV存在不精确的宽高，或者存在child也不精确，我们不得不再次measure</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用当前已测量过的宽高，重新生成MeasureSpec，并设置给layoutMnager</span></span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                    MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//重启过程2</span></span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// custom onMeasure</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">            startInterceptRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            processAdapterUpdatesAndSetAnimationFlags();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// consume remaining updates to provide a consistent state with the layout pass.</span></span><br><span class="line">                mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">                mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAdapterUpdateDuringMeasure = <span class="keyword">false</span>;</span><br><span class="line">            stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">            <span class="comment">// If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:</span></span><br><span class="line">            <span class="comment">// this means there is already an onMeasure() call performed to handle the pending</span></span><br><span class="line">            <span class="comment">// adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout</span></span><br><span class="line">            <span class="comment">// with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time</span></span><br><span class="line">            <span class="comment">// because getViewForPosition() will crash when LM uses a child to measure.</span></span><br><span class="line">            setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mState.mItemCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startInterceptRequestLayout();</span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>; <span class="comment">// clear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有设置layoutManager，则采用padding+最小尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultOnMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = LayoutManager.chooseSize(widthSpec,getPaddingLeft() + getPaddingRight(),</span><br><span class="line">            ViewCompat.getMinimumWidth(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = LayoutManager.chooseSize(heightSpec,getPaddingTop() + getPaddingBottom(),</span><br><span class="line">            ViewCompat.getMinimumHeight(<span class="keyword">this</span>));</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RV是什么&quot;&gt;&lt;a href=&quot;#RV是什么&quot; class=&quot;headerlink&quot; title=&quot;RV是什么&quot;&gt;&lt;/a&gt;RV是什么&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    
    <category term="Android" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/04/30/SharedPreferences%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/04/30/SharedPreferences%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-04-30T06:22:41.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SharedPreferences解读"><a href="#SharedPreferences解读" class="headerlink" title="SharedPreferences解读"></a>SharedPreferences解读</h1><blockquote><p>SharedPreferences是我们平时常用的简单储存工具。优点就是用起来方便，而且线程安全，甚至有的公司干脆连sqLite都不用了，全用SP！但是突然有一天腾讯弄出了个MMKV用来替代他，最近google也弄了个DataStorage，而且最近面试也是必问原理，于是我决定死磕一下SP。</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="getSharedPreferences"><a href="#getSharedPreferences" class="headerlink" title="getSharedPreferences"></a>getSharedPreferences</h3><p>我们通过这个方法拿到SP，该方法在Activity中内置，最终调用的是ContextWrapper的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mBase.getSharedPreferences(name, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextWrapper里面调用的mBase的对应方法，通过百度，查到mBase其实就是传说中的<code>ContextImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(String name, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</span><br><span class="line">Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">name = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File file;</span><br><span class="line"><span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (mSharedPrefsPaths == <span class="keyword">null</span>) &#123;</span><br><span class="line">mSharedPrefsPaths = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">file = mSharedPrefsPaths.get(name);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">file = getSharedPreferencesPath(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到文件后加入缓存，下次再拿文件就快了</span></span><br><span class="line">mSharedPrefsPaths.put(name, file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用重载方法执行真正的逻辑</span></span><br><span class="line"><span class="keyword">return</span> getSharedPreferences(file, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是用来获取文件，并且把文件放入ArrayMap缓存起来以备以后再次获取file可以提高效率。key就是文件的path，value就是文件映射的File对象。</p><p>然后使用文件作为参数，调用了同名的重载方法。</p><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><p>上述代码中出现了一个<code>file</code>局部变量，它是个什么角色呢，下一步我们就要来揭开它神秘的面纱。</p><p>首先看到<code>Synchronized</code>关键字，并且充当了<code>ContextIml</code>的类锁，那么带来线程安全的同时，会使所有并发访问该类的操作阻塞。那么会不会造成UI线程卡顿呢？会，但是不明显。</p><p><code>mSharedPrefsPaths = new ArrayMap&lt;&gt;();</code>，那么不用想，mSharedPrefsPaths是个ArrayMap，一定是个内存缓存。</p><p>此处代码不重要，请直接看下面文字结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到SP文件地址</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getSharedPreferencesPath</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> makeFilename(getPreferencesDir(), name + <span class="string">&quot;.xml&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到SP所在目录</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">getPreferencesDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (mPreferencesDir == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建File对象</span></span><br><span class="line">mPreferencesDir = <span class="keyword">new</span> File(getDataDir(), <span class="string">&quot;shared_prefs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确保文件一定存在</span></span><br><span class="line"><span class="keyword">return</span> ensurePrivateDirExists(mPreferencesDir);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*拿到数据目录，里面包括SP文件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDataDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">File res = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isCredentialProtectedStorage()) &#123;</span><br><span class="line">res = mPackageInfo.getCredentialProtectedDataDirFile();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDeviceProtectedStorage()) &#123;</span><br><span class="line">res = mPackageInfo.getDeviceProtectedDataDirFile();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = mPackageInfo.getDataDirFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!res.exists() &amp;&amp; android.os.Process.myUid() == android.os.Process.SYSTEM_UID) &#123;</span><br><span class="line">Log.wtf(TAG, <span class="string">&quot;Data directory doesn&#x27;t exist for package &quot;</span> + getPackageName(),</span><br><span class="line"><span class="keyword">new</span> Throwable());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">&quot;No data directory found for package &quot;</span> + getPackageName());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">&quot;No package details found for package &quot;</span> + getPackageName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">makeFilename</span><span class="params">(File base, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name.indexOf(File.separatorChar) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> File res = <span class="keyword">new</span> File(base, name);</span><br><span class="line"><span class="comment">// We report as filesystem access here to give us the best shot at</span></span><br><span class="line"><span class="comment">// detecting apps that will pass the path down to native code.</span></span><br><span class="line">BlockGuard.getVmPolicy().onPathAccess(res.getPath());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;File &quot;</span> + name + <span class="string">&quot; contains a path separator&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码没必要研究，就是经过一系列拼拼凑凑，最后拿到/data/data/包名/shared_prefs/[name].xml 文件，然后调用<code>ensurePrivateDirExists</code>方法确保文件一定存在(不存在就创建)。</p><h3 id="getSharedPreferences-重载方法"><a href="#getSharedPreferences-重载方法" class="headerlink" title="getSharedPreferences 重载方法"></a>getSharedPreferences 重载方法</h3><p>接下来调用了一个重载方法，主要是创建<code>SharedPreferenceImpl</code>对象，通过缓存进arrayMap，并且以file作为key一一绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">SharedPreferencesImpl sp;</span><br><span class="line"><span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line"><span class="comment">//获取缓存，该缓存把file和SharedPreferencesImpl一一绑定</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;file, sharedpreferencesimpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">sp = cache.get(file);</span><br><span class="line"><span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">checkMode(mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SharedPreferencesImpl</span></span><br><span class="line">sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line"><span class="comment">//缓存SP</span></span><br><span class="line">cache.put(file, sp);</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果开启多进程模式，或者小于3.0版本，则每次都重新加载文件</span></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line"></span><br><span class="line">sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayMap&lt;file, sharedpreferencesimpl&gt; <span class="title">getSharedPreferencesCacheLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">ArrayMap&lt;file, sharedpreferencesimpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line"><span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个重载方法，主要是创建<code>SharedPreferencesImpl</code>对象并且缓存，File作为key，SharedPreferencesImpl作为value，保证了File和SharedPreferencesImpl的一一对应。</p><h3 id="SharedPreferencesImpl构造方法"><a href="#SharedPreferencesImpl构造方法" class="headerlink" title="SharedPreferencesImpl构造方法"></a>SharedPreferencesImpl构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    <span class="comment">//创建备份文件对象</span></span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    mThrowable = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始加载</span></span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个同名文件，以.bak作为后缀</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File <span class="title">makeBackupFile</span><span class="params">(File prefsFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(prefsFile.getPath() + <span class="string">&quot;.bak&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，在sp所在目录中先创建了一个以“.bak”为后缀的备份文件的对象，然后在子线程中从硬盘加载文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在子线程加载文件</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">// 变更标志位</span></span><br><span class="line">        mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开启子线程从硬盘加载文件</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;SharedPreferencesImpl-load&quot;</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//dlc机制</span></span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果备份文件实体存在，则从备份恢复sp文件</span></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Map&lt;string, object=<span class="string">&quot;object&quot;</span>&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    StructStat stat = <span class="keyword">null</span>;</span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stat = Os.stat(mFile.getPath());</span><br><span class="line">        <span class="keyword">if</span> (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//读取文件内容</span></span><br><span class="line">                str = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(mFile), <span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//采用poll方式解析xml</span></span><br><span class="line">                map = (Map&lt;string, object=<span class="string">&quot;object&quot;</span>&gt;) XmlUtils.readMapXml(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;Cannot read &quot;</span> + mFile.getAbsolutePath(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtils.closeQuietly(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="comment">// An errno exception means the stat failed. Treat as empty/non-existing by</span></span><br><span class="line">        <span class="comment">// ignoring.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        thrown = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//变更标志位</span></span><br><span class="line">        mLoaded = <span class="keyword">true</span>;</span><br><span class="line">        mThrowable = thrown;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (thrown == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mMap = map;</span><br><span class="line">                    mStatTimestamp = stat.st_mtim;</span><br><span class="line">                    mStatSize = stat.st_size;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            mThrowable = t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//唯一唤醒锁的时机</span></span><br><span class="line">            mLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getXXX"><a href="#getXXX" class="headerlink" title="getXXX()"></a>getXXX()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, <span class="meta">@Nullable</span> String defValue)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意这个锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//持续等待</span></span><br><span class="line">awaitLoadedLocked();</span><br><span class="line">String v = (String)mMap.get(key);</span><br><span class="line"><span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mLock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的就是，<code>getXXX()</code>方法与构造方法中读取文件的地方是共享同一把锁<code>mLock</code>，从而使这两个方法存在互斥关系。如果文件很大，那么程序运行<code>sharedPreferenceImpl</code>构造方法的耗时就会比较长，此时调用<code>getXXX()</code>方法因为互斥锁的关系，就会持续等待，一直到构造方法执行完毕之后才能返回结果，导致主线程被阻塞，出现UI卡顿，甚至出现ANR。</p><h3 id="阶段总结"><a href="#阶段总结" class="headerlink" title="阶段总结"></a>阶段总结</h3><p><code>getSharedPreferences(String name,int mode)</code>方法用来初始化SP，主要就是创建xml文件，进而使用文件和mode创建<code>getSharedPreferencesImpl</code>对象并且返回。</p><p>而在创建<code>getSharedPreferencesImpl</code>时就会开启一个子线程从硬盘解析xml文件到内存中，同时创建一个以.bat为后缀的备份文件。</p><p>如果在构造方法读取文件期间调用了<code>getXXX()</code>方法，后者会持续等待前者完成之后才执行，会造成UI卡顿甚至ANR。</p><p>当开启<strong>多进程模式</strong>时，每次调用<code>getSharedPreferences()</code>时都会重新读取文件。因为SP不知道文件是否已被更新，所以只能每次重新读取。</p><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>按照SP的使用流程，下一步就是要获取到<code>Editor</code>对象了，我们通过<code>Editor</code>提供的<code>putXXX()</code>方法来向SP中写入数据。</p><p><code>Editor</code>是一个接口，提供了一些列的put虚方法。接口是不能直接调用的，所以我们调用的其实是他的实现类——<code>EditorImpl</code>，它是<code>getSharedPreferencesImpl</code>的<strong>内部匿名类</strong>，由于内部匿名类持有外部类的引用，那么它就可以访问外层类的成员！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又看到了这把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//持续等待</span></span><br><span class="line">awaitLoadedLocked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建EditorImpl</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EditorImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用<code>sp.editor()</code>方法，也会共享<code>mLock</code>这把锁，那么同样也存在上面说的问题，会出现卡顿。</p><h3 id="EditorImpl定义和Put操作"><a href="#EditorImpl定义和Put操作" class="headerlink" title="EditorImpl定义和Put操作"></a>EditorImpl定义和Put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorImpl</span> <span class="keyword">implements</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line"> <span class="comment">//一把锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mEditorLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;string, object&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志位</span></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mEditorLock&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mClear = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//喜闻乐见的putString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">putString</span><span class="params">(String key, <span class="meta">@Nullable</span> String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">mModified.put(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>代码很简单，put操作其实就是对HashMap缓存进行写入，同时为了保证线程安全，加了锁。每个PUT操作都是互斥关系。改动并没有即时提交到硬盘文件，也没有提交到真正的缓存mMap，而是提交到了editor内部的缓存<strong>mModified</strong>里面了。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line"><span class="comment">//为何不设置为null?;</span></span><br><span class="line">mModified.put(key, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我看到<code>remove()</code>方法定义时，我惊呆了！mModified里面放了this，而this又持有了mModified，这不就造成循环引用了吗，不会出问题吗？希望日后能找到答案吧。</p><p>我觉得一般人都会设置null吧。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line">mClear = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clear</code>方法也是非常奇怪，只是设置了一下标志位，并没有做其他的事情。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>怎样解决卡顿问题？</p><ol><li>尽量把大文件拆分成多个小文件。</li><li>尽量提前初始化sp。</li><li>然后尽量不要在初始化之后马上就用sp。</li></ol><h3 id="commit"><a href="#commit" class="headerlink" title="commit()"></a>commit()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交到内存</span></span><br><span class="line">MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"><span class="comment">//子线程写入文件</span></span><br><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//计数锁等待</span></span><br><span class="line">mcr.writtenToDiskLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知监视器</span></span><br><span class="line">notifyListeners(mcr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回读写结果true or false</span></span><br><span class="line"><span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commit方法通过计数锁阻塞了当前线程，等待子线程中的写操作完成，才会被唤醒，充分体现了线程协作的思想。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交到内存</span></span><br><span class="line"><span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实并不起作用，迷之操作</span></span><br><span class="line"><span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//计数锁开始等待</span></span><br><span class="line">mcr.writtenToDiskLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加生命周期回调</span></span><br><span class="line">QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用计数锁阻塞当前线程</span></span><br><span class="line">awaitCommit.run();</span><br><span class="line"><span class="comment">//移除生命周期回调</span></span><br><span class="line">QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程写入文件</span></span><br><span class="line">SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知监视器</span></span><br><span class="line">notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这两个方法主要干了三件事：</p><ol><li>调用<code>commitToMemory()</code>方法从<code>mModified</code>提交改动到<code>mMap</code>；</li><li>调用<code>SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);</code>把改动写入文件；</li><li>调用<code>notifyListeners(mcr);</code>通知监视器。</li></ol><p>不同点在于，<code>commit</code>方法在写入文件时，通过计数锁阻塞了当前线程，那么如果在主线程调用<code>commit</code>的话，就会造成卡顿了。而<code>apply</code>方法是把计数锁放到了另一个子线程中去执行了，所以阻塞的是另一个子线程，在一般情况下对主线程没有影响。</p><p>但是，当生命周期处于<code>handleStopService()</code> 、 <code>handlePauseActivity()</code> 、 <code>handleStopActivity()</code>时，会调用 <code>QueuedWork</code>的<code>waitToFinish()</code>方法，在这个方法中会遍历执行所有的<code>finisher</code>，所以如果内容很多，**<code>Apply</code>方法还是会引起ANR**。</p><p>最后，<code>apply</code>方法没有返回写入的成功失败。</p><p>怎么解决ANR问题？</p><p>我觉得在子线程中调用commit方法应该是个不错的选择吧。</p><h3 id="enqueueDiskWrite"><a href="#enqueueDiskWrite" class="headerlink" title="enqueueDiskWrite"></a>enqueueDiskWrite</h3><p><code>commit</code>和<code>apply</code>两个方法都是在主线程调用了这个方法完成写入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*使已经提交给内存的结果排队，以将其写入磁盘。它们将按入队的顺序一次写入磁盘</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;</span><br><span class="line"><span class="comment">//commit-true apply-false</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;</span><br><span class="line">writeToFile(mcr, isFromSyncCommit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件写完之后才会减1</span></span><br><span class="line">mDiskWritesInFlight--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//apply会执行</span></span><br><span class="line"><span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//主要是为了移除Finisher</span></span><br><span class="line">postWriteRunnable.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// commit执行</span></span><br><span class="line"><span class="keyword">if</span> (isFromSyncCommit) &#123;</span><br><span class="line"><span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"><span class="comment">//如果在commit之后紧接着又调用了commit，那么这里就是false了</span></span><br><span class="line">wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">writeToDiskRunnable.run();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply执行；频繁commit时后面的commit会转为异步执行</span></span><br><span class="line">QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里先定义了一个<code>Runnable</code>叫做writeToDiskRunnable ，一看名字就知道是用来IO写磁盘的。所以其中必然有<code>writeToFile</code>方法的调用啦。由于在同一线程顺序执行，<code>writeToFile</code>方法中必然会把<code>mcr.writtenToDiskLatch.countDown()</code>，所以后面的<code>postWriteRunnable.run();</code>只是为了移除finisher，而之前的<code>awaitCommit</code>这个Runnable中的<code>mcr.writtenToDiskLatch.await();</code>并没有起什么作用。</p><p>我们看到，系统通过变换<code>mDiskWritesInFlight</code>尽可能把<code>commit</code>转换为<code>apply</code>去执行。</p><p><code>commit</code>在当前线程就直接<code>run</code>了，而<code>apply</code>则是提交给了<code>QueuedWork.queue(writeToDiskRunnable,false)</code>。</p><p>这里要注意<code>mDiskWritesInFlight</code>这个计数器只有在<code>commitToMemory()</code>方法中才会++，只有在<code>writeToFile()</code>完成后才会–，所以当commit之后，紧接着再次调用commit，那么之后的commit都会转成异步方式执行写入，而异步是通过HandlerThread实现的（8.0以前则是通过SingleThreadPool实现），<code>QueuedWork.queue()</code>方法是把任务提交到了一个静态队列里面，由HandlerThread顺序执行。</p><h3 id="commitToMemory"><a href="#commitToMemory" class="headerlink" title="commitToMemory"></a>commitToMemory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if any changes were made</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MemoryCommitResult <span class="title">commitToMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line"><span class="keyword">boolean</span> keysCleared = <span class="keyword">false</span>;</span><br><span class="line">List&lt;String&gt; keysModified = <span class="keyword">null</span>;</span><br><span class="line">Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="keyword">null</span>;</span><br><span class="line">Map&lt;String, Object&gt; mapToWriteToDisk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mDiskWritesInFlight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">mMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(mMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换对象</span></span><br><span class="line">mapToWriteToDisk = mMap;</span><br><span class="line">mDiskWritesInFlight++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样是转换对象</span></span><br><span class="line"><span class="keyword">boolean</span> hasListeners = mListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">keysModified = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">listeners = <span class="keyword">new</span> HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又一把锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (mEditorLock) &#123;</span><br><span class="line"><span class="keyword">boolean</span> changesMade = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个标志位，为true说明调用过editor.clear()方法</span></span><br><span class="line"><span class="keyword">if</span> (mClear) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mapToWriteToDisk.isEmpty()) &#123;</span><br><span class="line">changesMade = <span class="keyword">true</span>;</span><br><span class="line">mapToWriteToDisk.clear();</span><br><span class="line">&#125;</span><br><span class="line">keysCleared = <span class="keyword">true</span>;</span><br><span class="line">mClear = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历拷贝</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</span><br><span class="line">String k = e.getKey();</span><br><span class="line">Object v = e.getValue();</span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">this</span> || v == <span class="keyword">null</span>) &#123;<span class="comment">//说明被editor.remove()过了</span></span><br><span class="line"><span class="keyword">if</span> (!mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">mapToWriteToDisk.remove(k);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mapToWriteToDisk.containsKey(k)) &#123;</span><br><span class="line">Object existingValue = mapToWriteToDisk.get(k);</span><br><span class="line"><span class="keyword">if</span> (existingValue != <span class="keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;<span class="comment">//如果值没变就跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mapToWriteToDisk.put(k, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changesMade = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">keysModified.add(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除editor缓存，释放内存</span></span><br><span class="line">mModified.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (changesMade) &#123;</span><br><span class="line">mCurrentMemoryStateGeneration++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memoryStateGeneration = mCurrentMemoryStateGeneration;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MemoryCommitResult(memoryStateGeneration, keysCleared, keysModified,</span><br><span class="line">listeners, mapToWriteToDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commitToMemory</code>方法顾名思义就是把<code>editor</code>的<code>mModified</code>中的值提交到<code>sharedferenceImpl</code>的<code>mMap</code>。</p><p>这里加了<code>SharedPreferencesImpl.this.mLock</code>，说明多次调用<code>commit</code>或<code>apply</code>方法都会阻塞执行，而且在进行<code>commit</code>或者<code>apply</code>还没结束时就调用<code>getXXX()</code>，依然会造成卡顿。</p><p>而这里出现的第二把锁<code>mEditorLock</code>是为了保证<code>mModified</code>的线程安全。</p><h4 id="MemoryCommitResult"><a href="#MemoryCommitResult" class="headerlink" title="MemoryCommitResult"></a>MemoryCommitResult</h4><p>MemoryCommitResult是一个打包类，它把当前的内存缓存、内存状态、监听回调、写入结果全部装箱到一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCommitResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存状态版本号</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> memoryStateGeneration;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> keysCleared;</span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">final</span> List&lt;string&gt; keysModified;</span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">final</span> Set&lt;onsharedpreferencechangelistener&gt; listeners;</span><br><span class="line"><span class="keyword">final</span> Map&lt;string, object&gt; mapToWriteToDisk;</span><br><span class="line"><span class="keyword">final</span> CountDownLatch writtenToDiskLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mWritingToDiskLock&quot;)</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> writeToDiskResult = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> wasWritten = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MemoryCommitResult</span><span class="params">(<span class="keyword">long</span> memoryStateGeneration, <span class="keyword">boolean</span> keysCleared,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> List&lt;string&gt; keysModified,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Nullable</span> Set&lt;onsharedpreferencechangelistener&gt; listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;string, object&gt; mapToWriteToDisk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.memoryStateGeneration = memoryStateGeneration;</span><br><span class="line"><span class="keyword">this</span>.keysCleared = keysCleared;</span><br><span class="line"><span class="keyword">this</span>.keysModified = keysModified;</span><br><span class="line"><span class="keyword">this</span>.listeners = listeners;</span><br><span class="line"><span class="keyword">this</span>.mapToWriteToDisk = mapToWriteToDisk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唯一提供的方法，用来变更标记为，储存写入结果</span></span><br><span class="line"><span class="comment">//只有这里能唤醒计数锁！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDiskWriteResult</span><span class="params">(<span class="keyword">boolean</span> wasWritten, <span class="keyword">boolean</span> result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.wasWritten = wasWritten;</span><br><span class="line">writeToDiskResult = result;</span><br><span class="line">writtenToDiskLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply方法的QueuedWork机制"><a href="#apply方法的QueuedWork机制" class="headerlink" title="apply方法的QueuedWork机制"></a>apply方法的QueuedWork机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span> 很奇怪为啥好东西都不让我们用呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWork</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 我是一把锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object sProcessingWork = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; sFinishers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler sHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Work queued via &#123;<span class="doctag">@link</span> #queue&#125; */</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; sWork = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;sLock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sCanDelay = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFinisher</span><span class="params">(Runnable finisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sFinishers.add(finisher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFinisher</span><span class="params">(Runnable finisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sFinishers.remove(finisher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在主线程立即处理剩余任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hadMessages = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除loop</span></span><br><span class="line">            <span class="keyword">if</span> (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除消息，使handlerThread剩余的任务不再执行了</span></span><br><span class="line">                handler.removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We should not delay any work as this might delay the finishers</span></span><br><span class="line">            sCanDelay = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程使用自检</span></span><br><span class="line">        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//当生命周期变化时，系统会主动触发写入，这可是在主线程哦</span></span><br><span class="line">            processPendingWork();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//允许在当前线程进行文件写入操作</span></span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事后检查机制，保证所有finisher都被执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Runnable finisher;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">                    finisher = sFinishers.poll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于在同一线程中先调用了processPendingWork()，完成写操作后就会remove掉finisher，所以大多数情况会走到这里</span></span><br><span class="line">                <span class="keyword">if</span> (finisher == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                finisher.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sCanDelay = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//同一个方法在7.0上的实现</span></span><br><span class="line"><span class="comment">// 在一个单线程的线程池中执行，就单纯的靠countDownLatch.await()来等待全部任务执行完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable toFinish;</span><br><span class="line">        <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          toFinish.run();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一看就懂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPendingWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> !sWork.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步任务调度,其实就是切换到工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shouldDelayapply=false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(Runnable work, <span class="keyword">boolean</span> shouldDelay)</span> </span>&#123;</span><br><span class="line">        Handler handler = getHandler();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            sWork.add(work);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldDelay &amp;&amp; sCanDelay) &#123;</span><br><span class="line">                handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *创建一个HandlerThread，并且返回一个单例的Handler</span></span><br><span class="line"><span class="comment"> * queue方法和waitToFinish中调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;queued-work-looper&quot;</span>,</span><br><span class="line">                        Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">                handlerThread.start();</span><br><span class="line"></span><br><span class="line">                sHandler = <span class="keyword">new</span> QueuedWorkHandler(handlerThread.getLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sHandler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *自定义的Handler</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QueuedWorkHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_RUN = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        QueuedWorkHandler(Looper looper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.what == MSG_RUN) &#123;</span><br><span class="line"><span class="comment">//切换到了handlerThread所在线程</span></span><br><span class="line">                processPendingWork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*用来处理挂起的任务，核心方法，遍历执行task，此时已切换到工作线程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里又是一把锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sProcessingWork) &#123;</span><br><span class="line">            LinkedList&lt;Runnable&gt; work;</span><br><span class="line"><span class="comment">//这里的锁注意一下</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line"><span class="comment">//浅拷贝，这里的work其实是writeToDiskRunnable，包含文件的写入操作和finisher调用</span></span><br><span class="line">                work = (LinkedList&lt;Runnable&gt;) sWork.clone();</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line">                sWork.clear();</span><br><span class="line"><span class="comment">//释放msg</span></span><br><span class="line">                getHandler().removeMessages(QueuedWorkHandler.MSG_RUN);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历执行task</span></span><br><span class="line">            <span class="keyword">if</span> (work.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Runnable w : work) &#123;</span><br><span class="line">                    w.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity在OnPause时会调用ActivityThread的<code>handleStopActivity</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">performStopActivityInner(r, stopInfo, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">reason);</span><br><span class="line"></span><br><span class="line">updateVisibility(r, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.0及以后版本，确保所有挂起的写入全都提交到文件</span></span><br><span class="line"><span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">QueuedWork.waitToFinish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopInfo.setActivity(r);</span><br><span class="line">stopInfo.setState(r.state);</span><br><span class="line">stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">pendingActions.setStopInfo(stopInfo);</span><br><span class="line">mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.0及以后系统，当发生cresh或者Activity、broaderCaster、service生命周期发生改变时，主线程会自动调用<code>QueuedWork.waitToFinish()</code>把当前挂起的修改写入到文件系统中！！！如果没有任何修改，那么就会遍历执行所有的finisher！！！这就是<code>apply</code>方法提交也会导致ANR的秘密！！！</p><p>如果过多的使用apply，可能在activity生命周期发生改变时，没能执行完全部的apply，那么就会在生命周期时自动执行余下的apply，保证异步任务不会丢失。</p><h4 id="最重要的方法writeToFile"><a href="#最重要的方法writeToFile" class="headerlink" title="最重要的方法writeToFile"></a>最重要的方法writeToFile</h4><h5 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足写入条件，并且备份文件</span></span><br><span class="line"><span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line"><span class="keyword">boolean</span> needsWrite = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果硬盘状态版本号低于内存状态版本号，那么只需要写入</span></span><br><span class="line"><span class="keyword">if</span> (mDiskStateGeneration &lt; mcr.memoryStateGeneration) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFromSyncCommit) &#123;<span class="comment">//commit</span></span><br><span class="line">needsWrite = <span class="keyword">true</span>;<span class="comment">//变更标志位</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;<span class="comment">//apply</span></span><br><span class="line"><span class="comment">//无需保持中间状态。只需等待最新状态保持不变即可。</span></span><br><span class="line"><span class="keyword">if</span> (mCurrentMemoryStateGeneration == mcr.memoryStateGeneration) &#123;</span><br><span class="line">needsWrite = <span class="keyword">true</span>;<span class="comment">//变更标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要写入，那么直接设置结果</span></span><br><span class="line"><span class="keyword">if</span> (!needsWrite) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判定备份文件是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> backupFileExists = mBackupFile.exists();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果备份不存在，则把文件内容备份</span></span><br><span class="line"><span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果已存在备份，则删掉文件</span></span><br><span class="line">mFile.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真正的写入"><a href="#真正的写入" class="headerlink" title="真正的写入"></a>真正的写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试写入文件，删除备份并尽可能自动地返回true。如果发生任何异常，请删除新文件。下次我们将从备份中还原。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果拿不到输出流就直接返回结果：失败</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行写入操作</span></span><br><span class="line">XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存写入的时间点</span></span><br><span class="line">writeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">FileUtils.sync(str);</span><br><span class="line"></span><br><span class="line">fsyncTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写完了，关闭输出流</span></span><br><span class="line">str.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文件权限</span></span><br><span class="line">ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取文件系统中的文件状态</span></span><br><span class="line"><span class="keyword">final</span> StructStat stat = Os.stat(mFile.getPath());</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">mStatTimestamp = stat.st_mtim;</span><br><span class="line">mStatSize = stat.st_size;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line"><span class="comment">// Do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入成功后删除备份</span></span><br><span class="line">mBackupFile.delete();</span><br><span class="line"></span><br><span class="line">mDiskStateGeneration = mcr.memoryStateGeneration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果</span></span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> fsyncDuration = fsyncTime - writeTime;</span><br><span class="line">mSyncTimes.add((<span class="keyword">int</span>) fsyncDuration);</span><br><span class="line">mNumSync++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;writeToFile: Got exception:&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;writeToFile: Got exception:&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理干净没有写入成功的文件</span></span><br><span class="line"><span class="keyword">if</span> (mFile.exists()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mFile.delete()) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">&quot;Couldn&#x27;t clean up partially-written file &quot;</span> + mFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回结果：失败</span></span><br><span class="line">mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这段逻辑真的好长，最后回顾起来却很简单，它只干了3件事情：</p><ul><li>用xml文件生成一个备份，用来做失败还原</li><li>用XmlUtil执行写入，写入成功后删除备份返回结果</li><li>写入失败则清理文件，保留备份</li></ul><p>这里还要注意的是，无论如何都会创建一个新的源文件来写入，所以不论是<code>commit</code>还是<code>apply</code>都是全量更新，效率非常的低！</p><h3 id="notifyListeners"><a href="#notifyListeners" class="headerlink" title="notifyListeners"></a>notifyListeners</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mcr.listeners == <span class="keyword">null</span> || (mcr.keysModified == <span class="keyword">null</span> &amp;&amp; !mcr.keysCleared)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前是主线程，就遍历MemoryCommitResult中listener</span></span><br><span class="line"><span class="keyword">if</span> (mcr.keysCleared &amp;&amp; Compatibility.isChangeEnabled(CALLBACK_ON_CLEAR_CHANGE)) &#123;</span><br><span class="line"><span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mcr.keysModified.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">final</span> String key = mcr.keysModified.get(i);</span><br><span class="line"><span class="keyword">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class="keyword">this</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果当前是子线程，就切换到主线程重新调用方法</span></span><br><span class="line">ActivityThread.sMainThreadHandler.post(() -&gt; notifyListeners(mcr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了这个方法，我才知道SP还可以注册监听。并且只有在<code>commit</code>或者<code>apply</code>时才会触发监听。而且<strong>必定在主线程回调</strong>。那么如果监听太多，或者监听里面有耗时操作，那么必定还是会ANR。</p><p>下面是监听的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val sp = getSharedPreferences(<span class="string">&quot;我擦&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line">        </span><br><span class="line">val listener = object: SharedPreferences.OnSharedPreferenceChangeListener&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">override fun <span class="title">onSharedPreferenceChanged</span><span class="params">(sharedPreferences: SharedPreferences?, key: String?)</span> </span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.registerOnSharedPreferenceChangeListener(listener)</span><br><span class="line"></span><br><span class="line">sp.unregisterOnSharedPreferenceChangeListener(listener)</span><br></pre></td></tr></table></figure><h2 id="专题：SP的缓存机制"><a href="#专题：SP的缓存机制" class="headerlink" title="专题：SP的缓存机制"></a>专题：SP的缓存机制</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><h5 id="ContextImpl中"><a href="#ContextImpl中" class="headerlink" title="ContextImpl中"></a><code>ContextImpl</code>中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayMap&lt;String, File&gt; mSharedPrefsPaths;</span><br></pre></td></tr></table></figure><p>用来缓存sp的file对象，它把name与file一一对应，用来根据name快速找到对应的file。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;File, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;</span><br></pre></td></tr></table></figure><p>用来根据file缓存spIml对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mFile;</span><br></pre></td></tr></table></figure><p>sp的硬盘缓存。</p><h5 id="spImpl中"><a href="#spImpl中" class="headerlink" title="spImpl中"></a>spImpl中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; mMap;</span><br></pre></td></tr></table></figure><p>内容的内存缓存，主要用于<code>getXXX()</code>方法。</p><h5 id="EditorImpl中"><a href="#EditorImpl中" class="headerlink" title="EditorImpl中"></a>EditorImpl中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;string, object&gt; mModified = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>写缓存，主要用于<code>putXXX()</code>方法写入的缓存，会先存到这里，等调用<code>commit</code>或者<code>apply</code>时，通过<code>commitToMemory</code>方法一次性刷入<code>mapToWriteToDisk</code>中。</p><h5 id="MemoryCommitResult中"><a href="#MemoryCommitResult中" class="headerlink" title="MemoryCommitResult中"></a>MemoryCommitResult中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;string, object&gt; mapToWriteToDisk;</span><br></pre></td></tr></table></figure><p>用来做写入前的缓存，但其实并不是缓存，而是<code>mMap</code>的引用。修改它就是修改<code>mMap</code>。</p><h4 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h4><ul><li>mFile ：位于/data/data/包名/shared_prefs/[name].xml，真正的sp文件，xml格式。</li><li>mBackupFile: 位于/data/data/包名/shared_prefs/[name].xml.bak,备份文件。</li></ul><h2 id="专题：SP的备份恢复机制"><a href="#专题：SP的备份恢复机制" class="headerlink" title="专题：SP的备份恢复机制"></a>专题：SP的备份恢复机制</h2><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(MemoryCommitResult mcr, <span class="keyword">boolean</span> isFromSyncCommit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果文件存在而备份不存在，则从源文件创建备份文件。</span></span><br><span class="line">        <span class="keyword">if</span> (!backupFileExists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFile.renameTo(mBackupFile)) &#123;</span><br><span class="line">                mcr.setDiskWriteResult(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果源文件和备份都存在，则删除源文件</span></span><br><span class="line">            mFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">///写入源文件，此时一定会生成一个新的源文件</span></span><br><span class="line">        FileOutputStream str = createFileOutputStream(mFile);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果写入成功，就删除备份</span></span><br><span class="line">        mBackupFile.delete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">///写入失败就删除脏文件，保留备份</span></span><br><span class="line">        mFile.delete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就一句话：<strong>写前备份，写后成功删备份，失败删源文件</strong>。</p><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferencesImpl(File file, <span class="keyword">int</span> mode) &#123;</span><br><span class="line">    mFile = file;</span><br><span class="line">    mBackupFile = makeBackupFile(file);</span><br><span class="line">    mMode = mode;</span><br><span class="line">    mLoaded = <span class="keyword">false</span>;</span><br><span class="line">    mMap = <span class="keyword">null</span>;</span><br><span class="line">    mThrowable = <span class="keyword">null</span>;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>spImpl</code>的构造方法中会创建一个mBackupFile。之后，就会开始从硬盘加载，也就是<code>startLoadFromDisk</code>。在这个方法中会创建一个子线程，执行<code>loadFromDisk</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLoaded) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有备份就删掉原文件，然后从备份中恢复</span></span><br><span class="line">        <span class="keyword">if</span> (mBackupFile.exists()) &#123;</span><br><span class="line">            mFile.delete();</span><br><span class="line">            mBackupFile.renameTo(mFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从mFile中解析xml到mMap缓存中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而第一次通过构造方法过来到这里时，<code>mBackupFile</code>还没有创建真实的物理文件，所以不会走恢复流程，而是直接从mFile中加载内容。</p><p>但是如果<code>mBackupFile</code>已经存在，则先删掉源文件，再从备份中恢复，最后再读取到内存缓存。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SP会在写入硬盘之前，先把以前的数据备份，写入成功就删除备份，失败就删除脏的源文件而保留备份。待下次初始化SP时，会重新从硬盘读取内容到缓存，此时如果存在备份，就先删掉源文件再从备份还原。</p><h2 id="专题：SP中的锁"><a href="#专题：SP中的锁" class="headerlink" title="专题：SP中的锁"></a>专题：SP中的锁</h2><ul><li>mLock 主要用来保护spImpl对象的安全，它是所有访问spImpl对象的操作阻塞，已达到安全性目的。</li><li>mWritingToDiskLock：文件写入锁，当多次调用apply时可以阻塞写入。</li><li>mEditorLock：多线程调用<code>editor.putXXX()</code>方法时的同步锁，用来保护editor内部的<code>mModified</code>缓存的数据安全性。</li><li>sLock：QueuedWork中用来同步启动HandlerThread和同步访问work和finisher这两条队列的同步锁。</li><li>sProcessingWork：确保同一时间只有一个线程调用<code>processPendingWork()</code>方法(前面说过apply会一部调用这方法，而activityThread会在生命周期变化时同步调用这方法)。</li><li>writtenToDiskLatch: 文件写入结果MemoryCommitResult中的计数锁，阻塞当前线程，只能countDown一次，代表文件读写完成(并不代表成功)，然后才能继续执行线程。</li></ul><h2 id="专题：SP造成的卡顿与ANR分析"><a href="#专题：SP造成的卡顿与ANR分析" class="headerlink" title="专题：SP造成的卡顿与ANR分析"></a>专题：SP造成的卡顿与ANR分析</h2><h3 id="xml文件造成的卡顿"><a href="#xml文件造成的卡顿" class="headerlink" title="xml文件造成的卡顿"></a>xml文件造成的卡顿</h3><p>SP在初始化过程中，要创建SPImpl对象时会创建一个<strong>子线程</strong>访问硬盘，<strong>加载并解析xml文件</strong>到内存缓存。如果这个文件比较大就会造成卡顿。那为什么在子线程中玩这一套会影响到主线程呢？就因为玩的是xml格式文件。</p><p>SP使用了高效的poll方式来解析xml成map，在此过程中会创建大量的临时对象，造成频繁的GC，而java在GC时会暂停所有的线程，当然也包括主线程，这就造成了主线程的卡顿了。</p><h3 id="初始化后直接读取造成的卡顿"><a href="#初始化后直接读取造成的卡顿" class="headerlink" title="初始化后直接读取造成的卡顿"></a>初始化后直接读取造成的卡顿</h3><p>在初始化过程中会调用<code>startLoadFromDisk()</code>加载文件，如果文件还没有加载完就在主线程调用<code>getXXX()</code>方法也会造成卡顿，甚至ANR。因为这两个方法都竞争**<code>mLock</code>**锁，并且在<code>getXXX()</code>中还会死循环让<code>mLock.wait()</code>，而只有文件全部读取完成后这把锁才会notifyAll。</p><h3 id="commit方法造成的卡顿"><a href="#commit方法造成的卡顿" class="headerlink" title="commit方法造成的卡顿"></a>commit方法造成的卡顿</h3><p>commit是在当前线程去写入，写入完成之后还会返回结果，如果在主线程调用这个方法，就会容易引起ANR。</p><h3 id="apply方法引起的ANR"><a href="#apply方法引起的ANR" class="headerlink" title="apply方法引起的ANR"></a>apply方法引起的ANR</h3><p>apply本身是依靠handlerThread任务队列来异步写入的，但是<code>ActivityThread</code>在生命周期发生改变时，会在主线程主动调用<code>QueuedWork</code>的<code>waitToFinish()</code>方法，遍历执行所有的finisher，而finisher中只有一行代码，就是让mcr的计数锁去await当前线程，对于activityThread来说就是主线程。</p><p>Android8.0之后，还加入可主动调用<code>processPendingWork()</code>方法执行写入，所以导致Apply方法也很容易造成ANR。</p><p>而如果我们过多的使用了apply，那么就放到了QueuedWork中的一个队列，依靠仅仅一个HandlerThread，一个一个的慢慢处理。那么当生命周期改变时，这些work没有被处理完，<code>waitToFinish()</code>方法就会移除剩余的msg，剩下的work会切换到主线程来执行，并且靠计数锁阻塞主线程，就造成了ANR。</p><blockquote><p>从这里可以看出，google希望在页面生命周期改变时，sp应该切换到主线程同步写入，宁可阻塞UI也要保证sp的写入完整性，这样才能保证到下一个页面我们直接get时能够拿到最新的值。同时这里也体现了sp应该只存入少量数据的设计思想。</p></blockquote><h2 id="专题：SP的问题梳理"><a href="#专题：SP的问题梳理" class="headerlink" title="专题：SP的问题梳理"></a>专题：SP的问题梳理</h2><ol><li>xml格式，导致文件庞大，占用硬盘；</li><li>xml解析带来的频繁GC，造成卡顿；</li><li>初始化时把所有文件内容缓存，造成内存压力；</li><li>commit和apply都会造成ANR；</li><li>每次全量写入；</li><li>进程不安全；</li><li>只能在主线程监听；</li></ol><h2 id="专题：注意事项："><a href="#专题：注意事项：" class="headerlink" title="专题：注意事项："></a>专题：注意事项：</h2><ol><li>不要存过多内容，尤其不要存json字符串，因为json字符串中存在大量的转义字符&amp;；</li><li>尽量拆分多个sp文件；</li><li>不要在初始化sp后就直接put;</li><li>不要过多调用<code>sp.edit()</code>因为每次都会生成新的<code>editor</code>对象；</li><li>尽量使用apply方法，不要多次使用apply方法。</li><li>多进程使用依赖<strong>contentProvider</strong>。</li></ol><h2 id="专题：改造思路"><a href="#专题：改造思路" class="headerlink" title="专题：改造思路"></a>专题：改造思路</h2><ol><li>采用protobuf减少文件体积，提高序列化、反序列化效率，提高io速度；</li><li>引入懒加载机制；</li><li>增量写入；</li><li>解除监听回调的主线程限制。</li><li>终极方案当然是改用mmkv或者dataStorge</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SharedPreferences解读&quot;&gt;&lt;a href=&quot;#SharedPreferences解读&quot; class=&quot;headerlink&quot; title=&quot;SharedPreferences解读&quot;&gt;&lt;/a&gt;SharedPreferences解读&lt;/h1&gt;&lt;bloc</summary>
      
    
    
    
    
    <category term="Android" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄露专题</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/24/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/24/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B8%93%E9%A2%98/</id>
    <published>2021-03-24T08:24:04.000Z</published>
    <updated>2021-05-10T10:04:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>短生命周期对象持有长生命周期对象的强引用，造成短生命周期对象在不需要使用时不能被回收。</p><h3 id="静态变量导致"><a href="#静态变量导致" class="headerlink" title="静态变量导致"></a>静态变量导致</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> RESULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Activity mActivity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mActivity = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        registerActivityLifecycleCallbacks(<span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Application</code>提供了<code>registerActivityLifecycleCallbacks</code>方法，可以监听Activity的生命周期，而<code>FragmentManager</code>中提供了<code>registerFragmentLifecycleCallbacks</code>方法可以监听Fragment的生命周期。</p><p>在<code>onActivityDestroyed</code>方法中监听到Activity正在销毁，就用弱引用去包装这个Activity，然后放入队列里面，从线程池中obtain出一个线程，5秒之后判断这个Activity的弱引用是否为null，如果为null就是已被回收了。如果不是null，说明没有被回收，可能存在内存泄露，这时候强制GC回收他，如果还不为null，说明确实存在内存泄露。</p><p>然后通过HAHA获取内存中heap堆快找引用关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;短生命周期对象持有长生命周期对象的强引用，造成短生命周期对象在不需要使用时不能被回收。&lt;/p&gt;
&lt;h3 id=&quot;静态变量导致&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Android 内存泄露 NPE" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-NPE/"/>
    
  </entry>
  
  <entry>
    <title>View的前前后后</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/24/View%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/24/View%E7%9A%84%E5%89%8D%E5%89%8D%E5%90%8E%E5%90%8E/</id>
    <published>2021-03-24T08:16:23.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    contentParent.addView(v);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View v, ViewGroup.LayoutParams lp)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    contentParent.addView(v, lp);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;setContentView&quot;&gt;&lt;a href=&quot;#setContentView&quot; class=&quot;headerlink&quot; title=&quot;setContentView&quot;&gt;&lt;/a&gt;setContentView&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>View的工作原理</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-22T02:37:36.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三大流程"><a href="#三大流程" class="headerlink" title="三大流程"></a>三大流程</h2><ul><li>measure 用来测量View的宽高；</li><li>layout    用来确定View在父容器中的放置位置；</li><li>draw  负责绘制。</li></ul><p>在ActivityThread中，当Activity创建完毕后，会将<code>DecorView</code>附加到<code>Window</code>中，同时会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>与<code>DecorView</code>建立关联。</p><p>ViewRootIml其实是<code>DecorView</code>的管理类。</p><p>View的绘制流程是从ViewRoot的<code>performTraversals()</code>方法开始的，经过<code>measure</code>、<code>layout</code>、<code>draw</code>三个过程才能最终将一个View绘制出来。</p><h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>通过调用<code>setMeasuredDimension</code>决定View的宽高。</p><p>计算之后可以通过<code>getMeasureWidth</code>和<code>getMeasureHeight</code>获取测量后的结构。</p><h3 id="measureChildren"><a href="#measureChildren" class="headerlink" title="measureChildren"></a>measureChildren</h3><p>通过遍历调用<code>measureChild(child,widthMeasureSpec,heightMeasureSpec)</code>方法完成所有子View的测量。</p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>用来确定子元素的位置。需要变脸子元素，调用其<code>layout</code>方法。</p><p>决定了View的四个顶点的坐标和实际的View的宽和高。</p><ul><li>getTop</li><li>getLeft</li><li>getRight</li><li>getBottom</li><li>getWidth</li><li>getHeight</li></ul><p><code>getWidth</code>和<code>getHeight</code>才是View的最终宽高。</p><h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><ol><li>绘制背景background.draw(canvas)。</li><li>绘制自己（onDraw）。</li><li>绘制children（dispatchDraw）。</li><li>绘制装饰（onDrawScrollBars）。</li></ol><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p>DecorView作为顶级的View，包含一个竖直的<code>LinnerLayout</code>，内部含有<strong>标题栏和内容栏</strong>.<code>setContentView</code>就是把View附加到内容栏。内容栏是个<code>FrameLayout</code>，他的的id是<code>content</code>，所以是setContentView。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取content内容栏</span></span><br><span class="line">ViewGroup content= findViewById (R.android.id.content)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取我们自己的顶级View</span></span><br><span class="line">View rootView = content.getChildAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>这是一个32位的int，高2位代表SpecMode，低30位代表SpecSize。</p><p>通过将SpecMode和SpecSize打包成一个int，避免过多的内存分配。</p><ul><li>UNSPECIFIED 父容器不做任何闲置，子View可以任意大；</li><li>EXACTLY 父容器测出View所需大小，对应match_parent和精确的值；</li><li>AT_MOST   父容器制定了一个可用大小SpecSize，View的大小不能大于这个值，用于wrap_content。</li></ul><h2 id="获取View的宽高"><a href="#获取View的宽高" class="headerlink" title="获取View的宽高"></a>获取View的宽高</h2><p>view的measure过程和Activitu生命周期不同步，所有在onCreate、onStart、onResume中都不能获取到View的宽高。</p><ul><li>Activity/View#onWindowFocusChanged；</li><li>view.post(runnable)；</li><li>ViewtreeObserver</li><li>view.measure(int widthMeasureSpec,int heightMeasureSpec)(手动测量);</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三大流程&quot;&gt;&lt;a href=&quot;#三大流程&quot; class=&quot;headerlink&quot; title=&quot;三大流程&quot;&gt;&lt;/a&gt;三大流程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;measure 用来测量View的宽高；&lt;/li&gt;
&lt;li&gt;layout    用来确定View在父容器中的放置</summary>
      
    
    
    
    
    <category term="Android View" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-View/"/>
    
  </entry>
  
  <entry>
    <title>View事件体系</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/22/View%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/22/View%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</id>
    <published>2021-03-22T00:55:28.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><h3 id="主要位置参数"><a href="#主要位置参数" class="headerlink" title="主要位置参数"></a>主要位置参数</h3><p><img src="../resource/view%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="View位置参数"></p><p>View的位置主要由它的四个顶点(相对父容器)来决定：</p><ul><li>getLeft()</li><li>getTop()</li><li>getRight()</li><li>getBottom()</li></ul><h3 id="用于移动的参数"><a href="#用于移动的参数" class="headerlink" title="用于移动的参数"></a>用于移动的参数</h3><ul><li>x/y View左上角相对父容器的坐标；</li><li>translationX/translationY View左上角相对父容器的偏移量。</li></ul><p>x = left + translationX;<br>y = top + translationY;</p><p>在View移动中，top和left不会变，xy,translation系列会变。</p><h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><p>事件：</p><ul><li>ACTION_DOWN</li><li>ACTION_MOVE</li><li>ACTION_UP</li></ul><p>触发点：</p><ul><li>getX/getY 相对当前View左上角的x和y坐标；</li><li>getRawX/getRawY 相对于手机屏幕左上角的x和y坐标。</li></ul><h3 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h3><p>系统能识别出的滑动最小距离。是个常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfiguration. get(getContext()).getScaledTouchSlop()</span><br></pre></td></tr></table></figure><p>可以利用这个常量来做过滤。</p><h3 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h3><p>速度追踪，用于追踪手指在一定时间内滑动过的像素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件定位1000毫秒，也就是1秒</span></span><br><span class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//回收</span></span><br><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure><h3 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h3><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector  mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//解决长按屏幕后无法拖动的现象</span></span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>然后在View的<code>onTouchEvent(event)</code>方法中接管事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure><p>然后实现<code>OnGestureListener</code>和<code>OnDoubleTapListener</code>方法。</p><h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>在View滑动时，可以调用scrollTo/scrollBy方法，但是这两个方法会瞬间完成，没有过度动画，Scroller可解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scroller scroller = <span class="keyword">new</span> Scroller(mContext);</span><br><span class="line"><span class="comment">// 缓慢滚动到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX,<span class="keyword">int</span> destY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> delta = destX -scrollX;</span><br><span class="line">    <span class="comment">// 1000ms内滑向destX，效果就是慢慢滑动</span></span><br><span class="line">    mScroller.startScroll(scrollX,<span class="number">0</span>,delta,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">            postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h3><ul><li>scrollTo/scrollBy 使内容滑动</li><li>动画实现平移效果</li><li>改变View的LayoutParams使View重新布局。</li></ul><h4 id="scrollTo-scrollBy"><a href="#scrollTo-scrollBy" class="headerlink" title="scrollTo/scrollBy"></a>scrollTo/scrollBy</h4><ul><li>scrollTo  绝对滑动。</li><li>scrollBy 基于当前位置相对滑动。</li></ul><p>scrollBy实际上也是调用scrollTo方法实现的。</p><p>获取当前滑动位置：</p><ul><li>getScrollX</li><li>getScrollY </li></ul><p>在滑动过程中，mScrollX的值总是等于View左边元和View内容左边元在水平方向的距离。而mScrollY的值总是等于View上边缘和内容上边缘在竖直方向的距离。</p><p><strong>scrollTo和scrollBy只改变View内容的位置</strong>。</p><h4 id="动画操作translationX-translationY"><a href="#动画操作translationX-translationY" class="headerlink" title="动画操作translationX/translationY"></a>动画操作translationX/translationY</h4><p>View动画是对view的影像做操作，并不能真正改变View的位置参数。所以在新的位置单击等操作会无效。解决方式是使用属性动画。</p><h4 id="改布局参数"><a href="#改布局参数" class="headerlink" title="改布局参数"></a>改布局参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParams params = (MarginLayoutParams)mButton1.getLayoutParams();</span><br><span class="line">params.width += <span class="number">100</span>;</span><br><span class="line">params.leftMargin += <span class="number">100</span>;</span><br><span class="line">mButton1.requestLayout();</span><br><span class="line"><span class="comment">//或者mButton1.setLayoutParams(params);</span></span><br></pre></td></tr></table></figure><h2 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h2><h3 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h3><ul><li>dispatchTouchEvent</li><li>onInterceptTouchEvent</li><li>onTouchEvent</li></ul><p><code>dispatchTouchEvent</code>用来用来做事件的分发，返回结果受当前View的<code>onTouchEvent</code>和下级View的<code>dispatchTouchEvent</code>影像。返回值表示是否小号掉当前的事件。</p><p><code>onInterceptTouchEvent</code>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p><p><code>onTouchEvent</code>在<code>dispatchTouchEvent</code>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="comment">//如果拦截到，调用onTouchEvent</span></span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不拦截，透传到子View的dispatchTouchEvent</span></span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里可以看出，子View是事件的最终处理者，所以不需要在子View内进行拦截了，因而在自定义View中不需要重写<code>onInterceptTouchEvent</code>。</p><p>当一个View设置了<code>onTouchListener</code>，事件先被<code>onTouchListener</code>处理，其中的<code>onTouch()</code>方法先被回调，如果返回false，则当前View的<code>onTouchEvent</code>方法才会被调用；如果返回true，<code>onTouchEvent()</code>方法就不会被调用。在<code>onTouchEvent()</code>方法中，如果当前View设置了<code>onClickListener</code>，那么最后才会调用<code>onClick()</code>方法。<code>onClickListener</code>的优先级最低，处于事件传递的尾端。</p><h3 id="事件传递的层级顺序"><a href="#事件传递的层级顺序" class="headerlink" title="事件传递的层级顺序"></a>事件传递的层级顺序</h3><ol><li>Activity</li><li>Window</li><li>ViewGroup</li><li>View</li></ol><p>事件从上倒下传递，如果其中一环的<code>onTouchEvent</code>返回false，则回传到父容器的<code>onTouchEvent</code>方法。如果所有的View都不处理事件，最终将会回传给Activity的<code>onTouchEvent()</code>方法处理。</p><p><code>MotionEvent</code>代表一系列事件，基本上会被一个View统一处理，也可以在通过调用其他View的<code>onTouchEvent</code>处理。</p><p>如果View一旦开始处理事件，如果它不消耗掉当前事件，那么同一事件序列中的其他事件都不会再交给他处理，eg:View收到了ACTION_DOWN，如果不消耗掉，那么后面的ACTION_MOVE和ACTION_UP都不会再交给他处理。</p><p>如果View不消耗掉除了ACTION_DOWN以外的其他事件，那么这个点击事件就会消失，父级容器的<code>onTouchEvent()</code>并不会调用。并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p><p>ViewGroup默认不拦截任何事件。<code>onInterceptTouchEvent()</code>方法默认返回false。</p><p>View的<code>onTouchEvent</code>默认返回true，即默认消耗事件（除非不可点击）。</p><p>View的<code>enable</code>属性不影像<code>onTouchEvent</code>的默认返回值。</p><h3 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h3><h4 id="内外滑动方向不一致"><a href="#内外滑动方向不一致" class="headerlink" title="内外滑动方向不一致"></a>内外滑动方向不一致</h4><p>在外层根据滑动方向判断，如果与自己方向一致，就拦截，否则传递给子View处理并消耗掉。</p><p>判断方法：</p><ul><li>水平方向与竖直方向的夹角；</li><li>水平方向与竖直方向的距离差</li></ul><h4 id="内外滑动方向一致"><a href="#内外滑动方向一致" class="headerlink" title="内外滑动方向一致"></a>内外滑动方向一致</h4><ul><li>根据业务需求来做判断</li><li>根据ACTION_DOWN的落点坐标来判断</li></ul><h2 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;位置参数&quot;&gt;&lt;a href=&quot;#位置参数&quot; class=&quot;headerlink&quot; title=&quot;位置参数&quot;&gt;&lt;/a&gt;位置参数&lt;/h2&gt;&lt;h3 id=&quot;主要位置参数&quot;&gt;&lt;a href=&quot;#主要位置参数&quot; class=&quot;headerlink&quot; title=&quot;主要位置参</summary>
      
    
    
    
    
    <category term="Android View" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-View/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/19/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/19/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2021-03-19T07:09:10.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h2><ul><li>原子性    操作要么成功，要么失败，中途不可被中断。</li><li>可见性    共享变量的变更立即可见。</li><li>有序性    程序执行依照代码的先后顺序来执行。</li></ul><h2 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h2><p>JMM的原则是数据拷贝，会从主存拷贝到CPU缓存，再拷贝到CPU寄存器。CPU寄存器的速度远高于缓存，缓存的读写速度远高于主存。当一个线程在寄存器中修改了数据，而没有同步到主存时，另一线程从主存读取了过期的数据，造成数据不同步问题。解决方式是同步访问（加锁）或者通过<code>volatile</code>强制刷写到主存。</p><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p><strong>如果不存在数据依赖性</strong>，为了提高性能，编译器和cpu会在不改变程序执行结果的前提下对指令重新排序。</p><h2 id="JMM内存屏障"><a href="#JMM内存屏障" class="headerlink" title="JMM内存屏障"></a>JMM内存屏障</h2><ul><li>LoadLoad   可保障：在执行屏障后面的所有读取操作之前，屏障前面的读取操作全部完成。</li><li>StoreStore  可保障：在执行屏障后面的所有写入操作之前，屏障前面的写入操作全部完成。</li><li>LoadStore 可保障：在执行屏障后面的所有写入操作之前，屏障前面的读取操作全部完成。</li><li>StoreLoad 可保障：在执行屏障后面的所有读取操作之前，屏障前面的写入操作全部完成。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>符合可见性和有序性，不保证原子性。</p><p>通过在编译器生成字节码时，在指令序列中添加<strong>内存读写屏障</strong>来禁止指令重排序，保障了可见性和有序性，不能保证原子性。</p><p>JVM会在volatile修饰的变量前后都加上内存屏障，保证有序性：</p><ol><li>LoadLoadBarrier</li><li>volatile读操作</li><li>LoadStoreBarrier</li><li></li><li>StoreStoreBarrier</li><li>volatile写操作</li><li>StoreLoadBarrier</li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>符合并发编程的三大特征。</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁;</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁;</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><img src="../resource/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="java堆存储"></p><p>原理是对象头中存在访问计数、偏向锁、轻量锁。</p><p>从jvm层面锁就是监视器<code>monitor</code>。持有或者重入monitor会使计数器自加1。释放时计数器归0，其他线程才能持有monitor。</p><h2 id="对象锁操作"><a href="#对象锁操作" class="headerlink" title="对象锁操作"></a>对象锁操作</h2><ul><li><code>void wait()</code> 导致一个线程进入等待状态，直到它得到通知。该方法只能在一个同步方法或同步块中调用。如果当前线程不是对象锁的持有者，会抛出异常。</li><li><code>void notify()</code> 随机选择一个在这个对象上调用wait方法的线程，接触其阻塞状态。</li><li><code>void notifyAll()</code> 解除所有被wait阻塞的线程。</li></ul><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">    Runnable runnable1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (data) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!Thread.currentThread().isInterrupted() &amp;&amp; data.getNum() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                        data.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.d(<span class="string">&quot;子线程&quot;</span>, <span class="string">&quot;run: 收到了通知，此时num值为&quot;</span> + data.getNum());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Runnable runnable2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (data) &#123;</span><br><span class="line">                data.setNum(<span class="number">1</span>);</span><br><span class="line">                data.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread t1, t2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.runnable1);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(<span class="keyword">this</span>.runnable2);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h2><ul><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicBoolean</li><li>AtomicReference</li></ul><p>原理： <code>private volatile int value;</code> 内部值带有 <code>volatile</code>保证可见性和有序性，通过<code>Unsafe</code>的底层能力保证原子性。</p><h2 id="重入锁ReentrantLocak"><a href="#重入锁ReentrantLocak" class="headerlink" title="重入锁ReentrantLocak"></a>重入锁ReentrantLocak</h2><p>重入锁：线程可以反复获得已拥有的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个重入锁</span></span><br><span class="line"><span class="keyword">new</span> reentrantLocak();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个公平锁</span></span><br><span class="line"><span class="keyword">new</span> reentrantLocak(<span class="keyword">boolean</span> fair);</span><br></pre></td></tr></table></figure><p>公平锁倾向于等待时间最长的吓成，可能严重影响性能。</p><h2 id="读写锁ReadWriteLock。"><a href="#读写锁ReadWriteLock。" class="headerlink" title="读写锁ReadWriteLock。"></a>读写锁ReadWriteLock。</h2><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><ul><li>公平锁、非公平锁：公平锁指多个线程按照申请锁的顺序来获取锁，非公平锁就是没有顺序完全随机，所以能会造成优先级反转或者饥饿现象；synchronized 就是非公平锁，ReentrantLock（使用 CAS 和 AQS 实现） 通过构造参数可以决定是非公平锁还是公平锁，默认构造是非公平锁；非公平锁的吞吐量性能比公平锁大好。</li></ul><p>可重入锁：又名递归锁，指在同一个线程在外层方法获取锁的时候在进入内层方法会自动获取锁，synchronized 和 ReentrantLock 都是可重入锁，可重入锁可以在一定程度避免死锁。</p><p>独占锁、共享锁：独享锁是指该锁一次只能被一个线程持有，共享锁指该锁可以被多个线程持有；synchronized 和 ReentrantLock 都是独享锁，ReadWriteLock 的读锁是共享锁，写锁是独占锁；ReentrantLock 的独享锁和共享锁也是通过 AQS 来实现的。</p><p>互斥锁、读写锁：其实就是独享锁、共享锁的具体说法；互斥锁实质就是 ReentrantLock，读写锁实质就是 ReadWriteLock。</p><p>乐观锁、悲观锁：这个分类不是具体锁的分类，而是看待并发同步的角度；悲观锁认为对于同一个数据的并发操作一定是会发生修改的（哪怕实质没修改也认为会修改），因此对于同一个数据的并发操作，悲观锁采取加锁的形式，因为悲观锁认为不加锁的操作一定有问题；乐观锁则认为对于同一个数据的并发操作是不会发生修改的，在更新数据的时候会采用不断的尝试更新，乐观锁认为不加锁的并发操作是没事的；由此可以看出悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升，悲观锁在 java 中很常见，乐观锁其实就是基于 CAS 的无锁编程，譬如 java 的原子类就是通过 CAS 自旋实现的。</p><p>分段锁：实质是一种锁的设计策略，不是具体的锁，对于 ConcurrentHashMap 而言其并发的实现就是通过分段锁的形式来实现高效并发操作；当要 put 元素时并不是对整个 hashmap 加锁，而是先通过 hashcode 知道它要放在哪个分段，然后对分段进行加锁，所以多线程 put 元素时只要放在的不是同一个分段就做到了真正的并行插入，但是统计 size 时就需要获取所有的分段锁才能统计；分段锁的设计是为了细化锁的粒度。</p><p>偏向锁、轻量级锁、重量级锁：这种分类是按照锁状态来归纳的，并且是针对 synchronized 的，java 1.6 为了减少获取锁和释放锁带来的性能问题而引入的一种状态，<strong>其状态会随着竞争情况逐渐升级，锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。</p><p>自旋锁：其实是相对于互斥锁的概念，互斥锁线程会进入 WAITING 状态和 RUNNABLE 状态的切换，涉及上下文切换、cpu 抢占等开销，自旋锁的线程一直是 RUNNABLE 状态的，一直在那循环检测锁标志位，机制不重复，但是自旋锁加锁全程消耗 cpu，起始开销虽然低于互斥锁，但随着持锁时间加锁开销是线性增长。</p><p>可中断锁：synchronized 是不可中断的，Lock 是可中断的，这里的可中断建立在阻塞等待中断，运行中是无法中断的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发三大特性&quot;&gt;&lt;a href=&quot;#并发三大特性&quot; class=&quot;headerlink&quot; title=&quot;并发三大特性&quot;&gt;&lt;/a&gt;并发三大特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性    操作要么成功，要么失败，中途不可被中断。&lt;/li&gt;
&lt;li&gt;可见性    共享变量</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java线程</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/19/Java%E7%BA%BF%E7%A8%8B/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/19/Java%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-19T01:44:50.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul><li>new 新建</li><li>Runnable 可运行</li><li>Blocaked 阻塞</li><li>Waiting 等待</li><li>Timed waiting 计时等待</li><li>Terminated 终止</li></ul><p><img src="../resource/thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="生命周期"></p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul><li><code>void start()</code>启动</li><li><code>void run()</code>调用内部Runnable的<code>run()</code>。</li><li><code>public static void sleep(long millis)</code>休眠指定的毫秒数。</li><li><code>static void yield()</code>使当前运行的线程向另一个线程交出运行权。</li><li><code>getState()</code>获取当前线程状态。</li><li><code>void stop()</code> 终止线程，已废弃。</li><li><code>void suspend()</code> 暂停线程，已废弃。</li><li><code>void resume()</code> 恢复已暂停的线程，已废弃。</li><li><code>void interrupt()</code> <strong>请求终止线程</strong>，变更标记为，需要用<code>isInterrupted()</code>判断。还会抛出<code>InterruptedException</code>。</li><li><code>public static boolean interrupted()</code> 检查是否被中断，会重置中断状态为false。</li><li><code>boolean isInterrupted()</code> 作用同上，但是不会重置状态。</li><li><code>static Thread currentThread()</code>获取当前正在执行的线程对象。</li><li><code>void setName(String name)</code> 给线程起个名。</li><li><code>void setDaemon(boolean isDaemon)</code> 转为守护线程。</li></ul><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ul><li>当一个线程要访问对象时（参与竞争对象锁），而该对象锁被正在被其他线程持有，此线程就会阻塞，直到其他线程释放对象锁，并且线程调度器允许此线程持有对象锁。</li><li>当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态。比如调用了<code>Object.wait()</code>或<code>Thread.join()</code>方法，或者是java.util.concurrent库中的<code>Lock.tryLock()</code>、<code>Condition.await</code>。</li></ul><h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><ul><li>任务执行完毕，run方法正常退出，线程正常终止。</li><li>抛出异常终止。</li><li>调用<code>stop()</code>方法。</li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li><code>mThread.interrupt()</code>可中断线程，但并不会终止，而只是变更了中断状态。</li><li><code>Thread.currentThread().isInterrupted()</code>可以检查中断状态。</li><li>如果线程正在阻塞中，调用<code>interrupt()</code>方法会抛出<code>InterruptedException</code>异常。捕获这个异常后，可以在线程内部的catch里面在此调用<code>interrupt()</code>方法变更状态。</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程是为其他线程提供服务的线程。JVM退出时会自动回收守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mThread.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>典型的就是GC线程。</p><h2 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h2><p>线程的<code>run</code>方法不能包抛出任何检查型异常，但是非检查型异常会导致线程终止。</p><p>可以通过实现<code>Thread.UncaughtExceptionHandler</code>接口，自定义一个未捕获异常处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line"><span class="comment">//创建处理器</span></span><br><span class="line">UncaughtExceptionHandler handler = <span class="keyword">new</span> UncaughtExceptionHandler();</span><br><span class="line"><span class="comment">//设置处理器</span></span><br><span class="line">t.setUncaughtExceptionHandler(handler);</span><br><span class="line"><span class="comment">//设置全局默认处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler(handler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(<span class="meta">@NonNull</span> Thread t, <span class="meta">@NonNull</span> Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以做异常采集、打印日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>可以使用<code>void setPriority(int newPriority)</code>设置线程优先级，值在1~10，默认为5。系统自带的常量如下：</p><ul><li>MIN_PRIORITY = 1  最小优先级</li><li>NORM_PRIORITY = 5 默认优先级</li><li>MAX_PRIORITY = 10 最大优先级</li></ul><p>默认情况下，线程会继承创建他自身的线程的优先级。</p><p>当线程调度器有机会选择新线程时，优先选择高优先级。</p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul><li>wait()、notifyAll()</li><li>Handler+Message</li><li>共享变量</li><li>信号量</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerlink&quot; title=&quot;状态&quot;&gt;&lt;/a&gt;状态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;new 新建&lt;/li&gt;
&lt;li&gt;Runnable 可运行&lt;/li&gt;
&lt;li&gt;Blocaked 阻塞&lt;/li&gt;
&lt;li&gt;Waiti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/18/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/18/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-03-18T07:33:07.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>参数解析：</p><ol><li>corePoolSize<br> 线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</li><li>maximumPoolSize<br> 线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</li><li>keepAliveTime<br> 非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPool-Executor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。</li><li>unit<br> 用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit. MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）以及TimeUnit.MINUTES（分钟）等。</li><li>workQueue<br> 线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</li><li>threadFactory<br> 线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r)。</li><li>Rejected-ExecutionHandler handler<br> 当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecution-Exception。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值。</li></ol><p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p><ol><li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li><li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调 用者。</li></ol><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>AsyncTask支持并发时的配置：</p><p>通过以下代码获取CPU核心数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure><p>配置原则：</p><ul><li>CPU密集型：大规模运算，没有阻塞，为减少cpu轮转次数，尽量减少线程数量，公式：<code>CPU核心数+1</code>;</li><li>IO密集型：阻塞多，尽量多给线程提高速度，公式：<code>CPU核心数*2</code>。</li></ul><p>AsyncTask的配置：</p><ul><li>核心线程数等于CPU核心数+1；</li><li>线程池的最大线程数为CPU核心数的2倍+1；</li><li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒；</li><li>任务队列的容量为128。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>任务调度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//当前运行的任务数</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//如果当前活跃线程数小于设置的核心线程数，直接执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//加入队列</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果xian</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>FixedThreadPool 线程数量固定，只有核心线程，当线程处于空闲状态时不会被回收。</li><li>CachedThreadPool 数量不固定，只有非核心线程，最大线程数为<code>Integer.MAX_VALUE</code>。</li><li>CachedThreadPool 核心线程数固定，非核心线程数没有限制，非核心线程闲置时会立刻被回收。主要用于执行定时任务，和具有固定周期的重复任务。</li><li>SingleThreadExecutor 只有一个核心线程，确保串行。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h2&gt;&lt;figure c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HandlerThread解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/18/HandlerThread%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/18/HandlerThread%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-18T06:22:41.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">Handler workHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;handler&quot;</span>, <span class="string">&quot;收到消息: &quot;</span> + msg.obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Message msg = Message.obtain(workHandler);</span><br><span class="line"></span><br><span class="line">msg.obj = <span class="string">&quot;我发了一条消息&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">msg.sendToTarget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">mHandlerThread.quit();</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承Thread，本身就是线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部持有looper</span></span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部持有handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">     * setup before Looper loops.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Process是进程的帮助类，可提供进程信息</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化loop</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启循环</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化内部Handler，但是外部不能调用此方法</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getThreadHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回线程id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>HandlerThread</code>本身就是一个线程，只不过它持有<code>Looper</code>,在<code>run()</code>方法内部实现了<code>Looper.prepary()</code>和<code>Looper.loop()</code>。所以任务也只能串行。</p><p>使用完要手动退出，否则线程一直存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AsyncTask解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/17/AsyncTask%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/17/AsyncTask%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-17T08:59:41.000Z</published>
    <updated>2021-05-10T10:04:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv = findViewById(R.id.tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask(<span class="keyword">this</span>.tv);</span><br><span class="line">        task.execute(<span class="string">&quot;我是&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Float</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;TextView&gt; tv;</span><br><span class="line"></span><br><span class="line">        MyTask(TextView tv) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tv = <span class="keyword">new</span> WeakReference&lt;TextView&gt;(tv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">            <span class="comment">// 任务执行前回调</span></span><br><span class="line">            tv.get().setText(<span class="string">&quot;即将开始任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... strings)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//后台任务逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (strings.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                        <span class="comment">//报告进度</span></span><br><span class="line">                        publishProgress(<span class="number">0.2f</span> * (i+<span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> strings[<span class="number">0</span>] + <span class="string">&quot;结果&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Float... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">            tv.get().setText(<span class="string">&quot;任务已执行&quot;</span>+values[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(s);</span><br><span class="line">            <span class="comment">//刷新UI</span></span><br><span class="line">            tv.get().setText(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要方法：</p><table><thead><tr><th>方法</th><th>线程</th><th>执行</th></tr></thead><tbody><tr><td>onPreExecute</td><td>主线程</td><td>任务开始前执行</td></tr><tr><td>doInBackground</td><td>子线程</td><td>后台任务执行时调用</td></tr><tr><td>onProgressUpdate</td><td>主线程</td><td><code>publishProgress</code>调用时回调</td></tr><tr><td>onPostExecute</td><td>主线程</td><td>任务完成后调用</td></tr><tr><td>onCancelled</td><td>主线程</td><td><code>cancell</code>调用时回调</td></tr></tbody></table><p>核心就这几个方法，只有<code>doInBackground</code>在子线程中调用。然后创建一个AsyncTask的实例，执行<code>execute</code>方法，并传入相应参数就开始执行了。</p><p>同时为避免内存泄露，需要用<strong>弱引用</strong>关联UI。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((Looper) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(handler != <span class="keyword">null</span> ? handler.getLooper() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   最终构造方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Looper callbackLooper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到Handler，默认拿到主线程Handler</span></span><br><span class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</span><br><span class="line">        ? getMainHandler()</span><br><span class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Callable，其中调用了doInBackground方法</span></span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">            Result result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//调用doInBackground</span></span><br><span class="line">                result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">                mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">throw</span> tr;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//发送Message</span></span><br><span class="line">                postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用FutureTask包装Callable，提供启动、取消、监听功能</span></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，Async的主要流程在构造方法中就已经定义好了。</p><p>其中有个mWorker是<code>WorkerRunnable</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">    Params[] mParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码才发现，这玩意并不是一个Runnable，而是个Callable，google跟我开了个玩笑。</p><p>接下来就是用<code>FutureTask</code>包装Callable，这样就可以具备启动、取消、完成监听功能。接下来我们去看<code>execute</code>方法。</p><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态final类型的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    sDefaultExecutor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出<code>execute</code>方法只能在主线程中调用。这就是<code>AsyncTask</code>的局限性了：只能用于主线程。</p><p><code>executeOnExecutor</code>方法传入了默认的线程池。这个线程池是在AsyncTask类首次加载时初始化的。它是个static final类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">        Params... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改状态</span></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在MainThread回调onPreExecute</span></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = params;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的执行任务</span></span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从switch判断可以知道，AsyncTask是一次性的，不能复用，只有<code>PENDING</code>状态的AsyncTask才能运行。而状态是在类加载时定义的，而且不支持修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</span><br></pre></td></tr></table></figure><p>在这个方法里，首先改变了全局的状态为「执行中」，然后通过<code>exec.execute(mFuture)</code>真正开始执行线程。在这里查看源码，发现<code>FutureTask</code>这个类同时遵循<code>Runnable</code>和<code>Future</code>接口，所以他可以被线程池execute，也能接收到callable的返回值。这也是Callable转Runnable的一种方式。</p><p>然后来看AsyncTask的三种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> </span>&#123;</span><br><span class="line">    <span class="comment">//未执行</span></span><br><span class="line">    PENDING,</span><br><span class="line">    <span class="comment">//执行中</span></span><br><span class="line">    RUNNING,</span><br><span class="line">    <span class="comment">//执行完</span></span><br><span class="line">    FINISHED,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publishProgress"><a href="#publishProgress" class="headerlink" title="publishProgress"></a>publishProgress</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报告消息是基于Handler+message的形式实现的。</p><p>这个消息的<code>what</code>是<code>MESSAGE_POST_PROGRESS</code>这个常量。<code>obj</code>是new了一个<code>AsyncTaskResult&lt;Progress&gt;(this, values)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AsyncTask mTask;</span><br><span class="line">    <span class="keyword">final</span> Data[] mData;</span><br><span class="line"></span><br><span class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收消息的Handler，依靠这个Handler切换回主线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onPostExecute"><a href="#onPostExecute" class="headerlink" title="onPostExecute"></a>onPostExecute</h3><p>这个方法是在构造方法的<code>WorkerRunnable</code>中的逻辑执行完毕，最后finally里面调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            result = doInBackground(mParams);</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">            mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">throw</span> tr;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个方法当然也是通过发送消息的方式达到线程间通信的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在Handler的handleMessage中通过what做判断，如果是postResult，就调用<code>finish()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTask的流程已经通了，最后再来看一下它是怎么玩线程池的。</p><h3 id="AsyncTask工作线程池的实现"><a href="#AsyncTask工作线程池的实现" class="headerlink" title="AsyncTask工作线程池的实现"></a>AsyncTask工作线程池的实现</h3><p>它这里是自定义了一个线程池代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可作为栈或队列使用，性能较高</span></span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在队尾添加元素</span></span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//poll()拿出队首元素</span></span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这货实际上是<code>THREAD_POOL_EXECUTOR</code>这个线程池的代理，作用就是维护任务队列。</p><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数，一直处于活动状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//最大线程数，当一个任务提交到线程池中时，如果线程数量达到了核心线程数，并且任务队列已满，不能再向任务队列中添加任务时，这时会检查任务是否达到了最大线程数，如果未达到，则创建新线程，执行任务，否则，执行拒绝策略。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//活跃时间，线程池中大于核心线程数的那部分线程，在执行完任务之后，在线程池中存活的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;AsyncTask #&quot;</span> + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), sThreadFactory);</span><br><span class="line">    threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy);</span><br><span class="line">    THREAD_POOL_EXECUTOR = threadPoolExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行这个静态代码块，初始化线程池。</p><p>我们看这里的线程池最大核心数只有1，那就是<strong>只能串行</strong>，最大线程数20，最多能有19个线程排队等待。</p><h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数&amp;最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACKUP_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler sRunOnSerialPolicy =</span><br><span class="line">            <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        android.util.Log.w(LOG_TAG, <span class="string">&quot;Exceeded ThreadPoolExecutor pool size&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBackupExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sBackupExecutorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">                sBackupExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                        BACKUP_POOL_SIZE, BACKUP_POOL_SIZE, KEEP_ALIVE_SECONDS,</span><br><span class="line">                        TimeUnit.SECONDS, sBackupExecutorQueue, sThreadFactory);</span><br><span class="line">                sBackupExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sBackupExecutor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果被拒绝，就新创建一个线程池去执行，这都可以？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AsyncTask类首次加载的时候初始化两个静态的线程池，<code>SerialExecutor</code>是个代理，内部维护着<code>Runnable</code>队列，实际通过调用threadPoolExecutor来执行任务。由于线程池不能保证线程执行的先后，所以AsyncTask通过加入外部队列的方式保障了任务执行的顺序。</p><p>AsyncTask的构造方法内部初始化了<code>Callable</code>，AsyncTask的主要流程都定义在<code>Callable</code>的<code>call()</code>方法内部，然后通过<code>FutureTask</code>包装<code>Callable</code>转换为<code>Runnable</code>传给线程池执行，同时可以取消任务或者获取返回值，最后通过内部的<code>Handler</code>发送消息切换回主线程。</p><p>由于内部的Handler在创建时传入<code>Looper.getMainLooper()</code>，所以默认线程就是主线程，并且<code>execute()</code>方法带有<code>@MainThread</code>注解，导致AsyncTask只能在主线程中使用。</p><p>AsyncTask初始化时状态为<code>pending</code>，在任务执行过程中变换为<code>Running</code>或<code>finished</code>，不可手动更改状态，导致AsyncTask不能复用。</p><h3 id="如何正确配置线程池的参数"><a href="#如何正确配置线程池的参数" class="headerlink" title="如何正确配置线程池的参数"></a>如何正确配置线程池的参数</h3><p>前面我们讲到了手动创建线程池涉及到的几个参数，那么我们要如何设置这些参数才算是正确的应用呢？实际上，需要根据任务的特性来分析。</p><p>任务的性质：CPU密集型、IO密集型和混杂型<br>任务的优先级：高中低<br>任务执行的时间：长中短<br>任务的依赖性：是否依赖数据库或者其他系统资源<br>不同的性质的任务，我们采取的配置将有所不同。在《Java并发编程实践》中有相应的计算公式。</p><p>通常来说，如果任务属于CPU密集型，那么我们可以将线程池数量设置成CPU的个数，以减少线程切换带来的开销。如果任务属于IO密集型，我们可以将线程池数量设置得更多一些，比如CPU个数*2。</p><p>PS：我们可以通过Runtime.getRuntime().availableProcessors()来获取CPU的个数。</p><p>作者：juconcurrent<br>链接：<a href="https://www.jianshu.com/p/7ab4ae9443b9">https://www.jianshu.com/p/7ab4ae9443b9</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Android AsyncTask" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/17/ThreadLocal%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/17/ThreadLocal%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-17T02:59:56.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从Set方法入手"><a href="#从Set方法入手" class="headerlink" title="从Set方法入手"></a>从Set方法入手</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，threadLocal的核心其实是<code>ThreadLocalMap</code>对象。</p><p><code>set</code>方法的作用是初始化内部的<code>ThreadLocalMap</code>，并将元素放入<code>ThreadLocalMap</code>中暂存，当前的ThreadLocal对象为key。</p><p>然后关注<code>createMap()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程中都有一个<code>threadLocals</code>对象，每次调用<code>createMap()</code>方法时都会给线程的<code>threadLocals</code>创建一个新的<code>ThreadLocalMap</code>，那么每次调用<code>set()</code>方法，其实是set给当前线程的<code>ThreadLocalMap</code>。</p><p>结论：<code>ThreadLocal</code>的<code>set</code>方法其实是把值存到了当前线程内部的<code>threadLocals</code>，而<code>threadLocals</code>是一个<code>ThreadLocalMap</code>类型的map（map嵌套），key就是当前的<code>ThreadLocal</code>。</p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLocal内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap其实是个简化的HashMap，内部是个<code>Entry</code>类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="真的线程安全？"><a href="#真的线程安全？" class="headerlink" title="真的线程安全？"></a>真的线程安全？</h2><p>大部分博客都说<code>ThreadLocal</code>是把变量在每个线程生成变量副本，线程只能操作属于自己的副本，从而不会相互影响，并且线程安全。</p><p>但是我翻来覆去的看代码，也没有看到打破引用的代码啊，没有<code>clone</code>，没有<code>new</code>，那怎么能叫副本呢？那应该不管怎么赋值，都是共享变量的引用才对啊。那么在不同线程中操作同一共享变量，又没加锁，还谈什么线程安全？</p><p>那就写个例子来印证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随便创建一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor tpe = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击按钮后让线程池执行两个任务</span></span><br><span class="line">    Data data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Data();</span><br><span class="line">        tpe.execute(<span class="keyword">new</span> MyRunnable1(data));</span><br><span class="line">        tpe.execute(<span class="keyword">new</span> MyRunnable2(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等10秒之后点第二个按钮展示结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toastResult</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;toastResult: &quot;</span> + data);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;toastResult: &quot;</span> + data, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Data&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Data data;</span><br><span class="line"></span><br><span class="line">        MyRunnable1(Data data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mThreadLocal.set(data);</span><br><span class="line">            mThreadLocal.get().name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            mThreadLocal.get().age = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;线程1： &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务2 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal&lt;Data&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Data data;</span><br><span class="line"></span><br><span class="line">        MyRunnable2(Data data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;我试试&quot;</span>, <span class="string">&quot;线程2：&quot;</span> + data);</span><br><span class="line">                mThreadLocal.set(data);</span><br><span class="line">                mThreadLocal.get().name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">                mThreadLocal.get().age = <span class="number">20</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">        String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Data(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Data() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑：创建一个变量，然后分别在两个线程中用set进各自的ThreadLocal，然后get各自的变量副本，修改值，打印当前值。最后等个20秒以后点一下获取结果按钮。</p><p>但是当我最后获取结果的时候，发现原始的Data数据变了，变成了任务2中的赋值结果！而且在两个任务执行期间，<code>threadLocal.get()</code>也能看到其他变量对data的修改结果，果然跟我的猜测不错！</p><p>通过印证，我发现ThreadLocal并不能解决线程安全问题，也并不是什么共享变量的副本。他的作用只是把数据与线程绑定，而且通过弱引用的方式避免线程作用域内的对象内存泄露。</p><h2 id="为什么Looper采用ThreadLocal？"><a href="#为什么Looper采用ThreadLocal？" class="headerlink" title="为什么Looper采用ThreadLocal？"></a>为什么Looper采用ThreadLocal？</h2><p>因为一般我们操作线程的变量，都要在线程里面去改它。我们可能new一个Thread或者new一个Runnable，通过构造方法或者在run方法里面去写变量赋值。那么问题来了，如果你拿不到线程，不能修改线程呢？比如ActivityThread。</p><p>而Looper的源码里面没有一句操作线程的代码，而是巧用了ThreadLocal完成了Looper自己与线程的绑定！！！</p><p>所以ThreadLocal的应用场景是：<strong>不需要在线程中做操作，只需要把变量与线程绑定时就用ThreadLocal!ThreadLocal就是个中介者模式！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从Set方法入手&quot;&gt;&lt;a href=&quot;#从Set方法入手&quot; class=&quot;headerlink&quot; title=&quot;从Set方法入手&quot;&gt;&lt;/a&gt;从Set方法入手&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Parcelable解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/12/Parcelable%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/12/Parcelable%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-12T06:43:10.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法内读取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Data</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成器常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Data&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Data&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用构造方法生成一个实例</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Data <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Data(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生成对应类型的数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Data[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Data[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========以下是getter和setter访问器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parcelable</code>使用：</p><ol><li>继承<code>Parcelable</code>接口；</li><li>声明构造方法，从<code>Parcel</code>中序列化数据；</li><li>重写<code>writeToParcel(Parcel dest, int flags)</code>方法，用来反序列化；</li><li>创建<code>Creator&lt;Data&gt;</code>类型的<code>CREATOR</code>，其内部实现了反序列化对象和数组的方法；</li><li>重写<code>describeContents()</code>方法。</li></ol><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>我们知道，序列化和反序列化都离不开<code>Parcel</code>对象，那他是个啥？</p><p>序列化的调用顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在我们的自定义类中：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dest.writeString(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用Parcel类中：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeString16NoHelper</span><span class="params">(<span class="meta">@Nullable</span> String val)</span> </span>&#123;</span><br><span class="line">    nativeWriteString16(mNativePtr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地JNI方法</span></span><br><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeWriteString16</span><span class="params">(<span class="keyword">long</span> nativePtr, String val)</span></span>;</span><br></pre></td></tr></table></figure><p>Parcel用来包装数据，并且提供了大量的read/write方法，最终会调用本地方法<strong>通过<code>Binder</code>读写数据到一块共享内存</strong>。</p><p>这里就与<code>Serializable</code>有很大的不同。**<code>Serializable</code>的原理是通过IO将数据写到一个文件中**。</p><p>那么而这对比，肯定内存的读写性能要高于硬盘文件系统啊，这就是为什么Parcelable比Serializable快很多的原因。</p><h2 id="Parcel的创建"><a href="#Parcel的创建" class="headerlink" title="Parcel的创建"></a>Parcel的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//池子内最大6个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POOL_SIZE = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sOwnedPool = <span class="keyword">new</span> Parcel[POOL_SIZE];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcel[] sHolderPool = <span class="keyword">new</span> Parce[POOL_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Parcel <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Parcel[] pool = sOwnedPool;</span><br><span class="line">    <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">        Parcel p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            p = pool[i];</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//池子中取出一个</span></span><br><span class="line">                pool[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//重置属性</span></span><br><span class="line">                p.mReadWriteHelper = ReadWriteHelper.DEFAULT;</span><br><span class="line">                <span class="comment">//返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果池子是空的则new一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Parcel(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Parcel的回收"><a href="#Parcel的回收" class="headerlink" title="Parcel的回收"></a>Parcel的回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RECYCLE) mStack = <span class="keyword">null</span>;</span><br><span class="line">    freeBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Parcel[] pool;</span><br><span class="line">    <span class="keyword">if</span> (mOwnsNativeParcelObject) &#123;</span><br><span class="line">        pool = sOwnedPool;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNativePtr = <span class="number">0</span>;</span><br><span class="line">        pool = sHolderPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;POOL_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pool[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pool[i] = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢？本来这个Parcel是自由的，有个民警同志带着这个parcel去看守所转了一圈，一旦发现有空牢房，就把Parcel扔进去，就算回收了。等刑满社会需要Parcel的时候再放出来给社会做贡献。</p><h2 id="Parcel的销毁"><a href="#Parcel的销毁" class="headerlink" title="Parcel的销毁"></a>Parcel的销毁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RECYCLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Client did not call Parcel.recycle()&quot;</span>, mStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resetSqaushingState();</span><br><span class="line">    <span class="keyword">if</span> (mNativePtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwnsNativeParcelObject) &#123;</span><br><span class="line">            nativeDestroy(mNativePtr);</span><br><span class="line">            updateNativeSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mNativePtr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>竟然是重写<code>finalize()</code>方法手动销毁的！</p><p><strong><code>finalize()</code>方法会在GC时回调，用来释放非Java对象，比如JNI中的C/C++对象</strong>。此处是为了调用nativeDestroy(mNativePtr)方法释放本地C++对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="Android" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Binder解析</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/12/Binder%E8%A7%A3%E6%9E%90/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/12/Binder%E8%A7%A3%E6%9E%90/</id>
    <published>2021-03-12T03:06:25.000Z</published>
    <updated>2021-05-10T10:04:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AIDL的全称是：Android接口定义语言(即 Android Interface Definition Language)，他定义的只不过是一套模板，实际起作用的是AS通过解释这个模板自动生成的<code>android.os.IInterface</code>的子类接口。作用是依靠<code>Service</code>中转，通过Binder机制来做IPC。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>AIDL支持的数据类型：</p><ul><li>byte</li><li>char</li><li>short</li><li>int</li><li>long</li><li>float</li><li>double</li><li>boolean</li><li>Parcelable</li><li>List</li><li>Map</li></ul><h3 id="定向Tag"><a href="#定向Tag" class="headerlink" title="定向Tag"></a>定向Tag</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookInOut</span><span class="params">(inout Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookIn</span><span class="params">(in Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBookOut</span><span class="params">(out Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>in 数据只能由客户端流向服务端</li><li>out 数据只能由服务端流向客户端</li><li>inout 数据可在服务端与客户端之间双向流通</li></ul><p>如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。</p><blockquote><p>引自<a href="https://www.jianshu.com/p/29999c1a93cd">https://www.jianshu.com/p/29999c1a93cd</a></p></blockquote><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名与项目包名一致</span></span><br><span class="line"><span class="keyword">package</span> com.vee.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   自动生成的接口</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *    我们自己声明的业务函数</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 本接口的默认实现，其中业务方法`getName`返回null;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *   静态内部类，继承自`android.os.Binder.Stub`类型，也遵循AIDL接口</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 用来标记当前Binder，所以采用全类名表示</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.vee.aidltest.IMyAidlInterface&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   构造方法中调用对象方法。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过* 程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端*的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.vee.aidltest.IMyAidlInterface))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((com.vee.aidltest.IMyAidlInterface)iin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.vee.aidltest.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回当前Binder对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span>&#123;</span><br><span class="line">        java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (code)&#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">            &#123;</span><br><span class="line">            reply.writeString(descriptor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_getName:</span><br><span class="line">            &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            java.lang.String _arg0;</span><br><span class="line">            _arg0 = data.readString();</span><br><span class="line">            java.lang.String _result = <span class="keyword">this</span>.getName(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeString(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   自动生成的静态代理，在客户端回调</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">vee</span>.<span class="title">aidltest</span>.<span class="title">IMyAidlInterface</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">        Proxy(android.os.IBinder remote)&#123;</span><br><span class="line">            mRemote = remote;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mRemote;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">            android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">            java.lang.String _result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getName, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getDefaultImpl().getName();</span><br><span class="line">            &#125;</span><br><span class="line">            _reply.readException();</span><br><span class="line">            _result = _reply.readString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.IMyAidlInterface sDefaultImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   用来标记我们自己定义的方法，前缀确定</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当处于客户端时调用，这里就是生成代理</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setDefaultImpl</span><span class="params">(com.vee.aidltest.IMyAidlInterface impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;setDefaultImpl() called twice&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *   当处于客户端时用来获取代理对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.vee.aidltest.<span class="function">IMyAidlInterface <span class="title">getDefaultImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DESCRIPTOR"><a href="#DESCRIPTOR" class="headerlink" title="DESCRIPTOR"></a>DESCRIPTOR</h4><p>Binder的唯一标识，一般用当前Binder的类名表示，比如本例中的<code>com.ryg.chapter_2.aidl.IBookManager</code>。</p><h4 id="asInterface-android-os-IBinder-obj"><a href="#asInterface-android-os-IBinder-obj" class="headerlink" title="asInterface(android.os.IBinder obj)"></a>asInterface(android.os.IBinder obj)</h4><p>用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。</p><h4 id="asBinder"><a href="#asBinder" class="headerlink" title="asBinder"></a>asBinder</h4><p>此方法用于返回当前Binder对象。</p><h4 id="onTransact-重要"><a href="#onTransact-重要" class="headerlink" title="onTransact:重要"></a>onTransact:重要</h4><p>这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为<code>public Boolean onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>。服务端先通过switch(code)可以判断出客户端所请求的是具体哪个方法。还记得这个方法标记吗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   用来标记我们自己定义的方法，前缀确定</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getName = (android.os.IBinderFIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>接着从data中取出目标方法所需的参数（如果目标方法有参数的话），data是个Parcel，所以这里是从二进制流中去读。</p><p>然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值（如果目标方法有返回值的话），而有异常的话也会写进reply。reply也是个Parcel，所以这里是把数据写进了流。</p><p>onTransact方法的执行过程就是这样的。需要注意的是，如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p><h4 id="Proxy-getName"><a href="#Proxy-getName" class="headerlink" title="Proxy#getName"></a>Proxy#getName</h4><p>这个方法运行在客户端。</p><p>首先从Parcel的缓存池中拿到两个parcel对象分别是<code>_data</code>和<code>_reply</code>，然后把参数<code>name</code>写进<code>_data</code>，</p><p>然后调用<code>mRemote</code>对象的<code>transact()</code>方法发起RPC请求，同时挂起当前线程。</p><p>这里调用<code>transact()</code>时传递了<code>Stub.TRANSACTION_getName</code>，RPC到服务端时也是依靠方法ID去调用方法的。</p><p>然后服务端的<code>transact</code>方法会回调，知道RPC过程结束返回后，当前线程继续执行，并从_reply中读取服务端<code>transact</code>方法的返回值或者异常。</p><p>最后先回收刚刚拿到的Parc#el，然后返回<code>_result</code>给客户端。</p><p>这里的<code>mRemote</code>是个<code>IBinder</code>类型，但是后者其实是<code>Binder</code>的接口，那么可以断定<code>mRemote</code>其实就是个<code>Binder</code>。</p><h2 id="提取一下重点"><a href="#提取一下重点" class="headerlink" title="提取一下重点"></a>提取一下重点</h2><p>两个端：</p><ul><li>server</li><li>client</li></ul><p>两个标记：</p><ul><li>DESCRIPTOR：当前Binder的唯一标志</li><li>TRANSACTION_getName：方法的唯一标志</li></ul><p>两个个类型：</p><ul><li>abstract class <code>Stub</code> extends android.os.Binder implements IMyAidlInterface</li><li>static class <code>Proxy</code> implements IMyAidlInterface</li></ul><p>5个方法：</p><ul><li>asInterface</li><li>asBinder</li><li>业务方法</li><li>transact</li><li>onTransact</li></ul><h2 id="梳理流程"><a href="#梳理流程" class="headerlink" title="梳理流程"></a>梳理流程</h2><p><img src="../resource/binder%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt="binder通信机制"></p><ol><li>服务端向<code>ServiceManager</code>注册Binder。</li><li>客户端(通过<code>bindService()</code>回调)拿到Binder，调用<code>Stub.asInterface(binderObj)</code>。在这个方法中通过<code>DESCRIPTOR</code>标志在<code>ServiceManager</code>中去找Binder，如果找到直接返回，找不到就创建这个binder的Proxy对象。Proxy对象中包含被代理的业务方法。</li><li>客户端调用Proxy中代理的业务方法，此时创建两个Parcel：<code>_data</code>和<code>_reply</code>。然后调用代理中的binder的<code>transact()</code>方法，传入<code>TRANSACTION_getName</code>方法标记、_data、_reply，这样就执行了服务端binder中的业务逻辑方法，此时线程挂起。</li><li>客户端调用服务端的<code>transact()</code>方法会回调服务端的<code>onTransact()</code>方法。在这个方法中会根据<code>TRANSACTION_getName</code>判断应该调用哪个业务逻辑方法，然后挂起线程，执行对应的业务逻辑方法，最后在reply中写入异常或结果。</li><li>客户端继续执行<code>transact()</code>方法，从_reply中读取异常或返回值，再继续线程，最后回收_data和_reply并返回_reply中读到的结果。</li></ol><h2 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AIDL&quot;&gt;&lt;a href=&quot;#AIDL&quot; class=&quot;headerlink&quot; title=&quot;AIDL&quot;&gt;&lt;/a&gt;AIDL&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h</summary>
      
    
    
    
    
    <category term="Android binder" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-binder/"/>
    
  </entry>
  
  <entry>
    <title>Android中Message的一辈子</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/09/Android%E4%B8%ADMessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/09/Android%E4%B8%ADMessage%E7%9A%84%E4%B8%80%E8%BE%88%E5%AD%90/</id>
    <published>2021-03-09T12:51:17.000Z</published>
    <updated>2021-05-10T10:04:03.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare();</span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure><p>Looper.prepare()源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化阶段主要做了四件事：</p><ol><li>依赖ThreadLocal给当前线程创建Looper的独立对象；</li><li>在Looper构造方法中创建MessageQueue；</li><li>创建Handler对象;</li><li>启动循环获取消息。</li></ol><h2 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方式1:</span></span><br><span class="line">Message.obtain();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line">mHandler.obtainMessage();</span><br></pre></td></tr></table></figure><h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1:</span></span><br><span class="line">mHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2:</span></span><br><span class="line">msg.sendToTarget();</span><br></pre></td></tr></table></figure><p>最终调用<code>MessageQueue.enqueueMessage(Message msg, long when)</code>。</p><p>所谓的发送消息，其实是干了3件事：</p><ol><li>把消息的状态改为inUse；</li><li>重组MessageQueue中的mMessages链条，把新消息放在队首；</li><li>唤醒Looper所在线程，开始循环处理消息。</li></ol><h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p>Looper的<code>looper</code>方法中循环调用MessageQueue的<code>next</code>方法读取新的message，如果有新消息，就调用handler的<code>dispatchMessage(msg)</code>，进而调用<code>handleCallback()</code>或者调用<code>handleMessage</code>方法。最后通过msg的<code>msg.recycleUnchecked();</code>完成消息的回收复用。</p><p>而此时，如果没有消息，或者下一个消息是延迟消息且还没到时间，looper会回调所有的idleHandler，然后通过linux的epoll机制进入休眠，降低cpu负载，直到调用Looper对象的<code>quitSafely()</code>，进一步调MessageQueue的<code>quit()</code>方法，更改<code>mQuitting</code>标记，使MessageQueue的<code>next</code>方法返回null，跳出Lopper的<code>loop</code>循环，释放了线程。</p><blockquote><p>明天补一张生命周期时序图吧，今天先到这了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="Android handler Message Looper" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-handler-Message-Looper/"/>
    
  </entry>
  
  <entry>
    <title>MessageQueue解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/04/MessageQueue%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/04/MessageQueue%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-04T12:01:35.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>handler发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//最后调用的是queue.enqueueMessage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper循环读取消息并发送给Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// 从MessageQueue中取出Message</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);<span class="comment">//调用Handler的dispatchMessage</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论如何都会回收消息</span></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Message mMessages;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;<span class="comment">//发送的消息必须是闲置状态的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123; <span class="comment">//mQuitting是一个状态，只有MessageQueue的quit方法调用时才这个状态才会为true</span></span><br><span class="line">            msg.recycle();<span class="comment">//回收</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse(); <span class="comment">//改状态为使用中</span></span><br><span class="line">        msg.when = when;<span class="comment">//注意这里赋值</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重点是时间的比较，如果新的msg的时间早于当前的message，那么就把新的msg放在头部。</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();<span class="comment">//如果是异步消息</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//又一个死循环，用来向下遍历队列，</span></span><br><span class="line">                prev = p;<span class="comment">//把当前的msg设为前一个msg</span></span><br><span class="line">                p = p.next;<span class="comment">//当前的msg指向下一个msg</span></span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;<span class="comment">//如果我们设置时间的早于msg的时间，那么就停止遍历</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);<span class="comment">//唤醒线程处理消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，<code>enqueueMessage</code>的作用是采用<code>synchronized</code>同步阻塞的方式操作Message链条的头部，依据Message的延迟时间，打断链条重新排序，同时修改msg的状态，利用共享内存（mMessages）达到线程间通信的目的。</p><p>那么所谓的<code>Handler.sendMessage(msg)</code>是真的发送消息吗？并不是！它只是修改了Looper中持有的MessageQueue中的mMessages的链条顺序，然后等待<code>Looper</code>不断循环获取，再传递回<code>mHandler.dispatchMessage(msg)</code>而已。但这一改加一取，就能达到线程间通信的效果，并让我一直误以为是真的通过序列化之后发送出去。</p><blockquote><p>不看不知道，一看好鸡贼！</p></blockquote><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当loop执行了quit后，程序可能会重启looper，就会返回到这里。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">//只有在第一次遍历时是-1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//用来在线程要进入阻塞之前跟内核线程发送消息，防止用户线程长时间的持有某个对象</span></span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);<span class="comment">//告诉linux的epoll：你丫可以睡nextPollTimeoutMillis这么长时间了！直到handler发送消息调用`mQueue.enqueueMessage()`方法时会被唤醒，或者当前消息到时间时也会被唤醒。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试检索下一个msg，找到就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//靠栅栏停滞，找到下一个异步msg</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//下一个消息还没到时间。设置一个唤醒时段</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是异步消息，prevMsg就是null</span></span><br><span class="line">                        mMessages = msg.next;<span class="comment">//往上提一位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;<span class="comment">//打断链条单独取出</span></span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();<span class="comment">//改变状态为使用中</span></span><br><span class="line">                    <span class="keyword">return</span> msg;<span class="comment">//返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果当前没有消息，把唤醒时钟设为-1，那么意味着线程会沉睡Integer.MaxValue</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///接下来就是喜闻乐见的idleHandler了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();<span class="comment">//如果没有添加过idleHandler，那么就是0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有idleHandler需要执行，那就继续loop</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化一个固定长度的数组</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历执行所有的idleHandler.</span></span><br><span class="line">        <span class="comment">//只有在第一次循环时才会执行到这个代码块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// 强行释放数组中的idleHandler，不会影响ArrayList中的idleHandler和当前正在使用的idleHandler。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();<span class="comment">//回调queueIdle方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重置计数</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment">* waiting for more messages.</span></span><br><span class="line"><span class="comment">* 当线程将要锁定（等待更多消息）时就会回调queueIdle方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当MessqgeQueue已经处理完所有的message，并且将要进入睡眠和等待时这个方法才会被调用。</span></span><br><span class="line"><span class="comment">    * 返回true可以使IdleHandler保持激活状态，那么当下次线程空闲了还会调用，返回false就会移除IdleHandler。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来这玩意根本不是什么Handler的子类，而是MessageQueue的一个内部静态类而已！</p><p>然后我就不太明白这个玩意了，去百了个度，拿到答案如下：</p><p>之前做过冷启动优化，在冷启动的场景有很多的任务其实并不需要马上启动，通常的做法就是做一个延迟启动，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">mHandler.postDelayed(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>将任务延迟启动1000ms，但是这个延迟启动的时间不好确定，只能是自己预估的，对于一些高端手机1000ms可能多了，一些低端手机可能1000ms还不够。这个时候IdelHandler就可以解决这个问题，它能够在CPU空闲的时候再执行指定的任务。</p><p>使用方法也很简单，如下所示，调用addIdleHandler方法就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.IdleHandler idleHandler = <span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Looper.getMainLooper().getQueue().addIdleHandler(idleHandler);</span><br></pre></td></tr></table></figure><p>引自<a href="https://blog.csdn.net/hbdatouerzi/article/details/104148722"></a></p><blockquote><p>我惊叹啊，还能这么玩啊～～想到以前面试官问过我怎么做延迟启动，我回答ContentProvider和StartUp，我觉得是没错的，但是她想要的应该就是这个IdleHandler。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(<span class="meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mIdleHandlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加时有非空判断和线程安全。</p><p>然后具体的操作也是在MessqgeQueue的<code>next</code>方法中进行的。那么IdleHandler怎么判断线程是否空闲呢？看<code>next</code>方法中这一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件1:没有msg或msg还没到执行的时候</span></span><br><span class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">        <span class="comment">//msg时间晚于当前时间</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件2:looper没有停止</span></span><br><span class="line"><span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件3:不存在IdleHandler的话就重新遍历</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以判断线程是否将进入空闲，也就是IdleHandler的执行时机，是依据：</p><ol><li>MessageQueue中没有消息或当前消息不必马上执行；</li><li>Looper没有释放；</li><li>队列中存在IdleHandler。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;handler发送消息：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    
    <category term="Android Handler Looper Message MessageQueue" scheme="https://vee-zhang.github.io/Vee-blog/tags/Android-Handler-Looper-Message-MessageQueue/"/>
    
  </entry>
  
  <entry>
    <title>Handler解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/04/Handler%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/04/Handler%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-04T02:40:11.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中可以看到，<code>handler</code>持有<code>Looper</code>的<code>MessageQueue</code>。</p><h2 id="obtainMessage"><a href="#obtainMessage" class="headerlink" title="obtainMessage"></a>obtainMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler的<code>obtainMessage()</code>其实还是调用<code>Message.obtain()</code>方法，所以直接调用后者反而效率更高。</p><h2 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//最后调用的是queue.enqueueMessage</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessage</code>最后是通过<code>MessageQueue</code>的<code>enqueueMessage</code>实现消息的发送。</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>post其实也是基于消息实现的，但与发送消息不同的是，<code>post</code>是先创建个消息，然后把<code>Runnable</code>类型的参数赋值给msg的<code>callback</code>。前面解读<code>Message</code>的时候了解到，<code>callback</code>是在handler接收到消息的时候才执行，它与handler在同一线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   把Runnable添加到message中，并且在handler所在线程运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();<span class="comment">//从message回收池中取一个闲置msg</span></span><br><span class="line">    m.callback = r;<span class="comment">//赋值callback</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="postDelayed"><a href="#postDelayed" class="headerlink" title="postDelayed"></a>postDelayed</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般面试的会考这个方法，我感觉也没啥啊，无非就是个<code>SystemClock.uptimeMillis()</code>加上设定的延迟时间。</p><p><code>SystemClock.uptimeMillis()</code>是从系统启动后开始累计的时间，并且在系统进入深度睡眠的时候暂停累计。</p><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>前面在<a href="Looper%E8%A7%A3%E8%AF%BB.md">Looper解读</a>里了解到，Looper在<code>loop</code>方法中死循环读取message，然后通过<code>msg.target.dispatchMessage(msg);</code>方法发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Handle system messages here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到，<strong>如果msg的callback不为空，那么就处理callback,反之则处理msg</strong>。这就是为什么给msg添加了callback之后，Handler的<code>handleMessage</code>不会再回调的原因。</p><p>handleCallback:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在当前线程去跑Runnable类型的callback。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构造方法&quot;&gt;&lt;a href=&quot;#构造方法&quot; class=&quot;headerlink&quot; title=&quot;构造方法&quot;&gt;&lt;/a&gt;构造方法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Message解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/03/Message%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/03/Message%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-03T07:03:03.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们都知道创建Message的时候有两种方式：</p><ul><li>构造方法创建（不推荐）。</li><li><code>Message.obtain();</code>（推荐）.</li></ul><p>为了防止OOM，我们一般都是直接用第二种方式，直接从回收池里面拿闲置。那么这个闲置的Message是从哪创建的呢？为什么我们不用先new一个Message，回收池里面就有呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 池子</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">private static Message sPool;</span></span><br><span class="line"><span class="comment">private static int sPoolSize = 0;</span></span><br><span class="line"><span class="comment">private static final int MAX_POOL_SIZE = 50;</span></span><br><span class="line"><span class="comment"><span class="doctag">@UnsupportedAppUsage</span></span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">//打断了链条</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出，<code>obtain()</code>方法检查池子为null,就会自动<code>new</code>一个message出来。而如果不为空，则抽取出来清一下状态返回，并把原来的<code>next</code>前置给<code>sPool</code>，最后把<code>size</code>自减1。</p><p>这里的<code>sPoll</code>比较有意思，叫池子，但其实是个单向链，我觉得叫队列更合适。但是看到后面会发现还是应该叫池子。</p><p>所以，**<code>Message</code>的实质是单向链+Size整数，最多不能超过50个！**</p><h2 id="回收复用指定的Message"><a href="#回收复用指定的Message" class="headerlink" title="回收复用指定的Message"></a>回收复用指定的Message</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but copies the values of an existing</span></span><br><span class="line"><span class="comment"> * message (including its target) into the new one.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orig Original message to copy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.what = orig.what;</span><br><span class="line">    m.arg1 = orig.arg1;</span><br><span class="line">    m.arg2 = orig.arg2;</span><br><span class="line">    m.obj = orig.obj;</span><br><span class="line">    m.replyTo = orig.replyTo;</span><br><span class="line">    m.sendingUid = orig.sendingUid;</span><br><span class="line">    m.workSourceUid = orig.workSourceUid;</span><br><span class="line">    <span class="keyword">if</span> (orig.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.data = <span class="keyword">new</span> Bundle(orig.data);</span><br><span class="line">    &#125;</span><br><span class="line">    m.target = orig.target;</span><br><span class="line">    m.callback = orig.callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要回收并且复用指定的Message，那么就把该message传递到obtain方法中。在方法内部，其实是通过copy值给回收的message来完成。</p><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p><code>obtain</code>方法可以传递一个Handler对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * Same as &#123;@link #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;&#x2F;em&gt; member on the Message returned.</span><br><span class="line">    * @param h  Handler to assign to the returned Message object&#39;s &lt;em&gt;target&lt;&#x2F;em&gt; member.</span><br><span class="line">    * @return A Message object from the global pool.</span><br><span class="line">    *&#x2F;</span><br><span class="line">public static Message obtain(Handler h) &#123;</span><br><span class="line">    Message m &#x3D; obtain();</span><br><span class="line">    m.target &#x3D; h;</span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果指定了对象，就可以通过<code>sendToTarget()</code>方法直接发送Message了。</p><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain(Handler)&#125;, but assigns a callback Runnable on</span></span><br><span class="line"><span class="comment">     * the Message that is returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Handler to assign to the returned Message object&#x27;s &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback Runnable that will execute when the message is handled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.callback = callback;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>obtain</code>方法还可以传递一个<code>Runnable</code>，作用是当message发送到Handler时就会执行这个<code>runnable</code>。而且这个<strong>callback竟然与Handler在同一线程中！！！</strong></p><p>但是一旦给消息设置了<code>callback</code>，实测Handler的<code>handleMessage</code>会失效，这是为啥，要想一想了。</p><h2 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h2><ul><li><code>mHandler.send(msg);</code></li><li><code>msg.sendToTarget();</code></li><li>Parcelable</li></ul><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>设置消息是否异步，这意味着它不受{@link Looper}同步障碍的约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方式我平时很少使用，听说是可以提升消息的重要性，如果标明异步，那么MessageQueue将会由近及远优先处理异步消息，然后再处理同步消息。</p><h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先检测是否在使用中，检测通过才真正的回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回收一个可能正在使用中的Message。</span></span><br><span class="line"><span class="comment"> *   当队列中的Message被释放时，由MessageQueue 和 Looper在内部调用此方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool; <span class="comment">// 添加入链条</span></span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是把当前的Message对象回滚到初始状态，并且标记为「正在使用」。把当前的Message赋值给了<code>next</code>，并且<code>sPoolSize++</code>,表示多了个闲置。</p><p><code>MAX_POOL_SIZE</code>常量的值为50，那么就是<strong>一个App最多能有50个闲置的message</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Message</code>的原理是<strong>整数sPoolSize+静态单向链sPoll</strong>，平时我们使用的message都是从<code>sPoll</code>中取<strong>队首</strong>，状态改为闲置，回收后把状态改成「使用中」，并插回到<strong>队首</strong>，遵循「后进先出」原则，并在<strong>填充</strong>和<strong>回收</strong>时通过<code>synchronized</code>保障线程安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;p&gt;我们都知道创建Message的时候有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造方法创建（不推荐）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Messa</summary>
      
    
    
    
    
    <category term="android message" scheme="https://vee-zhang.github.io/Vee-blog/tags/android-message/"/>
    
  </entry>
  
  <entry>
    <title>Looper解读</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/03/02/Looper%E8%A7%A3%E8%AF%BB/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/03/02/Looper%E8%A7%A3%E8%AF%BB/</id>
    <published>2021-03-02T09:30:46.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="../resource/handler%E7%9B%B8%E5%85%B3/Looper.dotuml.png" alt="类图"></p><h2 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法中创建MessageQueue，并引用当前线程。</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">private Looper(boolean quitAllowed) &#123;</span></span><br><span class="line"><span class="comment">    mQueue = new MessageQueue(quitAllowed);</span></span><br><span class="line"><span class="comment">    mThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Looper.prepare()</code>方法只是为了初始化<code>ThreadLocal</code>。</p><p>之前了解过，<code>ThreadLocal</code>可以包证多线程访问共享变量的线程安全问题。他不像<code>synchronized</code>靠阻塞实现线程安全，而是通过对变量拷贝的方式，使每一个线程都操作自己的拷贝，实现线程安全，所以效率要优于<code>synchronized</code>。<a href="https://www.jianshu.com/p/6fc3bba12f38">详情看这里</a>和<a href="http://www.jasongj.com/java/threadlocal/">这里</a></p><p>ThreadLocal在此处的使用是为了保证每个线程都只能分配到一个Looper对象，多次调用<code>Looper.prepary()</code>方法会抛出异常。而且在其他线程去操作这个Looper对象可以保证线程安全，比如在主线程中调用<code>mHandler.getLooper().quitSafely()</code>来终止子线程的Looper对象的<code>loop()</code>循环。</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p>只看核心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//其实就是从threadLocal中取出looper</span></span><br><span class="line">    <span class="comment">//省略判空</span></span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>; <span class="comment">//改变状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//拿到MessageQueue</span></span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来就是启动个死循环，为什么不用while而用for呢？</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// 从MessageQueue中取出Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果池子里面没有msg了则终止循环，所以这里并不是一个真正的死循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);<span class="comment">//调用Handler的dispatchMessage</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无论如何都会回收消息</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里死循环的写法比较特殊，为什么不用<code>while(true)</code>或者<code>do-while(true)</code>呢？一开始总是想不明白。后来发现，用while系列循环，无论如何都要传递个表达式进去，那么就涉及到了内存占用。而用空for循环，则不必创建任何变量或结构体，能够最大限度的降低内存占用，真是学到了。</p><p>今天又突然想到，既然涉及到表达式，那么每次循环的时候都需要判断表达式是否成立，无可避免浪费了cpu，同时带来了cpu计算单元做无效计算带来的性能损失。</p><h2 id="主线程中为何不ANR也不会内存泄露"><a href="#主线程中为何不ANR也不会内存泄露" class="headerlink" title="主线程中为何不ANR也不会内存泄露"></a>主线程中为何不ANR也不会内存泄露</h2><p>我们都知道线程一旦运行完毕就会回收，那么主线程中没有执行任何动作时为何不会回收呢？原因就是因为looper在死循环，阻塞了主线程的回收，那么相应的一旦不再死循环，程序也就退出了。Android同时利用Looper的死循环，发送消息，比如通知View重绘等等。</p><h2 id="会不会阻塞子线程呢？"><a href="#会不会阻塞子线程呢？" class="headerlink" title="会不会阻塞子线程呢？"></a>会不会阻塞子线程呢？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">        Message msg = Message.obtain(handler, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;&quot;</span>, <span class="string">&quot;run: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        msg.sendToTarget();</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;这里永远都不会执行&quot;</span>, <span class="string">&quot;run:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用<strong>Profile</strong>持续观察之后发现：答案是会！CPU会一直被占用，线程池也无法回收该线程！</p><h2 id="终止loop"><a href="#终止loop" class="headerlink" title="终止loop"></a>终止loop</h2><p>所以为了尽可能减少CPU浪费，应该调用<code>handler.getLooper().quitSafely();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看<code>mQueue.quit(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是修改了<code>mQuitting = true;</code>，这就是个标记，用来判断是否终止死循环。造成的效果呢当然是在<code>loop</code>方法的死循环中调用<code>mqueue.next()</code>时，会收到下面的影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dispose() &#123;</span><br><span class="line">    if (mPtr !&#x3D; 0) &#123;</span><br><span class="line">        nativeDestroy(mPtr);</span><br><span class="line">        mPtr &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native static void nativeDestroy(long ptr);</span><br></pre></td></tr></table></figure><p>直接返回null，而在Looper的<code>loop</code>方法的死循环中有这样的判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line">if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; No message indicates that the message queue is quitting.</span><br><span class="line">    me.mLogging.println(&quot;注意啦，真的停啦～～～&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果<code>queue.next</code>返回null那么就终止循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../resource/handler%E7%9B%B8%E5%85%B3/Looper.dotuml.png&quot; alt</summary>
      
    
    
    
    
    <category term="android" scheme="https://vee-zhang.github.io/Vee-blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment在Activity中的生命周期</title>
    <link href="https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://vee-zhang.github.io/Vee-blog/2021/02/26/Fragment%E5%9C%A8Activity%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-02-26T03:17:35.000Z</published>
    <updated>2021-05-10T10:04:03.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记忆方式"><a href="#记忆方式" class="headerlink" title="记忆方式"></a>记忆方式</h2><p>Fragment的<code>onAttach</code>,<code>onCreate</code>,<code>onCreateView</code>,<code>onViewCreated</code>在附加到Activity时执行，如<code>setContentView</code>或者<code>add</code>,<code>replace</code>时。</p><p>Fragment的<code>onResume</code>是在Activity的<code>onResume</code>执行完之后才会执行，而其他生命周期都在Activity的<code>super.onXXX</code>内执行。</p><p>跳转时，前一个页面的生命周期走到<code>onPause</code>时暂停，等待后一个页面的生命周期走到<code>onResume</code>之后，再继续执行<code>onStop</code>；同理，返回时后一个页面走到<code>onPause</code>时暂停，前一个页面<code>onRestart</code>,<code>onStart</code>,<code>onResume</code>之后，再继续执行剩下的<code>onStop</code>,<code>onDestory</code>。</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>Fragment的懒加载主要是用于<code>ViewPager</code>中，ViewPager会在加载fragment之前调用其<code>setUserVisibleHint()</code>方法。所以<code>setUserVisibleHint()</code>是在<code>onActtch()</code>方法之前调用。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/source/resource/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="生命周期"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onCreate: 前</span><br><span class="line">D: FirstActivity&#39;s super.onCreate: 后</span><br><span class="line">D: FirstActivity&#39;s setContentView: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onAttach: </span><br><span class="line">D: FirstFragment&#39;s onCreate: </span><br><span class="line">D: FirstFragment&#39;s onCreateView: </span><br><span class="line">D: FirstFragment&#39;s onViewCreated: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s setContentView: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line"></span><br><span class="line">D: FirstFragment&#39;s onActivityCreated: </span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><p>fragment的<code>onAttach</code>，<code>onCreate</code>，<code>onCreateView</code>，<code>onViewCreated</code>是在Activity的<code>setContentView</code>中执行的。</p><p>想一下就知道，Activity的<code>setContentView</code>的目的是从xml中加载View，而我把fragment写在了xml里面。</p><blockquote><p>这里有个小插曲，事实证明，Activity的<code>super.onCreate</code>可以写在<code>setContentView</code>之后，但是xml中存在fragment时就会报错。</p></blockquote><p>fragment的<code>onActivityCreated</code>、<code>onStart</code>是在Activity的<code>super.onStart</code>方法中执行。</p><p>fragment的<code>onResume</code>是在activity的<code>super.onResume</code>之后执行。</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 前</span><br><span class="line">D: SecondActivity&#39;s super.onCreate: 后</span><br><span class="line">D: SecondActivity&#39;s setContentView: 前</span><br><span class="line">D: SecondFragment&#39;s onAttach: </span><br><span class="line">D: SecondFragment&#39;s onCreate: </span><br><span class="line">D: SecondFragment&#39;s onCreateView: </span><br><span class="line">D: SecondFragment&#39;s onViewCreated: </span><br><span class="line">D: SecondActivity&#39;s setContentView: 后</span><br><span class="line">D: SecondActivity&#39;s super.onStart: 前</span><br><span class="line">D: SecondFragment&#39;s onActivityCreated: </span><br><span class="line">D: SecondFragment&#39;s onStart: </span><br><span class="line">D: SecondActivity&#39;s super.onStart: 后</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 前</span><br><span class="line">D: SecondActivity&#39;s super.onResume: 后</span><br><span class="line">D: SecondFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><p>fragment的<code>onPause</code>是在Activity的<code>super.onPause</code>中执行。</p><p>当第二个含有fragment的Activity可见后，上一个Activity的生命周期才会继续。</p><p>然后上一个fragment的<code>onStop</code>在Activity的<code>onStop</code>中执行。</p><p><strong>注意</strong>，前一个Activity执行到<code>onPause</code>，然后第二个Activity生命周期完成后，前一个Activity才会执行<code>onStop</code>。</p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D: SecondActivity&#39;s super.onPause: 前</span><br><span class="line">D: SecondFragment&#39;s onPause: </span><br><span class="line">D: SecondActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onStop: 前</span><br><span class="line">D: SecondFragment&#39;s onStop: </span><br><span class="line">D: SecondActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: SecondFragment&#39;s onDestroyView: </span><br><span class="line">D: SecondFragment&#39;s onDestroy: </span><br><span class="line">D: SecondFragment&#39;s onDetach: </span><br><span class="line">D: SecondActivity&#39;s super.onDestroy: 后</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先执行第二个Activity的<code>onPause</code>。</p><p>再回调前一个Activity的<code>onRestart</code>。</p><p>fragment的<code>onStart</code>在Activity的<code>super.onStart</code>中执行。</p><p>fragment的<code>onResume</code>在Activity的<code>super.onResume</code>中执行。</p><p>fragment的<code>onStop</code>在Activity的<code>super.onStop</code>中执行。</p><p>fragment的<code>onDestroyView</code>、<code>onDestroy</code>、<code>onDetach</code>在Activity的<code>super.onDestroy</code>中执行。</p><p><strong>注意</strong>fragment的<code>onResume</code>是在Activity的<code>onResume</code>之后执行的！！！</p><h2 id="退入后台"><a href="#退入后台" class="headerlink" title="退入后台"></a>退入后台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br></pre></td></tr></table></figure><h2 id="回到前台"><a href="#回到前台" class="headerlink" title="回到前台"></a>回到前台</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onRestart: 前</span><br><span class="line">D: FirstActivity&#39;s super.onRestart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onStart: 前</span><br><span class="line">D: FirstFragment&#39;s onStart: </span><br><span class="line">D: FirstActivity&#39;s super.onStart: 后</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 前</span><br><span class="line">D: FirstActivity&#39;s super.onResume: 后</span><br><span class="line">D: FirstFragment&#39;s onResume: </span><br></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D: FirstActivity&#39;s super.onPause: 前</span><br><span class="line">D: FirstFragment&#39;s onPause: </span><br><span class="line">D: FirstActivity&#39;s super.onPause: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onStop: 前</span><br><span class="line">D: FirstFragment&#39;s onStop: </span><br><span class="line">D: FirstActivity&#39;s super.onStop: 后</span><br><span class="line"></span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 前</span><br><span class="line">D: FirstFragment&#39;s onDestroyView: </span><br><span class="line">D: FirstFragment&#39;s onDestroy: </span><br><span class="line">D: FirstFragment&#39;s onDetach: </span><br><span class="line">D: FirstActivity&#39;s super.onDestroy: 后</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记忆方式&quot;&gt;&lt;a href=&quot;#记忆方式&quot; class=&quot;headerlink&quot; title=&quot;记忆方式&quot;&gt;&lt;/a&gt;记忆方式&lt;/h2&gt;&lt;p&gt;Fragment的&lt;code&gt;onAttach&lt;/code&gt;,&lt;code&gt;onCreate&lt;/code&gt;,&lt;code&gt;onC</summary>
      
    
    
    
    
    <category term="android,生命周期,fragment,activity" scheme="https://vee-zhang.github.io/Vee-blog/tags/android-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-fragment-activity/"/>
    
  </entry>
  
</feed>
